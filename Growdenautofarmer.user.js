// ==UserScript==
// @name        Growden autofarm
// @author      5
// @description O = farm without buying
// @description P = farm with buying
// @version     1
// @match       *://*.growden.io/*
// @run-at      document-start
// ==/UserScript==

(() => {
var __webpack_modules__ = ({
"./node_modules/@colyseus/schema/build/umd/index.js"(__unused_rspack_module, exports, __webpack_require__) {
/* provided dependency */ var Buffer = __webpack_require__("./node_modules/buffer/index.js")["Buffer"];
/* provided dependency */ var console = __webpack_require__("./node_modules/console-browserify/index.js");
(function (global, factory) {
     true ? factory(exports) :
    0;
})(this, (function (exports) { 'use strict';

    const SWITCH_TO_STRUCTURE = 255; // (decoding collides with DELETE_AND_ADD + fieldIndex = 63)
    const TYPE_ID = 213;
    /**
     * Encoding Schema field operations.
     */
    exports.OPERATION = void 0;
    (function (OPERATION) {
        OPERATION[OPERATION["ADD"] = 128] = "ADD";
        OPERATION[OPERATION["REPLACE"] = 0] = "REPLACE";
        OPERATION[OPERATION["DELETE"] = 64] = "DELETE";
        OPERATION[OPERATION["DELETE_AND_MOVE"] = 96] = "DELETE_AND_MOVE";
        OPERATION[OPERATION["MOVE_AND_ADD"] = 160] = "MOVE_AND_ADD";
        OPERATION[OPERATION["DELETE_AND_ADD"] = 192] = "DELETE_AND_ADD";
        /**
         * Collection operations
         */
        OPERATION[OPERATION["CLEAR"] = 10] = "CLEAR";
        /**
         * ArraySchema operations
         */
        OPERATION[OPERATION["REVERSE"] = 15] = "REVERSE";
        OPERATION[OPERATION["MOVE"] = 32] = "MOVE";
        OPERATION[OPERATION["DELETE_BY_REFID"] = 33] = "DELETE_BY_REFID";
        OPERATION[OPERATION["ADD_BY_REFID"] = 129] = "ADD_BY_REFID";
    })(exports.OPERATION || (exports.OPERATION = {}));

    Symbol.metadata ??= Symbol.for("Symbol.metadata");

    const $track = "~track";
    const $encoder = "~encoder";
    const $decoder = "~decoder";
    const $filter = "~filter";
    const $getByIndex = "~getByIndex";
    const $deleteByIndex = "~deleteByIndex";
    /**
     * Used to hold ChangeTree instances whitin the structures
     */
    const $changes = '~changes';
    /**
     * Used to keep track of the type of the child elements of a collection
     * (MapSchema, ArraySchema, etc.)
     */
    const $childType = '~childType';
    /**
     * Optional "discard" method for custom types (ArraySchema)
     * (Discards changes for next serialization)
     */
    const $onEncodeEnd = '~onEncodeEnd';
    /**
     * When decoding, this method is called after the instance is fully decoded
     */
    const $onDecodeEnd = "~onDecodeEnd";
    /**
     * Metadata
     */
    const $descriptors = "~descriptors";
    const $numFields = "~__numFields";
    const $refTypeFieldIndexes = "~__refTypeFieldIndexes";
    const $viewFieldIndexes = "~__viewFieldIndexes";
    const $fieldIndexesByViewTag = "$__fieldIndexesByViewTag";

    // @ts-nocheck
    /**
     * msgpack implementation highly based on notepack.io
     * https://github.com/darrachequesne/notepack
     */
    let textEncoder;
    // @ts-ignore
    try {
        textEncoder = new TextEncoder();
    }
    catch (e) { }
    const _convoBuffer$1 = new ArrayBuffer(8);
    const _int32$1 = new Int32Array(_convoBuffer$1);
    const _float32$1 = new Float32Array(_convoBuffer$1);
    const _float64$1 = new Float64Array(_convoBuffer$1);
    const _int64$1 = new BigInt64Array(_convoBuffer$1);
    const hasBufferByteLength = (typeof Buffer !== 'undefined' && Buffer.byteLength);
    const utf8Length = (hasBufferByteLength)
        ? Buffer.byteLength // node
        : function (str, _) {
            var c = 0, length = 0;
            for (var i = 0, l = str.length; i < l; i++) {
                c = str.charCodeAt(i);
                if (c < 0x80) {
                    length += 1;
                }
                else if (c < 0x800) {
                    length += 2;
                }
                else if (c < 0xd800 || c >= 0xe000) {
                    length += 3;
                }
                else {
                    i++;
                    length += 4;
                }
            }
            return length;
        };
    function utf8Write(view, str, it) {
        var c = 0;
        for (var i = 0, l = str.length; i < l; i++) {
            c = str.charCodeAt(i);
            if (c < 0x80) {
                view[it.offset++] = c;
            }
            else if (c < 0x800) {
                view[it.offset] = 0xc0 | (c >> 6);
                view[it.offset + 1] = 0x80 | (c & 0x3f);
                it.offset += 2;
            }
            else if (c < 0xd800 || c >= 0xe000) {
                view[it.offset] = 0xe0 | (c >> 12);
                view[it.offset + 1] = 0x80 | (c >> 6 & 0x3f);
                view[it.offset + 2] = 0x80 | (c & 0x3f);
                it.offset += 3;
            }
            else {
                i++;
                c = 0x10000 + (((c & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));
                view[it.offset] = 0xf0 | (c >> 18);
                view[it.offset + 1] = 0x80 | (c >> 12 & 0x3f);
                view[it.offset + 2] = 0x80 | (c >> 6 & 0x3f);
                view[it.offset + 3] = 0x80 | (c & 0x3f);
                it.offset += 4;
            }
        }
    }
    function int8$1(bytes, value, it) {
        bytes[it.offset++] = value & 255;
    }
    function uint8$1(bytes, value, it) {
        bytes[it.offset++] = value & 255;
    }
    function int16$1(bytes, value, it) {
        bytes[it.offset++] = value & 255;
        bytes[it.offset++] = (value >> 8) & 255;
    }
    function uint16$1(bytes, value, it) {
        bytes[it.offset++] = value & 255;
        bytes[it.offset++] = (value >> 8) & 255;
    }
    function int32$1(bytes, value, it) {
        bytes[it.offset++] = value & 255;
        bytes[it.offset++] = (value >> 8) & 255;
        bytes[it.offset++] = (value >> 16) & 255;
        bytes[it.offset++] = (value >> 24) & 255;
    }
    function uint32$1(bytes, value, it) {
        const b4 = value >> 24;
        const b3 = value >> 16;
        const b2 = value >> 8;
        const b1 = value;
        bytes[it.offset++] = b1 & 255;
        bytes[it.offset++] = b2 & 255;
        bytes[it.offset++] = b3 & 255;
        bytes[it.offset++] = b4 & 255;
    }
    function int64$1(bytes, value, it) {
        const high = Math.floor(value / Math.pow(2, 32));
        const low = value >>> 0;
        uint32$1(bytes, low, it);
        uint32$1(bytes, high, it);
    }
    function uint64$1(bytes, value, it) {
        const high = (value / Math.pow(2, 32)) >> 0;
        const low = value >>> 0;
        uint32$1(bytes, low, it);
        uint32$1(bytes, high, it);
    }
    function bigint64$1(bytes, value, it) {
        _int64$1[0] = BigInt.asIntN(64, value);
        int32$1(bytes, _int32$1[0], it);
        int32$1(bytes, _int32$1[1], it);
    }
    function biguint64$1(bytes, value, it) {
        _int64$1[0] = BigInt.asIntN(64, value);
        int32$1(bytes, _int32$1[0], it);
        int32$1(bytes, _int32$1[1], it);
    }
    function float32$1(bytes, value, it) {
        _float32$1[0] = value;
        int32$1(bytes, _int32$1[0], it);
    }
    function float64$1(bytes, value, it) {
        _float64$1[0] = value;
        int32$1(bytes, _int32$1[0 ], it);
        int32$1(bytes, _int32$1[1 ], it);
    }
    function boolean$1(bytes, value, it) {
        bytes[it.offset++] = value ? 1 : 0; // uint8
    }
    function string$1(bytes, value, it) {
        // encode `null` strings as empty.
        if (!value) {
            value = "";
        }
        let length = utf8Length(value, "utf8");
        let size = 0;
        // fixstr
        if (length < 0x20) {
            bytes[it.offset++] = length | 0xa0;
            size = 1;
        }
        // str 8
        else if (length < 0x100) {
            bytes[it.offset++] = 0xd9;
            bytes[it.offset++] = length % 255;
            size = 2;
        }
        // str 16
        else if (length < 0x10000) {
            bytes[it.offset++] = 0xda;
            uint16$1(bytes, length, it);
            size = 3;
        }
        // str 32
        else if (length < 0x100000000) {
            bytes[it.offset++] = 0xdb;
            uint32$1(bytes, length, it);
            size = 5;
        }
        else {
            throw new Error('String too long');
        }
        utf8Write(bytes, value, it);
        return size + length;
    }
    function number$1(bytes, value, it) {
        if (isNaN(value)) {
            return number$1(bytes, 0, it);
        }
        else if (!isFinite(value)) {
            return number$1(bytes, (value > 0) ? Number.MAX_SAFE_INTEGER : -Number.MAX_SAFE_INTEGER, it);
        }
        else if (value !== (value | 0)) {
            if (Math.abs(value) <= 3.4028235e+38) { // range check
                _float32$1[0] = value;
                if (Math.abs(Math.abs(_float32$1[0]) - Math.abs(value)) < 1e-4) { // precision check; adjust 1e-n (n = precision) to in-/decrease acceptable precision loss
                    // now we know value is in range for f32 and has acceptable precision for f32
                    bytes[it.offset++] = 0xca;
                    float32$1(bytes, value, it);
                    return 5;
                }
            }
            bytes[it.offset++] = 0xcb;
            float64$1(bytes, value, it);
            return 9;
        }
        if (value >= 0) {
            // positive fixnum
            if (value < 0x80) {
                bytes[it.offset++] = value & 255; // uint8
                return 1;
            }
            // uint 8
            if (value < 0x100) {
                bytes[it.offset++] = 0xcc;
                bytes[it.offset++] = value & 255; // uint8
                return 2;
            }
            // uint 16
            if (value < 0x10000) {
                bytes[it.offset++] = 0xcd;
                uint16$1(bytes, value, it);
                return 3;
            }
            // uint 32
            if (value < 0x100000000) {
                bytes[it.offset++] = 0xce;
                uint32$1(bytes, value, it);
                return 5;
            }
            // uint 64
            bytes[it.offset++] = 0xcf;
            uint64$1(bytes, value, it);
            return 9;
        }
        else {
            // negative fixnum
            if (value >= -32) {
                bytes[it.offset++] = 0xe0 | (value + 0x20);
                return 1;
            }
            // int 8
            if (value >= -128) {
                bytes[it.offset++] = 0xd0;
                int8$1(bytes, value, it);
                return 2;
            }
            // int 16
            if (value >= -32768) {
                bytes[it.offset++] = 0xd1;
                int16$1(bytes, value, it);
                return 3;
            }
            // int 32
            if (value >= -2147483648) {
                bytes[it.offset++] = 0xd2;
                int32$1(bytes, value, it);
                return 5;
            }
            // int 64
            bytes[it.offset++] = 0xd3;
            int64$1(bytes, value, it);
            return 9;
        }
    }
    const encode = {
        int8: int8$1,
        uint8: uint8$1,
        int16: int16$1,
        uint16: uint16$1,
        int32: int32$1,
        uint32: uint32$1,
        int64: int64$1,
        uint64: uint64$1,
        bigint64: bigint64$1,
        biguint64: biguint64$1,
        float32: float32$1,
        float64: float64$1,
        boolean: boolean$1,
        string: string$1,
        number: number$1,
        utf8Write,
        utf8Length,
    };

    // @ts-nocheck
    // force little endian to facilitate decoding on multiple implementations
    const _convoBuffer = new ArrayBuffer(8);
    const _int32 = new Int32Array(_convoBuffer);
    const _float32 = new Float32Array(_convoBuffer);
    const _float64 = new Float64Array(_convoBuffer);
    const _uint64 = new BigUint64Array(_convoBuffer);
    const _int64 = new BigInt64Array(_convoBuffer);
    function utf8Read(bytes, it, length) {
        // boundary check
        if (length > bytes.length - it.offset) {
            length = bytes.length - it.offset;
        }
        var string = '', chr = 0;
        for (var i = it.offset, end = it.offset + length; i < end; i++) {
            var byte = bytes[i];
            if ((byte & 0x80) === 0x00) {
                string += String.fromCharCode(byte);
                continue;
            }
            if ((byte & 0xe0) === 0xc0) {
                string += String.fromCharCode(((byte & 0x1f) << 6) |
                    (bytes[++i] & 0x3f));
                continue;
            }
            if ((byte & 0xf0) === 0xe0) {
                string += String.fromCharCode(((byte & 0x0f) << 12) |
                    ((bytes[++i] & 0x3f) << 6) |
                    ((bytes[++i] & 0x3f) << 0));
                continue;
            }
            if ((byte & 0xf8) === 0xf0) {
                chr = ((byte & 0x07) << 18) |
                    ((bytes[++i] & 0x3f) << 12) |
                    ((bytes[++i] & 0x3f) << 6) |
                    ((bytes[++i] & 0x3f) << 0);
                if (chr >= 0x010000) { // surrogate pair
                    chr -= 0x010000;
                    string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);
                }
                else {
                    string += String.fromCharCode(chr);
                }
                continue;
            }
            // (do not throw error to avoid server/client from crashing due to hack attemps)
            // throw new Error('Invalid byte ' + byte.toString(16));
            console.error('decode.utf8Read(): Invalid byte ' + byte + ' at offset ' + i + '. Skip to end of string: ' + (it.offset + length));
            break;
        }
        it.offset += length;
        return string;
    }
    function int8(bytes, it) {
        return uint8(bytes, it) << 24 >> 24;
    }
    function uint8(bytes, it) {
        return bytes[it.offset++];
    }
    function int16(bytes, it) {
        return uint16(bytes, it) << 16 >> 16;
    }
    function uint16(bytes, it) {
        return bytes[it.offset++] | bytes[it.offset++] << 8;
    }
    function int32(bytes, it) {
        return bytes[it.offset++] | bytes[it.offset++] << 8 | bytes[it.offset++] << 16 | bytes[it.offset++] << 24;
    }
    function uint32(bytes, it) {
        return int32(bytes, it) >>> 0;
    }
    function float32(bytes, it) {
        _int32[0] = int32(bytes, it);
        return _float32[0];
    }
    function float64(bytes, it) {
        _int32[0 ] = int32(bytes, it);
        _int32[1 ] = int32(bytes, it);
        return _float64[0];
    }
    function int64(bytes, it) {
        const low = uint32(bytes, it);
        const high = int32(bytes, it) * Math.pow(2, 32);
        return high + low;
    }
    function uint64(bytes, it) {
        const low = uint32(bytes, it);
        const high = uint32(bytes, it) * Math.pow(2, 32);
        return high + low;
    }
    function bigint64(bytes, it) {
        _int32[0] = int32(bytes, it);
        _int32[1] = int32(bytes, it);
        return _int64[0];
    }
    function biguint64(bytes, it) {
        _int32[0] = int32(bytes, it);
        _int32[1] = int32(bytes, it);
        return _uint64[0];
    }
    function boolean(bytes, it) {
        return uint8(bytes, it) > 0;
    }
    function string(bytes, it) {
        const prefix = bytes[it.offset++];
        let length;
        if (prefix < 0xc0) {
            // fixstr
            length = prefix & 0x1f;
        }
        else if (prefix === 0xd9) {
            length = uint8(bytes, it);
        }
        else if (prefix === 0xda) {
            length = uint16(bytes, it);
        }
        else if (prefix === 0xdb) {
            length = uint32(bytes, it);
        }
        return utf8Read(bytes, it, length);
    }
    function number(bytes, it) {
        const prefix = bytes[it.offset++];
        if (prefix < 0x80) {
            // positive fixint
            return prefix;
        }
        else if (prefix === 0xca) {
            // float 32
            return float32(bytes, it);
        }
        else if (prefix === 0xcb) {
            // float 64
            return float64(bytes, it);
        }
        else if (prefix === 0xcc) {
            // uint 8
            return uint8(bytes, it);
        }
        else if (prefix === 0xcd) {
            // uint 16
            return uint16(bytes, it);
        }
        else if (prefix === 0xce) {
            // uint 32
            return uint32(bytes, it);
        }
        else if (prefix === 0xcf) {
            // uint 64
            return uint64(bytes, it);
        }
        else if (prefix === 0xd0) {
            // int 8
            return int8(bytes, it);
        }
        else if (prefix === 0xd1) {
            // int 16
            return int16(bytes, it);
        }
        else if (prefix === 0xd2) {
            // int 32
            return int32(bytes, it);
        }
        else if (prefix === 0xd3) {
            // int 64
            return int64(bytes, it);
        }
        else if (prefix > 0xdf) {
            // negative fixint
            return (0xff - prefix + 1) * -1;
        }
    }
    function stringCheck(bytes, it) {
        const prefix = bytes[it.offset];
        return (
        // fixstr
        (prefix < 0xc0 && prefix > 0xa0) ||
            // str 8
            prefix === 0xd9 ||
            // str 16
            prefix === 0xda ||
            // str 32
            prefix === 0xdb);
    }
    const decode = {
        utf8Read,
        int8,
        uint8,
        int16,
        uint16,
        int32,
        uint32,
        float32,
        float64,
        int64,
        uint64,
        bigint64,
        biguint64,
        boolean,
        string,
        number,
        stringCheck,
    };

    const registeredTypes = {};
    const identifiers = new Map();
    function registerType(identifier, definition) {
        if (definition.constructor) {
            identifiers.set(definition.constructor, identifier);
            registeredTypes[identifier] = definition;
        }
        if (definition.encode) {
            encode[identifier] = definition.encode;
        }
        if (definition.decode) {
            decode[identifier] = definition.decode;
        }
    }
    function getType(identifier) {
        return registeredTypes[identifier];
    }
    function defineCustomTypes(types) {
        for (const identifier in types) {
            registerType(identifier, types[identifier]);
        }
        return (t) => type(t);
    }

    class TypeContext {
        /**
         * For inheritance support
         * Keeps track of which classes extends which. (parent -> children)
         */
        static { this.inheritedTypes = new Map(); }
        static { this.cachedContexts = new Map(); }
        static register(target) {
            const parent = Object.getPrototypeOf(target);
            if (parent !== Schema) {
                let inherits = TypeContext.inheritedTypes.get(parent);
                if (!inherits) {
                    inherits = new Set();
                    TypeContext.inheritedTypes.set(parent, inherits);
                }
                inherits.add(target);
            }
        }
        static cache(rootClass) {
            let context = TypeContext.cachedContexts.get(rootClass);
            if (!context) {
                context = new TypeContext(rootClass);
                TypeContext.cachedContexts.set(rootClass, context);
            }
            return context;
        }
        constructor(rootClass) {
            this.types = {};
            this.schemas = new Map();
            this.hasFilters = false;
            this.parentFiltered = {};
            if (rootClass) {
                this.discoverTypes(rootClass);
            }
        }
        has(schema) {
            return this.schemas.has(schema);
        }
        get(typeid) {
            return this.types[typeid];
        }
        add(schema, typeid = this.schemas.size) {
            // skip if already registered
            if (this.schemas.has(schema)) {
                return false;
            }
            this.types[typeid] = schema;
            //
            // Workaround to allow using an empty Schema (with no `@type()` fields)
            //
            if (schema[Symbol.metadata] === undefined) {
                Metadata.initialize(schema);
            }
            this.schemas.set(schema, typeid);
            return true;
        }
        getTypeId(klass) {
            return this.schemas.get(klass);
        }
        discoverTypes(klass, parentType, parentIndex, parentHasViewTag) {
            if (parentHasViewTag) {
                this.registerFilteredByParent(klass, parentType, parentIndex);
            }
            // skip if already registered
            if (!this.add(klass)) {
                return;
            }
            // add classes inherited from this base class
            TypeContext.inheritedTypes.get(klass)?.forEach((child) => {
                this.discoverTypes(child, parentType, parentIndex, parentHasViewTag);
            });
            // add parent classes
            let parent = klass;
            while ((parent = Object.getPrototypeOf(parent)) &&
                parent !== Schema && // stop at root (Schema)
                parent !== Function.prototype // stop at root (non-Schema)
            ) {
                this.discoverTypes(parent);
            }
            const metadata = (klass[Symbol.metadata] ??= {});
            // if any schema/field has filters, mark "context" as having filters.
            if (metadata[$viewFieldIndexes]) {
                this.hasFilters = true;
            }
            for (const fieldIndex in metadata) {
                const index = fieldIndex;
                const fieldType = metadata[index].type;
                const fieldHasViewTag = (metadata[index].tag !== undefined);
                if (typeof (fieldType) === "string") {
                    continue;
                }
                if (typeof (fieldType) === "function") {
                    this.discoverTypes(fieldType, klass, index, parentHasViewTag || fieldHasViewTag);
                }
                else {
                    const type = Object.values(fieldType)[0];
                    // skip primitive types
                    if (typeof (type) === "string") {
                        continue;
                    }
                    this.discoverTypes(type, klass, index, parentHasViewTag || fieldHasViewTag);
                }
            }
        }
        /**
         * Keep track of which classes have filters applied.
         * Format: `${typeid}-${parentTypeid}-${parentIndex}`
         */
        registerFilteredByParent(schema, parentType, parentIndex) {
            const typeid = this.schemas.get(schema) ?? this.schemas.size;
            let key = `${typeid}`;
            if (parentType) {
                key += `-${this.schemas.get(parentType)}`;
            }
            key += `-${parentIndex}`;
            this.parentFiltered[key] = true;
        }
        debug() {
            let parentFiltered = "";
            for (const key in this.parentFiltered) {
                const keys = key.split("-").map(Number);
                const fieldIndex = keys.pop();
                parentFiltered += `\n\t\t`;
                parentFiltered += `${key}: ${keys.reverse().map((id, i) => {
                const klass = this.types[id];
                const metadata = klass[Symbol.metadata];
                let txt = klass.name;
                if (i === 0) {
                    txt += `[${metadata[fieldIndex].name}]`;
                }
                return `${txt}`;
            }).join(" -> ")}`;
            }
            return `TypeContext ->\n` +
                `\tSchema types: ${this.schemas.size}\n` +
                `\thasFilters: ${this.hasFilters}\n` +
                `\tparentFiltered:${parentFiltered}`;
        }
    }

    function getNormalizedType(type) {
        if (Array.isArray(type)) {
            return { array: getNormalizedType(type[0]) };
        }
        else if (typeof (type['type']) !== "undefined") {
            return type['type'];
        }
        else if (isTSEnum(type)) {
            // Detect TS Enum type (either string or number)
            return Object.keys(type).every(key => typeof type[key] === "string")
                ? "string"
                : "number";
        }
        else if (typeof type === "object" && type !== null) {
            // Handle collection types
            const collectionType = Object.keys(type).find(k => registeredTypes[k] !== undefined);
            if (collectionType) {
                type[collectionType] = getNormalizedType(type[collectionType]);
                return type;
            }
        }
        return type;
    }
    function isTSEnum(_enum) {
        if (typeof _enum === 'function' && _enum[Symbol.metadata]) {
            return false;
        }
        const keys = Object.keys(_enum);
        const numericFields = keys.filter(k => /\d+/.test(k));
        // Check for number enum (has numeric keys and reverse mapping)
        if (numericFields.length > 0 && numericFields.length === (keys.length / 2) && _enum[_enum[numericFields[0]]] == numericFields[0]) {
            return true;
        }
        // Check for string enum (all values are strings and keys match values)
        if (keys.length > 0 && keys.every(key => typeof _enum[key] === 'string' && _enum[key] === key)) {
            return true;
        }
        return false;
    }
    const Metadata = {
        addField(metadata, index, name, type, descriptor) {
            if (index > 64) {
                throw new Error(`Can't define field '${name}'.\nSchema instances may only have up to 64 fields.`);
            }
            metadata[index] = Object.assign(metadata[index] || {}, // avoid overwriting previous field metadata (@owned / @deprecated)
            {
                type: getNormalizedType(type),
                index,
                name,
            });
            // create "descriptors" map
            Object.defineProperty(metadata, $descriptors, {
                value: metadata[$descriptors] || {},
                enumerable: false,
                configurable: true,
            });
            if (descriptor) {
                // for encoder
                metadata[$descriptors][name] = descriptor;
                metadata[$descriptors][`_${name}`] = {
                    value: undefined,
                    writable: true,
                    enumerable: false,
                    configurable: true,
                };
            }
            else {
                // for decoder
                metadata[$descriptors][name] = {
                    value: undefined,
                    writable: true,
                    enumerable: true,
                    configurable: true,
                };
            }
            // map -1 as last field index
            Object.defineProperty(metadata, $numFields, {
                value: index,
                enumerable: false,
                configurable: true
            });
            // map field name => index (non enumerable)
            Object.defineProperty(metadata, name, {
                value: index,
                enumerable: false,
                configurable: true,
            });
            // if child Ref/complex type, add to -4
            if (typeof (metadata[index].type) !== "string") {
                if (metadata[$refTypeFieldIndexes] === undefined) {
                    Object.defineProperty(metadata, $refTypeFieldIndexes, {
                        value: [],
                        enumerable: false,
                        configurable: true,
                    });
                }
                metadata[$refTypeFieldIndexes].push(index);
            }
        },
        setTag(metadata, fieldName, tag) {
            const index = metadata[fieldName];
            const field = metadata[index];
            // add 'tag' to the field
            field.tag = tag;
            if (!metadata[$viewFieldIndexes]) {
                // -2: all field indexes with "view" tag
                Object.defineProperty(metadata, $viewFieldIndexes, {
                    value: [],
                    enumerable: false,
                    configurable: true
                });
                // -3: field indexes by "view" tag
                Object.defineProperty(metadata, $fieldIndexesByViewTag, {
                    value: {},
                    enumerable: false,
                    configurable: true
                });
            }
            metadata[$viewFieldIndexes].push(index);
            if (!metadata[$fieldIndexesByViewTag][tag]) {
                metadata[$fieldIndexesByViewTag][tag] = [];
            }
            metadata[$fieldIndexesByViewTag][tag].push(index);
        },
        setFields(target, fields) {
            // for inheritance support
            const constructor = target.prototype.constructor;
            TypeContext.register(constructor);
            const parentClass = Object.getPrototypeOf(constructor);
            const parentMetadata = parentClass && parentClass[Symbol.metadata];
            const metadata = Metadata.initialize(constructor);
            // Use Schema's methods if not defined in the class
            if (!constructor[$track]) {
                constructor[$track] = Schema[$track];
            }
            if (!constructor[$encoder]) {
                constructor[$encoder] = Schema[$encoder];
            }
            if (!constructor[$decoder]) {
                constructor[$decoder] = Schema[$decoder];
            }
            if (!constructor.prototype.toJSON) {
                constructor.prototype.toJSON = Schema.prototype.toJSON;
            }
            //
            // detect index for this field, considering inheritance
            //
            let fieldIndex = metadata[$numFields] // current structure already has fields defined
                ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined
                ?? -1; // no fields defined
            fieldIndex++;
            for (const field in fields) {
                const type = getNormalizedType(fields[field]);
                // FIXME: this code is duplicated from @type() annotation
                const complexTypeKlass = typeof (Object.keys(type)[0]) === "string" && getType(Object.keys(type)[0]);
                const childType = (complexTypeKlass)
                    ? Object.values(type)[0]
                    : type;
                Metadata.addField(metadata, fieldIndex, field, type, getPropertyDescriptor(`_${field}`, fieldIndex, childType, complexTypeKlass));
                fieldIndex++;
            }
            return target;
        },
        isDeprecated(metadata, field) {
            return metadata[field].deprecated === true;
        },
        init(klass) {
            //
            // Used only to initialize an empty Schema (Encoder#constructor)
            // TODO: remove/refactor this...
            //
            const metadata = {};
            klass[Symbol.metadata] = metadata;
            Object.defineProperty(metadata, $numFields, {
                value: 0,
                enumerable: false,
                configurable: true,
            });
        },
        initialize(constructor) {
            const parentClass = Object.getPrototypeOf(constructor);
            const parentMetadata = parentClass[Symbol.metadata];
            let metadata = constructor[Symbol.metadata] ?? Object.create(null);
            // make sure inherited classes have their own metadata object.
            if (parentClass !== Schema && metadata === parentMetadata) {
                metadata = Object.create(null);
                if (parentMetadata) {
                    //
                    // assign parent metadata to current
                    //
                    Object.setPrototypeOf(metadata, parentMetadata);
                    // $numFields
                    Object.defineProperty(metadata, $numFields, {
                        value: parentMetadata[$numFields],
                        enumerable: false,
                        configurable: true,
                        writable: true,
                    });
                    // $viewFieldIndexes / $fieldIndexesByViewTag
                    if (parentMetadata[$viewFieldIndexes] !== undefined) {
                        Object.defineProperty(metadata, $viewFieldIndexes, {
                            value: [...parentMetadata[$viewFieldIndexes]],
                            enumerable: false,
                            configurable: true,
                            writable: true,
                        });
                        Object.defineProperty(metadata, $fieldIndexesByViewTag, {
                            value: { ...parentMetadata[$fieldIndexesByViewTag] },
                            enumerable: false,
                            configurable: true,
                            writable: true,
                        });
                    }
                    // $refTypeFieldIndexes
                    if (parentMetadata[$refTypeFieldIndexes] !== undefined) {
                        Object.defineProperty(metadata, $refTypeFieldIndexes, {
                            value: [...parentMetadata[$refTypeFieldIndexes]],
                            enumerable: false,
                            configurable: true,
                            writable: true,
                        });
                    }
                    // $descriptors
                    Object.defineProperty(metadata, $descriptors, {
                        value: { ...parentMetadata[$descriptors] },
                        enumerable: false,
                        configurable: true,
                        writable: true,
                    });
                }
            }
            Object.defineProperty(constructor, Symbol.metadata, {
                value: metadata,
                writable: false,
                configurable: true
            });
            return metadata;
        },
        isValidInstance(klass) {
            return (klass.constructor[Symbol.metadata] &&
                Object.prototype.hasOwnProperty.call(klass.constructor[Symbol.metadata], $numFields));
        },
        getFields(klass) {
            const metadata = klass[Symbol.metadata];
            const fields = {};
            for (let i = 0; i <= metadata[$numFields]; i++) {
                fields[metadata[i].name] = metadata[i].type;
            }
            return fields;
        },
        hasViewTagAtIndex(metadata, index) {
            return metadata?.[$viewFieldIndexes]?.includes(index);
        }
    };

    function createChangeSet(queueRootNode) {
        return { indexes: {}, operations: [], queueRootNode };
    }
    // Linked list helper functions
    function createChangeTreeList() {
        return { next: undefined, tail: undefined };
    }
    function setOperationAtIndex(changeSet, index) {
        const operationsIndex = changeSet.indexes[index];
        if (operationsIndex === undefined) {
            changeSet.indexes[index] = changeSet.operations.push(index) - 1;
        }
        else {
            changeSet.operations[operationsIndex] = index;
        }
    }
    function deleteOperationAtIndex(changeSet, index) {
        let operationsIndex = changeSet.indexes[index];
        if (operationsIndex === undefined) {
            //
            // if index is not found, we need to find the last operation
            // FIXME: this is not very efficient
            //
            // > See "should allow consecutive splices (same place)" tests
            //
            operationsIndex = Object.values(changeSet.indexes).at(-1);
            index = Object.entries(changeSet.indexes).find(([_, value]) => value === operationsIndex)?.[0];
        }
        changeSet.operations[operationsIndex] = undefined;
        delete changeSet.indexes[index];
    }
    class ChangeTree {
        constructor(ref) {
            /**
             * Whether this structure is parent of a filtered structure.
             */
            this.isFiltered = false;
            this.indexedOperations = {};
            //
            // TODO:
            //   try storing the index + operation per item.
            //   example: 1024 & 1025 => ADD, 1026 => DELETE
            //
            // => https://chatgpt.com/share/67107d0c-bc20-8004-8583-83b17dd7c196
            //
            this.changes = { indexes: {}, operations: [] };
            this.allChanges = { indexes: {}, operations: [] };
            /**
             * Is this a new instance? Used on ArraySchema to determine OPERATION.MOVE_AND_ADD operation.
             */
            this.isNew = true;
            this.ref = ref;
            this.metadata = ref.constructor[Symbol.metadata];
            //
            // Does this structure have "filters" declared?
            //
            if (this.metadata?.[$viewFieldIndexes]) {
                this.allFilteredChanges = { indexes: {}, operations: [] };
                this.filteredChanges = { indexes: {}, operations: [] };
            }
        }
        setRoot(root) {
            this.root = root;
            const isNewChangeTree = this.root.add(this);
            this.checkIsFiltered(this.parent, this.parentIndex, isNewChangeTree);
            // Recursively set root on child structures
            if (isNewChangeTree) {
                this.forEachChild((child, _) => {
                    if (child.root !== root) {
                        child.setRoot(root);
                    }
                    else {
                        root.add(child); // increment refCount
                    }
                });
            }
        }
        setParent(parent, root, parentIndex) {
            this.addParent(parent, parentIndex);
            // avoid setting parents with empty `root`
            if (!root) {
                return;
            }
            const isNewChangeTree = root.add(this);
            // skip if parent is already set
            if (root !== this.root) {
                this.root = root;
                this.checkIsFiltered(parent, parentIndex, isNewChangeTree);
            }
            // assign same parent on child structures
            if (isNewChangeTree) {
                //
                // assign same parent on child structures
                //
                this.forEachChild((child, index) => {
                    if (child.root === root) {
                        //
                        // re-assigning a child of the same root, move it next to parent
                        // so encoding order is preserved
                        //
                        root.add(child);
                        root.moveNextToParent(child);
                        return;
                    }
                    child.setParent(this.ref, root, index);
                });
            }
        }
        forEachChild(callback) {
            //
            // assign same parent on child structures
            //
            if (this.ref[$childType]) {
                if (typeof (this.ref[$childType]) !== "string") {
                    // MapSchema / ArraySchema, etc.
                    for (const [key, value] of this.ref.entries()) {
                        if (!value) {
                            continue;
                        } // sparse arrays can have undefined values
                        callback(value[$changes], this.indexes?.[key] ?? key);
                    }
                }
            }
            else {
                for (const index of this.metadata?.[$refTypeFieldIndexes] ?? []) {
                    const field = this.metadata[index];
                    const value = this.ref[field.name];
                    if (!value) {
                        continue;
                    }
                    callback(value[$changes], index);
                }
            }
        }
        operation(op) {
            // operations without index use negative values to represent them
            // this is checked during .encode() time.
            if (this.filteredChanges !== undefined) {
                this.filteredChanges.operations.push(-op);
                this.root?.enqueueChangeTree(this, 'filteredChanges');
            }
            else {
                this.changes.operations.push(-op);
                this.root?.enqueueChangeTree(this, 'changes');
            }
        }
        change(index, operation = exports.OPERATION.ADD) {
            const isFiltered = this.isFiltered || (this.metadata?.[index]?.tag !== undefined);
            const changeSet = (isFiltered)
                ? this.filteredChanges
                : this.changes;
            const previousOperation = this.indexedOperations[index];
            if (!previousOperation || previousOperation === exports.OPERATION.DELETE) {
                const op = (!previousOperation)
                    ? operation
                    : (previousOperation === exports.OPERATION.DELETE)
                        ? exports.OPERATION.DELETE_AND_ADD
                        : operation;
                //
                // TODO: are DELETE operations being encoded as ADD here ??
                //
                this.indexedOperations[index] = op;
            }
            setOperationAtIndex(changeSet, index);
            if (isFiltered) {
                setOperationAtIndex(this.allFilteredChanges, index);
                if (this.root) {
                    this.root.enqueueChangeTree(this, 'filteredChanges');
                    this.root.enqueueChangeTree(this, 'allFilteredChanges');
                }
            }
            else {
                setOperationAtIndex(this.allChanges, index);
                this.root?.enqueueChangeTree(this, 'changes');
            }
        }
        shiftChangeIndexes(shiftIndex) {
            //
            // Used only during:
            //
            // - ArraySchema#unshift()
            //
            const changeSet = (this.isFiltered)
                ? this.filteredChanges
                : this.changes;
            const newIndexedOperations = {};
            const newIndexes = {};
            for (const index in this.indexedOperations) {
                newIndexedOperations[Number(index) + shiftIndex] = this.indexedOperations[index];
                newIndexes[Number(index) + shiftIndex] = changeSet.indexes[index];
            }
            this.indexedOperations = newIndexedOperations;
            changeSet.indexes = newIndexes;
            changeSet.operations = changeSet.operations.map((index) => index + shiftIndex);
        }
        shiftAllChangeIndexes(shiftIndex, startIndex = 0) {
            //
            // Used only during:
            //
            // - ArraySchema#splice()
            //
            if (this.filteredChanges !== undefined) {
                this._shiftAllChangeIndexes(shiftIndex, startIndex, this.allFilteredChanges);
                this._shiftAllChangeIndexes(shiftIndex, startIndex, this.allChanges);
            }
            else {
                this._shiftAllChangeIndexes(shiftIndex, startIndex, this.allChanges);
            }
        }
        _shiftAllChangeIndexes(shiftIndex, startIndex = 0, changeSet) {
            const newIndexes = {};
            let newKey = 0;
            for (const key in changeSet.indexes) {
                newIndexes[newKey++] = changeSet.indexes[key];
            }
            changeSet.indexes = newIndexes;
            for (let i = 0; i < changeSet.operations.length; i++) {
                const index = changeSet.operations[i];
                if (index > startIndex) {
                    changeSet.operations[i] = index + shiftIndex;
                }
            }
        }
        indexedOperation(index, operation, allChangesIndex = index) {
            this.indexedOperations[index] = operation;
            if (this.filteredChanges !== undefined) {
                setOperationAtIndex(this.allFilteredChanges, allChangesIndex);
                setOperationAtIndex(this.filteredChanges, index);
                this.root?.enqueueChangeTree(this, 'filteredChanges');
            }
            else {
                setOperationAtIndex(this.allChanges, allChangesIndex);
                setOperationAtIndex(this.changes, index);
                this.root?.enqueueChangeTree(this, 'changes');
            }
        }
        getType(index) {
            return (
            //
            // Get the child type from parent structure.
            // - ["string"] => "string"
            // - { map: "string" } => "string"
            // - { set: "string" } => "string"
            //
            this.ref[$childType] || // ArraySchema | MapSchema | SetSchema | CollectionSchema
                this.metadata[index].type // Schema
            );
        }
        getChange(index) {
            return this.indexedOperations[index];
        }
        //
        // used during `.encode()`
        //
        getValue(index, isEncodeAll = false) {
            //
            // `isEncodeAll` param is only used by ArraySchema
            //
            return this.ref[$getByIndex](index, isEncodeAll);
        }
        delete(index, operation, allChangesIndex = index) {
            if (index === undefined) {
                try {
                    throw new Error(`@colyseus/schema ${this.ref.constructor.name}: trying to delete non-existing index '${index}'`);
                }
                catch (e) {
                    console.warn(e);
                }
                return;
            }
            const changeSet = (this.filteredChanges !== undefined)
                ? this.filteredChanges
                : this.changes;
            this.indexedOperations[index] = operation ?? exports.OPERATION.DELETE;
            setOperationAtIndex(changeSet, index);
            deleteOperationAtIndex(this.allChanges, allChangesIndex);
            const previousValue = this.getValue(index);
            // remove `root` reference
            if (previousValue && previousValue[$changes]) {
                //
                // FIXME: this.root is "undefined"
                //
                // This method is being called at decoding time when a DELETE operation is found.
                //
                // - This is due to using the concrete Schema class at decoding time.
                // - "Reflected" structures do not have this problem.
                //
                // (The property descriptors should NOT be used at decoding time. only at encoding time.)
                //
                this.root?.remove(previousValue[$changes]);
            }
            //
            // FIXME: this is looking a ugly and repeated
            //
            if (this.filteredChanges !== undefined) {
                deleteOperationAtIndex(this.allFilteredChanges, allChangesIndex);
                this.root?.enqueueChangeTree(this, 'filteredChanges');
            }
            else {
                this.root?.enqueueChangeTree(this, 'changes');
            }
            return previousValue;
        }
        endEncode(changeSetName) {
            this.indexedOperations = {};
            // clear changeset
            this[changeSetName] = createChangeSet();
            // ArraySchema and MapSchema have a custom "encode end" method
            this.ref[$onEncodeEnd]?.();
            // Not a new instance anymore
            this.isNew = false;
        }
        discard(discardAll = false) {
            //
            // > MapSchema:
            //      Remove cached key to ensure ADD operations is unsed instead of
            //      REPLACE in case same key is used on next patches.
            //
            this.ref[$onEncodeEnd]?.();
            this.indexedOperations = {};
            this.changes = createChangeSet(this.changes.queueRootNode);
            if (this.filteredChanges !== undefined) {
                this.filteredChanges = createChangeSet(this.filteredChanges.queueRootNode);
            }
            if (discardAll) {
                // preserve queueRootNode references
                this.allChanges = createChangeSet(this.allChanges.queueRootNode);
                if (this.allFilteredChanges !== undefined) {
                    this.allFilteredChanges = createChangeSet(this.allFilteredChanges.queueRootNode);
                }
            }
        }
        /**
         * Recursively discard all changes from this, and child structures.
         * (Used in tests only)
         */
        discardAll() {
            const keys = Object.keys(this.indexedOperations);
            for (let i = 0, len = keys.length; i < len; i++) {
                const value = this.getValue(Number(keys[i]));
                if (value && value[$changes]) {
                    value[$changes].discardAll();
                }
            }
            this.discard();
        }
        get changed() {
            return (Object.entries(this.indexedOperations).length > 0);
        }
        checkIsFiltered(parent, parentIndex, isNewChangeTree) {
            if (this.root.types.hasFilters) {
                //
                // At Schema initialization, the "root" structure might not be available
                // yet, as it only does once the "Encoder" has been set up.
                //
                // So the "parent" may be already set without a "root".
                //
                this._checkFilteredByParent(parent, parentIndex);
                if (this.filteredChanges !== undefined) {
                    this.root?.enqueueChangeTree(this, 'filteredChanges');
                    if (isNewChangeTree) {
                        this.root?.enqueueChangeTree(this, 'allFilteredChanges');
                    }
                }
            }
            if (!this.isFiltered) {
                this.root?.enqueueChangeTree(this, 'changes');
                if (isNewChangeTree) {
                    this.root?.enqueueChangeTree(this, 'allChanges');
                }
            }
        }
        _checkFilteredByParent(parent, parentIndex) {
            // skip if parent is not set
            if (!parent) {
                return;
            }
            //
            // ArraySchema | MapSchema - get the child type
            // (if refType is typeof string, the parentFiltered[key] below will always be invalid)
            //
            const refType = Metadata.isValidInstance(this.ref)
                ? this.ref.constructor
                : this.ref[$childType];
            let parentChangeTree;
            let parentIsCollection = !Metadata.isValidInstance(parent);
            if (parentIsCollection) {
                parentChangeTree = parent[$changes];
                parent = parentChangeTree.parent;
                parentIndex = parentChangeTree.parentIndex;
            }
            else {
                parentChangeTree = parent[$changes];
            }
            const parentConstructor = parent.constructor;
            let key = `${this.root.types.getTypeId(refType)}`;
            if (parentConstructor) {
                key += `-${this.root.types.schemas.get(parentConstructor)}`;
            }
            key += `-${parentIndex}`;
            const fieldHasViewTag = Metadata.hasViewTagAtIndex(parentConstructor?.[Symbol.metadata], parentIndex);
            this.isFiltered = parent[$changes].isFiltered // in case parent is already filtered
                || this.root.types.parentFiltered[key]
                || fieldHasViewTag;
            //
            // "isFiltered" may not be imedialely available during `change()` due to the instance not being attached to the root yet.
            // when it's available, we need to enqueue the "changes" changeset into the "filteredChanges" changeset.
            //
            if (this.isFiltered) {
                this.isVisibilitySharedWithParent = (parentChangeTree.isFiltered &&
                    typeof (refType) !== "string" &&
                    !fieldHasViewTag &&
                    parentIsCollection);
                if (!this.filteredChanges) {
                    this.filteredChanges = createChangeSet();
                    this.allFilteredChanges = createChangeSet();
                }
                if (this.changes.operations.length > 0) {
                    this.changes.operations.forEach((index) => setOperationAtIndex(this.filteredChanges, index));
                    this.allChanges.operations.forEach((index) => setOperationAtIndex(this.allFilteredChanges, index));
                    this.changes = createChangeSet();
                    this.allChanges = createChangeSet();
                }
            }
        }
        /**
         * Get the immediate parent
         */
        get parent() {
            return this.parentChain?.ref;
        }
        /**
         * Get the immediate parent index
         */
        get parentIndex() {
            return this.parentChain?.index;
        }
        /**
         * Add a parent to the chain
         */
        addParent(parent, index) {
            // Check if this parent already exists in the chain
            if (this.hasParent((p, _) => p[$changes] === parent[$changes])) {
                // if (this.hasParent((p, i) => p[$changes] === parent[$changes] && i === index)) {
                this.parentChain.index = index;
                return;
            }
            this.parentChain = {
                ref: parent,
                index,
                next: this.parentChain
            };
        }
        /**
         * Remove a parent from the chain
         * @param parent - The parent to remove
         * @returns true if parent was removed
         */
        removeParent(parent = this.parent) {
            let current = this.parentChain;
            let previous = null;
            while (current) {
                //
                // FIXME: it is required to check against `$changes` here because
                // ArraySchema is instance of Proxy
                //
                if (current.ref[$changes] === parent[$changes]) {
                    if (previous) {
                        previous.next = current.next;
                    }
                    else {
                        this.parentChain = current.next;
                    }
                    return true;
                }
                previous = current;
                current = current.next;
            }
            return this.parentChain === undefined;
        }
        /**
         * Find a specific parent in the chain
         */
        findParent(predicate) {
            let current = this.parentChain;
            while (current) {
                if (predicate(current.ref, current.index)) {
                    return current;
                }
                current = current.next;
            }
            return undefined;
        }
        /**
         * Check if this ChangeTree has a specific parent
         */
        hasParent(predicate) {
            return this.findParent(predicate) !== undefined;
        }
        /**
         * Get all parents as an array (for debugging/testing)
         */
        getAllParents() {
            const parents = [];
            let current = this.parentChain;
            while (current) {
                parents.push({ ref: current.ref, index: current.index });
                current = current.next;
            }
            return parents;
        }
    }

    function encodeValue(encoder, bytes, type, value, operation, it) {
        if (typeof (type) === "string") {
            encode[type]?.(bytes, value, it);
        }
        else if (type[Symbol.metadata] !== undefined) {
            //
            // Encode refId for this instance.
            // The actual instance is going to be encoded on next `changeTree` iteration.
            //
            encode.number(bytes, value[$changes].refId, it);
            // Try to encode inherited TYPE_ID if it's an ADD operation.
            if ((operation & exports.OPERATION.ADD) === exports.OPERATION.ADD) {
                encoder.tryEncodeTypeId(bytes, type, value.constructor, it);
            }
        }
        else {
            //
            // Encode refId for this instance.
            // The actual instance is going to be encoded on next `changeTree` iteration.
            //
            encode.number(bytes, value[$changes].refId, it);
        }
    }
    /**
     * Used for Schema instances.
     * @private
     */
    const encodeSchemaOperation = function (encoder, bytes, changeTree, index, operation, it, _, __, metadata) {
        // "compress" field index + operation
        bytes[it.offset++] = (index | operation) & 255;
        // Do not encode value for DELETE operations
        if (operation === exports.OPERATION.DELETE) {
            return;
        }
        const ref = changeTree.ref;
        const field = metadata[index];
        // TODO: inline this function call small performance gain
        encodeValue(encoder, bytes, metadata[index].type, ref[field.name], operation, it);
    };
    /**
     * Used for collections (MapSchema, CollectionSchema, SetSchema)
     * @private
     */
    const encodeKeyValueOperation = function (encoder, bytes, changeTree, index, operation, it) {
        // encode operation
        bytes[it.offset++] = operation & 255;
        // encode index
        encode.number(bytes, index, it);
        // Do not encode value for DELETE operations
        if (operation === exports.OPERATION.DELETE) {
            return;
        }
        const ref = changeTree.ref;
        //
        // encode "alias" for dynamic fields (maps)
        //
        if ((operation & exports.OPERATION.ADD) === exports.OPERATION.ADD) { // ADD or DELETE_AND_ADD
            if (typeof (ref['set']) === "function") {
                //
                // MapSchema dynamic key
                //
                const dynamicIndex = changeTree.ref['$indexes'].get(index);
                encode.string(bytes, dynamicIndex, it);
            }
        }
        const type = ref[$childType];
        const value = ref[$getByIndex](index);
        // try { throw new Error(); } catch (e) {
        //     // only print if not coming from Reflection.ts
        //     if (!e.stack.includes("src/Reflection.ts")) {
        //         console.log("encodeKeyValueOperation -> ", {
        //             ref: changeTree.ref.constructor.name,
        //             field,
        //             operation: OPERATION[operation],
        //             value: value?.toJSON(),
        //             items: ref.toJSON(),
        //         });
        //     }
        // }
        // TODO: inline this function call small performance gain
        encodeValue(encoder, bytes, type, value, operation, it);
    };
    /**
     * Used for collections (MapSchema, ArraySchema, etc.)
     * @private
     */
    const encodeArray = function (encoder, bytes, changeTree, field, operation, it, isEncodeAll, hasView) {
        const ref = changeTree.ref;
        const useOperationByRefId = hasView && changeTree.isFiltered && (typeof (changeTree.getType(field)) !== "string");
        let refOrIndex;
        if (useOperationByRefId) {
            const item = ref['tmpItems'][field];
            // Skip encoding if item is undefined (e.g. when clear() is called)
            if (!item) {
                return;
            }
            refOrIndex = item[$changes].refId;
            if (operation === exports.OPERATION.DELETE) {
                operation = exports.OPERATION.DELETE_BY_REFID;
            }
            else if (operation === exports.OPERATION.ADD) {
                operation = exports.OPERATION.ADD_BY_REFID;
            }
        }
        else {
            refOrIndex = field;
        }
        // encode operation
        bytes[it.offset++] = operation & 255;
        // encode index
        encode.number(bytes, refOrIndex, it);
        // Do not encode value for DELETE operations
        if (operation === exports.OPERATION.DELETE || operation === exports.OPERATION.DELETE_BY_REFID) {
            return;
        }
        const type = changeTree.getType(field);
        const value = changeTree.getValue(field, isEncodeAll);
        // console.log({ type, field, value });
        // console.log("encodeArray -> ", {
        //     ref: changeTree.ref.constructor.name,
        //     field,
        //     operation: OPERATION[operation],
        //     value: value?.toJSON(),
        //     items: ref.toJSON(),
        // });
        // TODO: inline this function call small performance gain
        encodeValue(encoder, bytes, type, value, operation, it);
    };

    const DEFINITION_MISMATCH = -1;
    function decodeValue(decoder, operation, ref, index, type, bytes, it, allChanges) {
        const $root = decoder.root;
        const previousValue = ref[$getByIndex](index);
        let value;
        if ((operation & exports.OPERATION.DELETE) === exports.OPERATION.DELETE) {
            // Flag `refId` for garbage collection.
            const previousRefId = $root.refIds.get(previousValue);
            if (previousRefId !== undefined) {
                $root.removeRef(previousRefId);
            }
            //
            // Delete operations
            //
            if (operation !== exports.OPERATION.DELETE_AND_ADD) {
                ref[$deleteByIndex](index);
            }
            value = undefined;
        }
        if (operation === exports.OPERATION.DELETE) ;
        else if (Schema.is(type)) {
            const refId = decode.number(bytes, it);
            value = $root.refs.get(refId);
            if ((operation & exports.OPERATION.ADD) === exports.OPERATION.ADD) {
                const childType = decoder.getInstanceType(bytes, it, type);
                if (!value) {
                    value = decoder.createInstanceOfType(childType);
                }
                $root.addRef(refId, value, (value !== previousValue || // increment ref count if value has changed
                    (operation === exports.OPERATION.DELETE_AND_ADD && value === previousValue) // increment ref count if the same instance is being added again
                ));
            }
        }
        else if (typeof (type) === "string") {
            //
            // primitive value (number, string, boolean, etc)
            //
            value = decode[type](bytes, it);
        }
        else {
            const typeDef = getType(Object.keys(type)[0]);
            const refId = decode.number(bytes, it);
            const valueRef = ($root.refs.has(refId))
                ? previousValue || $root.refs.get(refId)
                : new typeDef.constructor();
            value = valueRef.clone(true);
            value[$childType] = Object.values(type)[0]; // cache childType for ArraySchema and MapSchema
            if (previousValue) {
                let previousRefId = $root.refIds.get(previousValue);
                if (previousRefId !== undefined && refId !== previousRefId) {
                    //
                    // enqueue onRemove if structure has been replaced.
                    //
                    const entries = previousValue.entries();
                    let iter;
                    while ((iter = entries.next()) && !iter.done) {
                        const [key, value] = iter.value;
                        // if value is a schema, remove its reference
                        if (typeof (value) === "object") {
                            previousRefId = $root.refIds.get(value);
                            $root.removeRef(previousRefId);
                        }
                        allChanges.push({
                            ref: previousValue,
                            refId: previousRefId,
                            op: exports.OPERATION.DELETE,
                            field: key,
                            value: undefined,
                            previousValue: value,
                        });
                    }
                }
            }
            $root.addRef(refId, value, (valueRef !== previousValue ||
                (operation === exports.OPERATION.DELETE_AND_ADD && valueRef === previousValue)));
        }
        return { value, previousValue };
    }
    const decodeSchemaOperation = function (decoder, bytes, it, ref, allChanges) {
        const first_byte = bytes[it.offset++];
        const metadata = ref.constructor[Symbol.metadata];
        // "compressed" index + operation
        const operation = (first_byte >> 6) << 6;
        const index = first_byte % (operation || 255);
        // skip early if field is not defined
        const field = metadata[index];
        if (field === undefined) {
            console.warn("@colyseus/schema: field not defined at", { index, ref: ref.constructor.name, metadata });
            return DEFINITION_MISMATCH;
        }
        const { value, previousValue } = decodeValue(decoder, operation, ref, index, field.type, bytes, it, allChanges);
        if (value !== null && value !== undefined) {
            ref[field.name] = value;
        }
        // add change
        if (previousValue !== value) {
            allChanges.push({
                ref,
                refId: decoder.currentRefId,
                op: operation,
                field: field.name,
                value,
                previousValue,
            });
        }
    };
    const decodeKeyValueOperation = function (decoder, bytes, it, ref, allChanges) {
        // "uncompressed" index + operation (array/map items)
        const operation = bytes[it.offset++];
        if (operation === exports.OPERATION.CLEAR) {
            //
            // When decoding:
            // - enqueue items for DELETE callback.
            // - flag child items for garbage collection.
            //
            decoder.removeChildRefs(ref, allChanges);
            ref.clear();
            return;
        }
        const index = decode.number(bytes, it);
        const type = ref[$childType];
        let dynamicIndex;
        if ((operation & exports.OPERATION.ADD) === exports.OPERATION.ADD) { // ADD or DELETE_AND_ADD
            if (typeof (ref['set']) === "function") {
                dynamicIndex = decode.string(bytes, it); // MapSchema
                ref['setIndex'](index, dynamicIndex);
            }
            else {
                dynamicIndex = index; // ArraySchema
            }
        }
        else {
            // get dynamic index from "ref"
            dynamicIndex = ref['getIndex'](index);
        }
        const { value, previousValue } = decodeValue(decoder, operation, ref, index, type, bytes, it, allChanges);
        if (value !== null && value !== undefined) {
            if (typeof (ref['set']) === "function") {
                // MapSchema
                ref['$items'].set(dynamicIndex, value);
            }
            else if (typeof (ref['$setAt']) === "function") {
                // ArraySchema
                ref['$setAt'](index, value, operation);
            }
            else if (typeof (ref['add']) === "function") {
                // CollectionSchema && SetSchema
                const index = ref.add(value);
                if (typeof (index) === "number") {
                    ref['setIndex'](index, index);
                }
            }
        }
        // add change
        if (previousValue !== value) {
            allChanges.push({
                ref,
                refId: decoder.currentRefId,
                op: operation,
                field: "", // FIXME: remove this
                dynamicIndex,
                value,
                previousValue,
            });
        }
    };
    const decodeArray = function (decoder, bytes, it, ref, allChanges) {
        // "uncompressed" index + operation (array/map items)
        let operation = bytes[it.offset++];
        let index;
        if (operation === exports.OPERATION.CLEAR) {
            //
            // When decoding:
            // - enqueue items for DELETE callback.
            // - flag child items for garbage collection.
            //
            decoder.removeChildRefs(ref, allChanges);
            ref.clear();
            return;
        }
        else if (operation === exports.OPERATION.REVERSE) {
            ref.reverse();
            return;
        }
        else if (operation === exports.OPERATION.DELETE_BY_REFID) {
            // TODO: refactor here, try to follow same flow as below
            const refId = decode.number(bytes, it);
            const previousValue = decoder.root.refs.get(refId);
            index = ref.findIndex((value) => value === previousValue);
            ref[$deleteByIndex](index);
            allChanges.push({
                ref,
                refId: decoder.currentRefId,
                op: exports.OPERATION.DELETE,
                field: "", // FIXME: remove this
                dynamicIndex: index,
                value: undefined,
                previousValue,
            });
            return;
        }
        else if (operation === exports.OPERATION.ADD_BY_REFID) {
            const refId = decode.number(bytes, it);
            const itemByRefId = decoder.root.refs.get(refId);
            // if item already exists, use existing index
            if (itemByRefId) {
                index = ref.findIndex((value) => value === itemByRefId);
            }
            // fallback to use last index
            if (index === -1 || index === undefined) {
                index = ref.length;
            }
        }
        else {
            index = decode.number(bytes, it);
        }
        const type = ref[$childType];
        let dynamicIndex = index;
        const { value, previousValue } = decodeValue(decoder, operation, ref, index, type, bytes, it, allChanges);
        if (value !== null && value !== undefined &&
            value !== previousValue // avoid setting same value twice (if index === 0 it will result in a "unshift" for ArraySchema)
        ) {
            // ArraySchema
            ref['$setAt'](index, value, operation);
        }
        // add change
        if (previousValue !== value) {
            allChanges.push({
                ref,
                refId: decoder.currentRefId,
                op: operation,
                field: "", // FIXME: remove this
                dynamicIndex,
                value,
                previousValue,
            });
        }
    };

    class EncodeSchemaError extends Error {
    }
    function assertType(value, type, klass, field) {
        let typeofTarget;
        let allowNull = false;
        switch (type) {
            case "number":
            case "int8":
            case "uint8":
            case "int16":
            case "uint16":
            case "int32":
            case "uint32":
            case "int64":
            case "uint64":
            case "float32":
            case "float64":
                typeofTarget = "number";
                if (isNaN(value)) {
                    console.log(`trying to encode "NaN" in ${klass.constructor.name}#${field}`);
                }
                break;
            case "bigint64":
            case "biguint64":
                typeofTarget = "bigint";
                break;
            case "string":
                typeofTarget = "string";
                allowNull = true;
                break;
            case "boolean":
                // boolean is always encoded as true/false based on truthiness
                return;
            default:
                // skip assertion for custom types
                // TODO: allow custom types to define their own assertions
                return;
        }
        if (typeof (value) !== typeofTarget && (!allowNull || (allowNull && value !== null))) {
            let foundValue = `'${JSON.stringify(value)}'${(value && value.constructor && ` (${value.constructor.name})`) || ''}`;
            throw new EncodeSchemaError(`a '${typeofTarget}' was expected, but ${foundValue} was provided in ${klass.constructor.name}#${field}`);
        }
    }
    function assertInstanceType(value, type, instance, field) {
        if (!(value instanceof type)) {
            throw new EncodeSchemaError(`a '${type.name}' was expected, but '${value && value.constructor.name}' was provided in ${instance.constructor.name}#${field}`);
        }
    }

    var _a$4, _b$4;
    const DEFAULT_SORT = (a, b) => {
        const A = a.toString();
        const B = b.toString();
        if (A < B)
            return -1;
        else if (A > B)
            return 1;
        else
            return 0;
    };
    class ArraySchema {
        static { this[_a$4] = encodeArray; }
        static { this[_b$4] = decodeArray; }
        /**
         * Determine if a property must be filtered.
         * - If returns false, the property is NOT going to be encoded.
         * - If returns true, the property is going to be encoded.
         *
         * Encoding with "filters" happens in two steps:
         * - First, the encoder iterates over all "not owned" properties and encodes them.
         * - Then, the encoder iterates over all "owned" properties per instance and encodes them.
         */
        static [(_a$4 = $encoder, _b$4 = $decoder, $filter)](ref, index, view) {
            return (!view ||
                typeof (ref[$childType]) === "string" ||
                view.isChangeTreeVisible(ref['tmpItems'][index]?.[$changes]));
        }
        static is(type) {
            return (
            // type format: ["string"]
            Array.isArray(type) ||
                // type format: { array: "string" }
                (type['array'] !== undefined));
        }
        static from(iterable) {
            return new ArraySchema(...Array.from(iterable));
        }
        constructor(...items) {
            this.items = [];
            this.tmpItems = [];
            this.deletedIndexes = {};
            this.isMovingItems = false;
            Object.defineProperty(this, $childType, {
                value: undefined,
                enumerable: false,
                writable: true,
                configurable: true,
            });
            const proxy = new Proxy(this, {
                get: (obj, prop) => {
                    if (typeof (prop) !== "symbol" &&
                        // FIXME: d8 accuses this as low performance
                        !isNaN(prop) // https://stackoverflow.com/a/175787/892698
                    ) {
                        return this.items[prop];
                    }
                    else {
                        return Reflect.get(obj, prop);
                    }
                },
                set: (obj, key, setValue) => {
                    if (typeof (key) !== "symbol" && !isNaN(key)) {
                        if (setValue === undefined || setValue === null) {
                            obj.$deleteAt(key);
                        }
                        else {
                            if (setValue[$changes]) {
                                assertInstanceType(setValue, obj[$childType], obj, key);
                                const previousValue = obj.items[key];
                                if (!obj.isMovingItems) {
                                    obj.$changeAt(Number(key), setValue);
                                }
                                else {
                                    if (previousValue !== undefined) {
                                        if (setValue[$changes].isNew) {
                                            obj[$changes].indexedOperation(Number(key), exports.OPERATION.MOVE_AND_ADD);
                                        }
                                        else {
                                            if ((obj[$changes].getChange(Number(key)) & exports.OPERATION.DELETE) === exports.OPERATION.DELETE) {
                                                obj[$changes].indexedOperation(Number(key), exports.OPERATION.DELETE_AND_MOVE);
                                            }
                                            else {
                                                obj[$changes].indexedOperation(Number(key), exports.OPERATION.MOVE);
                                            }
                                        }
                                    }
                                    else if (setValue[$changes].isNew) {
                                        obj[$changes].indexedOperation(Number(key), exports.OPERATION.ADD);
                                    }
                                    setValue[$changes].setParent(this, obj[$changes].root, key);
                                }
                                if (previousValue !== undefined) {
                                    // remove root reference from previous value
                                    previousValue[$changes].root?.remove(previousValue[$changes]);
                                }
                            }
                            else {
                                obj.$changeAt(Number(key), setValue);
                            }
                            obj.items[key] = setValue;
                            obj.tmpItems[key] = setValue;
                        }
                        return true;
                    }
                    else {
                        return Reflect.set(obj, key, setValue);
                    }
                },
                deleteProperty: (obj, prop) => {
                    if (typeof (prop) === "number") {
                        obj.$deleteAt(prop);
                    }
                    else {
                        delete obj[prop];
                    }
                    return true;
                },
                has: (obj, key) => {
                    if (typeof (key) !== "symbol" && !isNaN(Number(key))) {
                        return Reflect.has(this.items, key);
                    }
                    return Reflect.has(obj, key);
                }
            });
            Object.defineProperty(this, $changes, {
                value: new ChangeTree(proxy),
                enumerable: false,
                writable: true,
            });
            if (items.length > 0) {
                this.push(...items);
            }
            return proxy;
        }
        set length(newLength) {
            if (newLength === 0) {
                this.clear();
            }
            else if (newLength < this.items.length) {
                this.splice(newLength, this.length - newLength);
            }
            else {
                console.warn("ArraySchema: can't set .length to a higher value than its length.");
            }
        }
        get length() {
            return this.items.length;
        }
        push(...values) {
            let length = this.tmpItems.length;
            const changeTree = this[$changes];
            for (let i = 0, l = values.length; i < l; i++, length++) {
                const value = values[i];
                if (value === undefined || value === null) {
                    // skip null values
                    return;
                }
                else if (typeof (value) === "object" && this[$childType]) {
                    assertInstanceType(value, this[$childType], this, i);
                    // TODO: move value[$changes]?.setParent() to this block.
                }
                changeTree.indexedOperation(length, exports.OPERATION.ADD, this.items.length);
                this.items.push(value);
                this.tmpItems.push(value);
                //
                // set value's parent after the value is set
                // (to avoid encoding "refId" operations before parent's "ADD" operation)
                //
                value[$changes]?.setParent(this, changeTree.root, length);
            }
            return length;
        }
        /**
         * Removes the last element from an array and returns it.
         */
        pop() {
            let index = -1;
            // find last non-undefined index
            for (let i = this.tmpItems.length - 1; i >= 0; i--) {
                // if (this.tmpItems[i] !== undefined) {
                if (this.deletedIndexes[i] !== true) {
                    index = i;
                    break;
                }
            }
            if (index < 0) {
                return undefined;
            }
            this[$changes].delete(index, undefined, this.items.length - 1);
            this.deletedIndexes[index] = true;
            return this.items.pop();
        }
        at(index) {
            // Allow negative indexing from the end
            if (index < 0)
                index += this.length;
            return this.items[index];
        }
        // encoding only
        $changeAt(index, value) {
            if (value === undefined || value === null) {
                console.error("ArraySchema items cannot be null nor undefined; Use `deleteAt(index)` instead.");
                return;
            }
            // skip if the value is the same as cached.
            if (this.items[index] === value) {
                return;
            }
            const operation = (this.items[index] !== undefined)
                ? typeof (value) === "object"
                    ? exports.OPERATION.DELETE_AND_ADD // schema child
                    : exports.OPERATION.REPLACE // primitive
                : exports.OPERATION.ADD;
            const changeTree = this[$changes];
            changeTree.change(index, operation);
            //
            // set value's parent after the value is set
            // (to avoid encoding "refId" operations before parent's "ADD" operation)
            //
            value[$changes]?.setParent(this, changeTree.root, index);
        }
        // encoding only
        $deleteAt(index, operation) {
            this[$changes].delete(index, operation);
        }
        // decoding only
        $setAt(index, value, operation) {
            if (index === 0 &&
                operation === exports.OPERATION.ADD &&
                this.items[index] !== undefined) {
                // handle decoding unshift
                this.items.unshift(value);
            }
            else if (operation === exports.OPERATION.DELETE_AND_MOVE) {
                this.items.splice(index, 1);
                this.items[index] = value;
            }
            else {
                this.items[index] = value;
            }
        }
        clear() {
            // skip if already clear
            if (this.items.length === 0) {
                return;
            }
            // discard previous operations.
            const changeTree = this[$changes];
            // remove children references
            changeTree.forEachChild((childChangeTree, _) => {
                changeTree.root?.remove(childChangeTree);
            });
            changeTree.discard(true);
            changeTree.operation(exports.OPERATION.CLEAR);
            this.items.length = 0;
            this.tmpItems.length = 0;
        }
        /**
         * Combines two or more arrays.
         * @param items Additional items to add to the end of array1.
         */
        // @ts-ignore
        concat(...items) {
            return new ArraySchema(...this.items.concat(...items));
        }
        /**
         * Adds all the elements of an array separated by the specified separator string.
         * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
         */
        join(separator) {
            return this.items.join(separator);
        }
        /**
         * Reverses the elements in an Array.
         */
        // @ts-ignore
        reverse() {
            this[$changes].operation(exports.OPERATION.REVERSE);
            this.items.reverse();
            this.tmpItems.reverse();
            return this;
        }
        /**
         * Removes the first element from an array and returns it.
         */
        shift() {
            if (this.items.length === 0) {
                return undefined;
            }
            const changeTree = this[$changes];
            const index = this.tmpItems.findIndex(item => item === this.items[0]);
            const allChangesIndex = this.items.findIndex(item => item === this.items[0]);
            changeTree.delete(index, exports.OPERATION.DELETE, allChangesIndex);
            changeTree.shiftAllChangeIndexes(-1, allChangesIndex);
            this.deletedIndexes[index] = true;
            return this.items.shift();
        }
        /**
         * Returns a section of an array.
         * @param start The beginning of the specified portion of the array.
         * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
         */
        slice(start, end) {
            const sliced = new ArraySchema();
            sliced.push(...this.items.slice(start, end));
            return sliced;
        }
        /**
         * Sorts an array.
         * @param compareFn Function used to determine the order of the elements. It is expected to return
         * a negative value if first argument is less than second argument, zero if they're equal and a positive
         * value otherwise. If omitted, the elements are sorted in ascending, ASCII character order.
         * ```ts
         * [11,2,22,1].sort((a, b) => a - b)
         * ```
         */
        sort(compareFn = DEFAULT_SORT) {
            this.isMovingItems = true;
            const changeTree = this[$changes];
            const sortedItems = this.items.sort(compareFn);
            // wouldn't OPERATION.MOVE make more sense here?
            sortedItems.forEach((_, i) => changeTree.change(i, exports.OPERATION.REPLACE));
            this.tmpItems.sort(compareFn);
            this.isMovingItems = false;
            return this;
        }
        /**
         * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.
         * @param start The zero-based location in the array from which to start removing elements.
         * @param deleteCount The number of elements to remove.
         * @param insertItems Elements to insert into the array in place of the deleted elements.
         */
        splice(start, deleteCount, ...insertItems) {
            const changeTree = this[$changes];
            const itemsLength = this.items.length;
            const tmpItemsLength = this.tmpItems.length;
            const insertCount = insertItems.length;
            // build up-to-date list of indexes, excluding removed values.
            const indexes = [];
            for (let i = 0; i < tmpItemsLength; i++) {
                if (this.deletedIndexes[i] !== true) {
                    indexes.push(i);
                }
            }
            if (itemsLength > start) {
                // if deleteCount is not provided, delete all items from start to end
                if (deleteCount === undefined) {
                    deleteCount = itemsLength - start;
                }
                //
                // delete operations at correct index
                //
                for (let i = start; i < start + deleteCount; i++) {
                    const index = indexes[i];
                    changeTree.delete(index, exports.OPERATION.DELETE);
                    this.deletedIndexes[index] = true;
                }
            }
            else {
                // not enough items to delete
                deleteCount = 0;
            }
            // insert operations
            if (insertCount > 0) {
                if (insertCount > deleteCount) {
                    console.error("Inserting more elements than deleting during ArraySchema#splice()");
                    throw new Error("ArraySchema#splice(): insertCount must be equal or lower than deleteCount.");
                }
                for (let i = 0; i < insertCount; i++) {
                    const addIndex = (indexes[start] ?? itemsLength) + i;
                    changeTree.indexedOperation(addIndex, (this.deletedIndexes[addIndex])
                        ? exports.OPERATION.DELETE_AND_ADD
                        : exports.OPERATION.ADD);
                    // set value's parent/root
                    insertItems[i][$changes]?.setParent(this, changeTree.root, addIndex);
                }
            }
            //
            // delete exceeding indexes from "allChanges"
            // (prevent .encodeAll() from encoding non-existing items)
            //
            if (deleteCount > insertCount) {
                changeTree.shiftAllChangeIndexes(-(deleteCount - insertCount), indexes[start + insertCount]);
                // debugChangeSet("AFTER SHIFT indexes", changeTree.allChanges);
            }
            //
            // FIXME: this code block is duplicated on ChangeTree
            //
            if (changeTree.filteredChanges !== undefined) {
                changeTree.root?.enqueueChangeTree(changeTree, 'filteredChanges');
            }
            else {
                changeTree.root?.enqueueChangeTree(changeTree, 'changes');
            }
            return this.items.splice(start, deleteCount, ...insertItems);
        }
        /**
         * Inserts new elements at the start of an array.
         * @param items  Elements to insert at the start of the Array.
         */
        unshift(...items) {
            const changeTree = this[$changes];
            // shift indexes
            changeTree.shiftChangeIndexes(items.length);
            // new index
            if (changeTree.isFiltered) {
                setOperationAtIndex(changeTree.filteredChanges, this.items.length);
                // changeTree.filteredChanges[this.items.length] = OPERATION.ADD;
            }
            else {
                setOperationAtIndex(changeTree.allChanges, this.items.length);
                // changeTree.allChanges[this.items.length] = OPERATION.ADD;
            }
            // FIXME: should we use OPERATION.MOVE here instead?
            items.forEach((_, index) => {
                changeTree.change(index, exports.OPERATION.ADD);
            });
            this.tmpItems.unshift(...items);
            return this.items.unshift(...items);
        }
        /**
         * Returns the index of the first occurrence of a value in an array.
         * @param searchElement The value to locate in the array.
         * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
         */
        indexOf(searchElement, fromIndex) {
            return this.items.indexOf(searchElement, fromIndex);
        }
        /**
         * Returns the index of the last occurrence of a specified value in an array.
         * @param searchElement The value to locate in the array.
         * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
         */
        lastIndexOf(searchElement, fromIndex = this.length - 1) {
            return this.items.lastIndexOf(searchElement, fromIndex);
        }
        every(callbackfn, thisArg) {
            return this.items.every(callbackfn, thisArg);
        }
        /**
         * Determines whether the specified callback function returns true for any element of an array.
         * @param callbackfn A function that accepts up to three arguments. The some method calls
         * the callbackfn function for each element in the array until the callbackfn returns a value
         * which is coercible to the Boolean value true, or until the end of the array.
         * @param thisArg An object to which the this keyword can refer in the callbackfn function.
         * If thisArg is omitted, undefined is used as the this value.
         */
        some(callbackfn, thisArg) {
            return this.items.some(callbackfn, thisArg);
        }
        /**
         * Performs the specified action for each element in an array.
         * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
         * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
         */
        forEach(callbackfn, thisArg) {
            return this.items.forEach(callbackfn, thisArg);
        }
        /**
         * Calls a defined callback function on each element of an array, and returns an array that contains the results.
         * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
         * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
         */
        map(callbackfn, thisArg) {
            return this.items.map(callbackfn, thisArg);
        }
        filter(callbackfn, thisArg) {
            return this.items.filter(callbackfn, thisArg);
        }
        /**
         * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
         * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
         * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
         */
        reduce(callbackfn, initialValue) {
            return this.items.reduce(callbackfn, initialValue);
        }
        /**
         * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
         * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
         * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
         */
        reduceRight(callbackfn, initialValue) {
            return this.items.reduceRight(callbackfn, initialValue);
        }
        /**
         * Returns the value of the first element in the array where predicate is true, and undefined
         * otherwise.
         * @param predicate find calls predicate once for each element of the array, in ascending
         * order, until it finds one where predicate returns true. If such an element is found, find
         * immediately returns that element value. Otherwise, find returns undefined.
         * @param thisArg If provided, it will be used as the this value for each invocation of
         * predicate. If it is not provided, undefined is used instead.
         */
        find(predicate, thisArg) {
            return this.items.find(predicate, thisArg);
        }
        /**
         * Returns the index of the first element in the array where predicate is true, and -1
         * otherwise.
         * @param predicate find calls predicate once for each element of the array, in ascending
         * order, until it finds one where predicate returns true. If such an element is found,
         * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
         * @param thisArg If provided, it will be used as the this value for each invocation of
         * predicate. If it is not provided, undefined is used instead.
         */
        findIndex(predicate, thisArg) {
            return this.items.findIndex(predicate, thisArg);
        }
        /**
         * Returns the this object after filling the section identified by start and end with value
         * @param value value to fill array section with
         * @param start index to start filling the array at. If start is negative, it is treated as
         * length+start where length is the length of the array.
         * @param end index to stop filling the array at. If end is negative, it is treated as
         * length+end.
         */
        fill(value, start, end) {
            //
            // TODO
            //
            throw new Error("ArraySchema#fill() not implemented");
        }
        /**
         * Returns the this object after copying a section of the array identified by start and end
         * to the same array starting at position target
         * @param target If target is negative, it is treated as length+target where length is the
         * length of the array.
         * @param start If start is negative, it is treated as length+start. If end is negative, it
         * is treated as length+end.
         * @param end If not specified, length of the this object is used as its default value.
         */
        copyWithin(target, start, end) {
            //
            // TODO
            //
            throw new Error("ArraySchema#copyWithin() not implemented");
        }
        /**
         * Returns a string representation of an array.
         */
        toString() {
            return this.items.toString();
        }
        /**
         * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
         */
        toLocaleString() {
            return this.items.toLocaleString();
        }
        ;
        /** Iterator */
        [Symbol.iterator]() {
            return this.items[Symbol.iterator]();
        }
        static get [Symbol.species]() {
            return ArraySchema;
        }
        /**
         * Returns an iterable of key, value pairs for every entry in the array
         */
        entries() { return this.items.entries(); }
        /**
         * Returns an iterable of keys in the array
         */
        keys() { return this.items.keys(); }
        /**
         * Returns an iterable of values in the array
         */
        values() { return this.items.values(); }
        /**
         * Determines whether an array includes a certain element, returning true or false as appropriate.
         * @param searchElement The element to search for.
         * @param fromIndex The position in this array at which to begin searching for searchElement.
         */
        includes(searchElement, fromIndex) {
            return this.items.includes(searchElement, fromIndex);
        }
        //
        // ES2022
        //
        /**
         * Calls a defined callback function on each element of an array. Then, flattens the result into
         * a new array.
         * This is identical to a map followed by flat with depth 1.
         *
         * @param callback A function that accepts up to three arguments. The flatMap method calls the
         * callback function one time for each element in the array.
         * @param thisArg An object to which the this keyword can refer in the callback function. If
         * thisArg is omitted, undefined is used as the this value.
         */
        // @ts-ignore
        flatMap(callback, thisArg) {
            // @ts-ignore
            throw new Error("ArraySchema#flatMap() is not supported.");
        }
        /**
         * Returns a new array with all sub-array elements concatenated into it recursively up to the
         * specified depth.
         *
         * @param depth The maximum recursion depth
         */
        // @ts-ignore
        flat(depth) {
            throw new Error("ArraySchema#flat() is not supported.");
        }
        findLast() {
            // @ts-ignore
            return this.items.findLast.apply(this.items, arguments);
        }
        findLastIndex(...args) {
            // @ts-ignore
            return this.items.findLastIndex.apply(this.items, arguments);
        }
        //
        // ES2023
        //
        with(index, value) {
            const copy = this.items.slice();
            // Allow negative indexing from the end
            if (index < 0)
                index += this.length;
            copy[index] = value;
            return new ArraySchema(...copy);
        }
        toReversed() {
            return this.items.slice().reverse();
        }
        toSorted(compareFn) {
            return this.items.slice().sort(compareFn);
        }
        // @ts-ignore
        toSpliced(start, deleteCount, ...items) {
            // @ts-ignore
            return this.items.toSpliced.apply(copy, arguments);
        }
        shuffle() {
            return this.move((_) => {
                let currentIndex = this.items.length;
                while (currentIndex != 0) {
                    let randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex--;
                    [this[currentIndex], this[randomIndex]] = [this[randomIndex], this[currentIndex]];
                }
            });
        }
        /**
         * Allows to move items around in the array.
         *
         * Example:
         *     state.cards.move((cards) => {
         *         [cards[4], cards[3]] = [cards[3], cards[4]];
         *         [cards[3], cards[2]] = [cards[2], cards[3]];
         *         [cards[2], cards[0]] = [cards[0], cards[2]];
         *         [cards[1], cards[1]] = [cards[1], cards[1]];
         *         [cards[0], cards[0]] = [cards[0], cards[0]];
         *     })
         *
         * @param cb
         * @returns
         */
        move(cb) {
            this.isMovingItems = true;
            cb(this);
            this.isMovingItems = false;
            return this;
        }
        [($getByIndex)](index, isEncodeAll = false) {
            //
            // TODO: avoid unecessary `this.tmpItems` check during decoding.
            //
            //    ENCODING uses `this.tmpItems` (or `this.items` if `isEncodeAll` is true)
            //    DECODING uses `this.items`
            //
            return (isEncodeAll)
                ? this.items[index]
                : this.deletedIndexes[index]
                    ? this.items[index]
                    : this.tmpItems[index] || this.items[index];
        }
        [$deleteByIndex](index) {
            this.items[index] = undefined;
            this.tmpItems[index] = undefined; // TODO: do not try to get "tmpItems" at decoding time.
        }
        [$onEncodeEnd]() {
            this.tmpItems = this.items.slice();
            this.deletedIndexes = {};
        }
        [$onDecodeEnd]() {
            this.items = this.items.filter((item) => item !== undefined);
            this.tmpItems = this.items.slice(); // TODO: do no use "tmpItems" at decoding time.
        }
        toArray() {
            return this.items.slice(0);
        }
        toJSON() {
            return this.toArray().map((value) => {
                return (typeof (value['toJSON']) === "function")
                    ? value['toJSON']()
                    : value;
            });
        }
        //
        // Decoding utilities
        //
        clone(isDecoding) {
            let cloned;
            if (isDecoding) {
                cloned = new ArraySchema();
                cloned.push(...this.items);
            }
            else {
                cloned = new ArraySchema(...this.map(item => ((item[$changes])
                    ? item.clone()
                    : item)));
            }
            return cloned;
        }
        ;
    }
    registerType("array", { constructor: ArraySchema });

    var _a$3, _b$3;
    class MapSchema {
        static { this[_a$3] = encodeKeyValueOperation; }
        static { this[_b$3] = decodeKeyValueOperation; }
        /**
         * Determine if a property must be filtered.
         * - If returns false, the property is NOT going to be encoded.
         * - If returns true, the property is going to be encoded.
         *
         * Encoding with "filters" happens in two steps:
         * - First, the encoder iterates over all "not owned" properties and encodes them.
         * - Then, the encoder iterates over all "owned" properties per instance and encodes them.
         */
        static [(_a$3 = $encoder, _b$3 = $decoder, $filter)](ref, index, view) {
            return (!view ||
                typeof (ref[$childType]) === "string" ||
                view.isChangeTreeVisible((ref[$getByIndex](index) ?? ref.deletedItems[index])[$changes]));
        }
        static is(type) {
            return type['map'] !== undefined;
        }
        constructor(initialValues) {
            this.$items = new Map();
            this.$indexes = new Map();
            this.deletedItems = {};
            const changeTree = new ChangeTree(this);
            changeTree.indexes = {};
            Object.defineProperty(this, $changes, {
                value: changeTree,
                enumerable: false,
                writable: true,
            });
            if (initialValues) {
                if (initialValues instanceof Map ||
                    initialValues instanceof MapSchema) {
                    initialValues.forEach((v, k) => this.set(k, v));
                }
                else {
                    for (const k in initialValues) {
                        this.set(k, initialValues[k]);
                    }
                }
            }
            Object.defineProperty(this, $childType, {
                value: undefined,
                enumerable: false,
                writable: true,
                configurable: true,
            });
        }
        /** Iterator */
        [Symbol.iterator]() { return this.$items[Symbol.iterator](); }
        get [Symbol.toStringTag]() { return this.$items[Symbol.toStringTag]; }
        static get [Symbol.species]() { return MapSchema; }
        set(key, value) {
            if (value === undefined || value === null) {
                throw new Error(`MapSchema#set('${key}', ${value}): trying to set ${value} value on '${key}'.`);
            }
            else if (typeof (value) === "object" && this[$childType]) {
                assertInstanceType(value, this[$childType], this, key);
            }
            // Force "key" as string
            // See: https://github.com/colyseus/colyseus/issues/561#issuecomment-1646733468
            key = key.toString();
            const changeTree = this[$changes];
            const isRef = (value[$changes]) !== undefined;
            let index;
            let operation;
            // IS REPLACE?
            if (typeof (changeTree.indexes[key]) !== "undefined") {
                index = changeTree.indexes[key];
                operation = exports.OPERATION.REPLACE;
                const previousValue = this.$items.get(key);
                if (previousValue === value) {
                    // if value is the same, avoid re-encoding it.
                    return;
                }
                else if (isRef) {
                    // if is schema, force ADD operation if value differ from previous one.
                    operation = exports.OPERATION.DELETE_AND_ADD;
                    // remove reference from previous value
                    if (previousValue !== undefined) {
                        previousValue[$changes].root?.remove(previousValue[$changes]);
                    }
                }
                if (this.deletedItems[index]) {
                    delete this.deletedItems[index];
                }
            }
            else {
                index = changeTree.indexes[$numFields] ?? 0;
                operation = exports.OPERATION.ADD;
                this.$indexes.set(index, key);
                changeTree.indexes[key] = index;
                changeTree.indexes[$numFields] = index + 1;
            }
            this.$items.set(key, value);
            changeTree.change(index, operation);
            //
            // set value's parent after the value is set
            // (to avoid encoding "refId" operations before parent's "ADD" operation)
            //
            if (isRef) {
                value[$changes].setParent(this, changeTree.root, index);
            }
            return this;
        }
        get(key) {
            return this.$items.get(key);
        }
        delete(key) {
            if (!this.$items.has(key)) {
                return false;
            }
            const index = this[$changes].indexes[key];
            this.deletedItems[index] = this[$changes].delete(index);
            return this.$items.delete(key);
        }
        clear() {
            const changeTree = this[$changes];
            // discard previous operations.
            changeTree.discard(true);
            changeTree.indexes = {};
            // remove children references
            changeTree.forEachChild((childChangeTree, _) => {
                changeTree.root?.remove(childChangeTree);
            });
            // clear previous indexes
            this.$indexes.clear();
            // clear items
            this.$items.clear();
            changeTree.operation(exports.OPERATION.CLEAR);
        }
        has(key) {
            return this.$items.has(key);
        }
        forEach(callbackfn) {
            this.$items.forEach(callbackfn);
        }
        entries() {
            return this.$items.entries();
        }
        keys() {
            return this.$items.keys();
        }
        values() {
            return this.$items.values();
        }
        get size() {
            return this.$items.size;
        }
        setIndex(index, key) {
            this.$indexes.set(index, key);
        }
        getIndex(index) {
            return this.$indexes.get(index);
        }
        [$getByIndex](index) {
            return this.$items.get(this.$indexes.get(index));
        }
        [$deleteByIndex](index) {
            const key = this.$indexes.get(index);
            this.$items.delete(key);
            this.$indexes.delete(index);
        }
        [$onEncodeEnd]() {
            const changeTree = this[$changes];
            // - cleanup changeTree.indexes
            // - cleanup $indexes
            for (const indexStr in this.deletedItems) {
                const index = parseInt(indexStr);
                const key = this.$indexes.get(index);
                // TODO: refactor this.
                // it shouldn't be necessary to keep track of indexes both on changeTree and on $indexes
                delete changeTree.indexes[key];
                this.$indexes.delete(index);
            }
            this.deletedItems = {};
        }
        toJSON() {
            const map = {};
            this.forEach((value, key) => {
                map[key] = (typeof (value['toJSON']) === "function")
                    ? value['toJSON']()
                    : value;
            });
            return map;
        }
        //
        // Decoding utilities
        //
        // @ts-ignore
        clone(isDecoding) {
            let cloned;
            if (isDecoding) {
                // client-side
                cloned = Object.assign(new MapSchema(), this);
            }
            else {
                // server-side
                cloned = new MapSchema();
                this.forEach((value, key) => {
                    if (value[$changes]) {
                        cloned.set(key, value['clone']());
                    }
                    else {
                        cloned.set(key, value);
                    }
                });
            }
            return cloned;
        }
    }
    registerType("map", { constructor: MapSchema });

    var _a$2, _b$2;
    class CollectionSchema {
        static { this[_a$2] = encodeKeyValueOperation; }
        static { this[_b$2] = decodeKeyValueOperation; }
        /**
         * Determine if a property must be filtered.
         * - If returns false, the property is NOT going to be encoded.
         * - If returns true, the property is going to be encoded.
         *
         * Encoding with "filters" happens in two steps:
         * - First, the encoder iterates over all "not owned" properties and encodes them.
         * - Then, the encoder iterates over all "owned" properties per instance and encodes them.
         */
        static [(_a$2 = $encoder, _b$2 = $decoder, $filter)](ref, index, view) {
            return (!view ||
                typeof (ref[$childType]) === "string" ||
                view.isChangeTreeVisible((ref[$getByIndex](index) ?? ref.deletedItems[index])[$changes]));
        }
        static is(type) {
            return type['collection'] !== undefined;
        }
        constructor(initialValues) {
            this.$items = new Map();
            this.$indexes = new Map();
            this.deletedItems = {};
            this.$refId = 0;
            this[$changes] = new ChangeTree(this);
            this[$changes].indexes = {};
            if (initialValues) {
                initialValues.forEach((v) => this.add(v));
            }
            Object.defineProperty(this, $childType, {
                value: undefined,
                enumerable: false,
                writable: true,
                configurable: true,
            });
        }
        add(value) {
            // set "index" for reference.
            const index = this.$refId++;
            const isRef = (value[$changes]) !== undefined;
            if (isRef) {
                value[$changes].setParent(this, this[$changes].root, index);
            }
            this[$changes].indexes[index] = index;
            this.$indexes.set(index, index);
            this.$items.set(index, value);
            this[$changes].change(index);
            return index;
        }
        at(index) {
            const key = Array.from(this.$items.keys())[index];
            return this.$items.get(key);
        }
        entries() {
            return this.$items.entries();
        }
        delete(item) {
            const entries = this.$items.entries();
            let index;
            let entry;
            while (entry = entries.next()) {
                if (entry.done) {
                    break;
                }
                if (item === entry.value[1]) {
                    index = entry.value[0];
                    break;
                }
            }
            if (index === undefined) {
                return false;
            }
            this.deletedItems[index] = this[$changes].delete(index);
            this.$indexes.delete(index);
            return this.$items.delete(index);
        }
        clear() {
            const changeTree = this[$changes];
            // discard previous operations.
            changeTree.discard(true);
            changeTree.indexes = {};
            // remove children references
            changeTree.forEachChild((childChangeTree, _) => {
                changeTree.root?.remove(childChangeTree);
            });
            // clear previous indexes
            this.$indexes.clear();
            // clear items
            this.$items.clear();
            changeTree.operation(exports.OPERATION.CLEAR);
        }
        has(value) {
            return Array.from(this.$items.values()).some((v) => v === value);
        }
        forEach(callbackfn) {
            this.$items.forEach((value, key, _) => callbackfn(value, key, this));
        }
        values() {
            return this.$items.values();
        }
        get size() {
            return this.$items.size;
        }
        /** Iterator */
        [Symbol.iterator]() {
            return this.$items.values();
        }
        setIndex(index, key) {
            this.$indexes.set(index, key);
        }
        getIndex(index) {
            return this.$indexes.get(index);
        }
        [$getByIndex](index) {
            return this.$items.get(this.$indexes.get(index));
        }
        [$deleteByIndex](index) {
            const key = this.$indexes.get(index);
            this.$items.delete(key);
            this.$indexes.delete(index);
        }
        [$onEncodeEnd]() {
            this.deletedItems = {};
        }
        toArray() {
            return Array.from(this.$items.values());
        }
        toJSON() {
            const values = [];
            this.forEach((value, key) => {
                values.push((typeof (value['toJSON']) === "function")
                    ? value['toJSON']()
                    : value);
            });
            return values;
        }
        //
        // Decoding utilities
        //
        clone(isDecoding) {
            let cloned;
            if (isDecoding) {
                // client-side
                cloned = Object.assign(new CollectionSchema(), this);
            }
            else {
                // server-side
                cloned = new CollectionSchema();
                this.forEach((value) => {
                    if (value[$changes]) {
                        cloned.add(value['clone']());
                    }
                    else {
                        cloned.add(value);
                    }
                });
            }
            return cloned;
        }
    }
    registerType("collection", { constructor: CollectionSchema, });

    var _a$1, _b$1;
    class SetSchema {
        static { this[_a$1] = encodeKeyValueOperation; }
        static { this[_b$1] = decodeKeyValueOperation; }
        /**
         * Determine if a property must be filtered.
         * - If returns false, the property is NOT going to be encoded.
         * - If returns true, the property is going to be encoded.
         *
         * Encoding with "filters" happens in two steps:
         * - First, the encoder iterates over all "not owned" properties and encodes them.
         * - Then, the encoder iterates over all "owned" properties per instance and encodes them.
         */
        static [(_a$1 = $encoder, _b$1 = $decoder, $filter)](ref, index, view) {
            return (!view ||
                typeof (ref[$childType]) === "string" ||
                view.visible.has((ref[$getByIndex](index) ?? ref.deletedItems[index])[$changes]));
        }
        static is(type) {
            return type['set'] !== undefined;
        }
        constructor(initialValues) {
            this.$items = new Map();
            this.$indexes = new Map();
            this.deletedItems = {};
            this.$refId = 0;
            this[$changes] = new ChangeTree(this);
            this[$changes].indexes = {};
            if (initialValues) {
                initialValues.forEach((v) => this.add(v));
            }
            Object.defineProperty(this, $childType, {
                value: undefined,
                enumerable: false,
                writable: true,
                configurable: true,
            });
        }
        add(value) {
            // immediatelly return false if value already added.
            if (this.has(value)) {
                return false;
            }
            // set "index" for reference.
            const index = this.$refId++;
            if ((value[$changes]) !== undefined) {
                value[$changes].setParent(this, this[$changes].root, index);
            }
            const operation = this[$changes].indexes[index]?.op ?? exports.OPERATION.ADD;
            this[$changes].indexes[index] = index;
            this.$indexes.set(index, index);
            this.$items.set(index, value);
            this[$changes].change(index, operation);
            return index;
        }
        entries() {
            return this.$items.entries();
        }
        delete(item) {
            const entries = this.$items.entries();
            let index;
            let entry;
            while (entry = entries.next()) {
                if (entry.done) {
                    break;
                }
                if (item === entry.value[1]) {
                    index = entry.value[0];
                    break;
                }
            }
            if (index === undefined) {
                return false;
            }
            this.deletedItems[index] = this[$changes].delete(index);
            this.$indexes.delete(index);
            return this.$items.delete(index);
        }
        clear() {
            const changeTree = this[$changes];
            // discard previous operations.
            changeTree.discard(true);
            changeTree.indexes = {};
            // clear previous indexes
            this.$indexes.clear();
            // clear items
            this.$items.clear();
            changeTree.operation(exports.OPERATION.CLEAR);
        }
        has(value) {
            const values = this.$items.values();
            let has = false;
            let entry;
            while (entry = values.next()) {
                if (entry.done) {
                    break;
                }
                if (value === entry.value) {
                    has = true;
                    break;
                }
            }
            return has;
        }
        forEach(callbackfn) {
            this.$items.forEach((value, key, _) => callbackfn(value, key, this));
        }
        values() {
            return this.$items.values();
        }
        get size() {
            return this.$items.size;
        }
        /** Iterator */
        [Symbol.iterator]() {
            return this.$items.values();
        }
        setIndex(index, key) {
            this.$indexes.set(index, key);
        }
        getIndex(index) {
            return this.$indexes.get(index);
        }
        [$getByIndex](index) {
            return this.$items.get(this.$indexes.get(index));
        }
        [$deleteByIndex](index) {
            const key = this.$indexes.get(index);
            this.$items.delete(key);
            this.$indexes.delete(index);
        }
        [$onEncodeEnd]() {
            this.deletedItems = {};
        }
        toArray() {
            return Array.from(this.$items.values());
        }
        toJSON() {
            const values = [];
            this.forEach((value, key) => {
                values.push((typeof (value['toJSON']) === "function")
                    ? value['toJSON']()
                    : value);
            });
            return values;
        }
        //
        // Decoding utilities
        //
        clone(isDecoding) {
            let cloned;
            if (isDecoding) {
                // client-side
                cloned = Object.assign(new SetSchema(), this);
            }
            else {
                // server-side
                cloned = new SetSchema();
                this.forEach((value) => {
                    if (value[$changes]) {
                        cloned.add(value['clone']());
                    }
                    else {
                        cloned.add(value);
                    }
                });
            }
            return cloned;
        }
    }
    registerType("set", { constructor: SetSchema });

    const DEFAULT_VIEW_TAG = -1;
    function entity(constructor) {
        TypeContext.register(constructor);
        return constructor;
    }
    /**
     * [See documentation](https://docs.colyseus.io/state/schema/)
     *
     * Annotate a Schema property to be serializeable.
     * \@type()'d fields are automatically flagged as "dirty" for the next patch.
     *
     * @example Standard usage, with automatic change tracking.
     * ```
     * \@type("string") propertyName: string;
     * ```
     *
     * @example You can provide the "manual" option if you'd like to manually control your patches via .setDirty().
     * ```
     * \@type("string", { manual: true })
     * ```
     */
    // export function type(type: DefinitionType, options?: TypeOptions) {
    //     return function ({ get, set }, context: ClassAccessorDecoratorContext): ClassAccessorDecoratorResult<Schema, any> {
    //         if (context.kind !== "accessor") {
    //             throw new Error("@type() is only supported for class accessor properties");
    //         }
    //         const field = context.name.toString();
    //         //
    //         // detect index for this field, considering inheritance
    //         //
    //         const parent = Object.getPrototypeOf(context.metadata);
    //         let fieldIndex: number = context.metadata[$numFields] // current structure already has fields defined
    //             ?? (parent && parent[$numFields]) // parent structure has fields defined
    //             ?? -1; // no fields defined
    //         fieldIndex++;
    //         if (
    //             !parent && // the parent already initializes the `$changes` property
    //             !Metadata.hasFields(context.metadata)
    //         ) {
    //             context.addInitializer(function (this: Ref) {
    //                 Object.defineProperty(this, $changes, {
    //                     value: new ChangeTree(this),
    //                     enumerable: false,
    //                     writable: true
    //                 });
    //             });
    //         }
    //         Metadata.addField(context.metadata, fieldIndex, field, type);
    //         const isArray = ArraySchema.is(type);
    //         const isMap = !isArray && MapSchema.is(type);
    //         // if (options && options.manual) {
    //         //     // do not declare getter/setter descriptor
    //         //     definition.descriptors[field] = {
    //         //         enumerable: true,
    //         //         configurable: true,
    //         //         writable: true,
    //         //     };
    //         //     return;
    //         // }
    //         return {
    //             init(value) {
    //                 // TODO: may need to convert ArraySchema/MapSchema here
    //                 // do not flag change if value is undefined.
    //                 if (value !== undefined) {
    //                     this[$changes].change(fieldIndex);
    //                     // automaticallty transform Array into ArraySchema
    //                     if (isArray) {
    //                         if (!(value instanceof ArraySchema)) {
    //                             value = new ArraySchema(...value);
    //                         }
    //                         value[$childType] = Object.values(type)[0];
    //                     }
    //                     // automaticallty transform Map into MapSchema
    //                     if (isMap) {
    //                         if (!(value instanceof MapSchema)) {
    //                             value = new MapSchema(value);
    //                         }
    //                         value[$childType] = Object.values(type)[0];
    //                     }
    //                     // try to turn provided structure into a Proxy
    //                     if (value['$proxy'] === undefined) {
    //                         if (isMap) {
    //                             value = getMapProxy(value);
    //                         }
    //                     }
    //                 }
    //                 return value;
    //             },
    //             get() {
    //                 return get.call(this);
    //             },
    //             set(value: any) {
    //                 /**
    //                  * Create Proxy for array or map items
    //                  */
    //                 // skip if value is the same as cached.
    //                 if (value === get.call(this)) {
    //                     return;
    //                 }
    //                 if (
    //                     value !== undefined &&
    //                     value !== null
    //                 ) {
    //                     // automaticallty transform Array into ArraySchema
    //                     if (isArray) {
    //                         if (!(value instanceof ArraySchema)) {
    //                             value = new ArraySchema(...value);
    //                         }
    //                         value[$childType] = Object.values(type)[0];
    //                     }
    //                     // automaticallty transform Map into MapSchema
    //                     if (isMap) {
    //                         if (!(value instanceof MapSchema)) {
    //                             value = new MapSchema(value);
    //                         }
    //                         value[$childType] = Object.values(type)[0];
    //                     }
    //                     // try to turn provided structure into a Proxy
    //                     if (value['$proxy'] === undefined) {
    //                         if (isMap) {
    //                             value = getMapProxy(value);
    //                         }
    //                     }
    //                     // flag the change for encoding.
    //                     this[$changes].change(fieldIndex);
    //                     //
    //                     // call setParent() recursively for this and its child
    //                     // structures.
    //                     //
    //                     if (value[$changes]) {
    //                         value[$changes].setParent(
    //                             this,
    //                             this[$changes].root,
    //                             Metadata.getIndex(context.metadata, field),
    //                         );
    //                     }
    //                 } else if (get.call(this)) {
    //                     //
    //                     // Setting a field to `null` or `undefined` will delete it.
    //                     //
    //                     this[$changes].delete(field);
    //                 }
    //                 set.call(this, value);
    //             },
    //         };
    //     }
    // }
    function view(tag = DEFAULT_VIEW_TAG) {
        return function (target, fieldName) {
            const constructor = target.constructor;
            const parentClass = Object.getPrototypeOf(constructor);
            const parentMetadata = parentClass[Symbol.metadata];
            // TODO: use Metadata.initialize()
            const metadata = (constructor[Symbol.metadata] ??= Object.assign({}, constructor[Symbol.metadata], parentMetadata ?? Object.create(null)));
            // const fieldIndex = metadata[fieldName];
            // if (!metadata[fieldIndex]) {
            //     //
            //     // detect index for this field, considering inheritance
            //     //
            //     metadata[fieldIndex] = {
            //         type: undefined,
            //         index: (metadata[$numFields] // current structure already has fields defined
            //             ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined
            //             ?? -1) + 1 // no fields defined
            //     }
            // }
            Metadata.setTag(metadata, fieldName, tag);
        };
    }
    function type(type, options) {
        return function (target, field) {
            const constructor = target.constructor;
            if (!type) {
                throw new Error(`${constructor.name}: @type() reference provided for "${field}" is undefined. Make sure you don't have any circular dependencies.`);
            }
            // Normalize type (enum/collection/etc)
            type = getNormalizedType(type);
            // for inheritance support
            TypeContext.register(constructor);
            const parentClass = Object.getPrototypeOf(constructor);
            const parentMetadata = parentClass[Symbol.metadata];
            const metadata = Metadata.initialize(constructor);
            let fieldIndex = metadata[field];
            /**
             * skip if descriptor already exists for this field (`@deprecated()`)
             */
            if (metadata[fieldIndex] !== undefined) {
                if (metadata[fieldIndex].deprecated) {
                    // do not create accessors for deprecated properties.
                    return;
                }
                else if (metadata[fieldIndex].type !== undefined) {
                    // trying to define same property multiple times across inheritance.
                    // https://github.com/colyseus/colyseus-unity3d/issues/131#issuecomment-814308572
                    try {
                        throw new Error(`@colyseus/schema: Duplicate '${field}' definition on '${constructor.name}'.\nCheck @type() annotation`);
                    }
                    catch (e) {
                        const definitionAtLine = e.stack.split("\n")[4].trim();
                        throw new Error(`${e.message} ${definitionAtLine}`);
                    }
                }
            }
            else {
                //
                // detect index for this field, considering inheritance
                //
                fieldIndex = metadata[$numFields] // current structure already has fields defined
                    ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined
                    ?? -1; // no fields defined
                fieldIndex++;
            }
            if (options && options.manual) {
                Metadata.addField(metadata, fieldIndex, field, type, {
                    // do not declare getter/setter descriptor
                    enumerable: true,
                    configurable: true,
                    writable: true,
                });
            }
            else {
                const complexTypeKlass = typeof (Object.keys(type)[0]) === "string" && getType(Object.keys(type)[0]);
                const childType = (complexTypeKlass)
                    ? Object.values(type)[0]
                    : type;
                Metadata.addField(metadata, fieldIndex, field, type, getPropertyDescriptor(`_${field}`, fieldIndex, childType, complexTypeKlass));
            }
        };
    }
    function getPropertyDescriptor(fieldCached, fieldIndex, type, complexTypeKlass) {
        return {
            get: function () { return this[fieldCached]; },
            set: function (value) {
                const previousValue = this[fieldCached] ?? undefined;
                // skip if value is the same as cached.
                if (value === previousValue) {
                    return;
                }
                if (value !== undefined &&
                    value !== null) {
                    if (complexTypeKlass) {
                        // automaticallty transform Array into ArraySchema
                        if (complexTypeKlass.constructor === ArraySchema && !(value instanceof ArraySchema)) {
                            value = new ArraySchema(...value);
                        }
                        // automaticallty transform Map into MapSchema
                        if (complexTypeKlass.constructor === MapSchema && !(value instanceof MapSchema)) {
                            value = new MapSchema(value);
                        }
                        // // automaticallty transform Array into SetSchema
                        // if (complexTypeKlass.constructor === SetSchema && !(value instanceof SetSchema)) {
                        //     value = new SetSchema(value);
                        // }
                        value[$childType] = type;
                    }
                    else if (typeof (type) !== "string") {
                        assertInstanceType(value, type, this, fieldCached.substring(1));
                    }
                    else {
                        assertType(value, type, this, fieldCached.substring(1));
                    }
                    const changeTree = this[$changes];
                    //
                    // Replacing existing "ref", remove it from root.
                    //
                    if (previousValue !== undefined && previousValue[$changes]) {
                        changeTree.root?.remove(previousValue[$changes]);
                        this.constructor[$track](changeTree, fieldIndex, exports.OPERATION.DELETE_AND_ADD);
                    }
                    else {
                        this.constructor[$track](changeTree, fieldIndex, exports.OPERATION.ADD);
                    }
                    //
                    // call setParent() recursively for this and its child
                    // structures.
                    //
                    value[$changes]?.setParent(this, changeTree.root, fieldIndex);
                }
                else if (previousValue !== undefined) {
                    //
                    // Setting a field to `null` or `undefined` will delete it.
                    //
                    this[$changes].delete(fieldIndex);
                }
                this[fieldCached] = value;
            },
            enumerable: true,
            configurable: true
        };
    }
    /**
     * `@deprecated()` flag a field as deprecated.
     * The previous `@type()` annotation should remain along with this one.
     */
    function deprecated(throws = true) {
        return function (klass, field) {
            //
            // FIXME: the following block of code is repeated across `@type()`, `@deprecated()` and `@unreliable()` decorators.
            //
            const constructor = klass.constructor;
            const parentClass = Object.getPrototypeOf(constructor);
            const parentMetadata = parentClass[Symbol.metadata];
            const metadata = (constructor[Symbol.metadata] ??= Object.assign({}, constructor[Symbol.metadata], parentMetadata ?? Object.create(null)));
            const fieldIndex = metadata[field];
            // if (!metadata[field]) {
            //     //
            //     // detect index for this field, considering inheritance
            //     //
            //     metadata[field] = {
            //         type: undefined,
            //         index: (metadata[$numFields] // current structure already has fields defined
            //             ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined
            //             ?? -1) + 1 // no fields defined
            //     }
            // }
            metadata[fieldIndex].deprecated = true;
            if (throws) {
                metadata[$descriptors] ??= {};
                metadata[$descriptors][field] = {
                    get: function () { throw new Error(`${field} is deprecated.`); },
                    set: function (value) { },
                    enumerable: false,
                    configurable: true
                };
            }
            // flag metadata[field] as non-enumerable
            Object.defineProperty(metadata, fieldIndex, {
                value: metadata[fieldIndex],
                enumerable: false,
                configurable: true
            });
        };
    }
    function defineTypes(target, fields, options) {
        for (let field in fields) {
            type(fields[field], options)(target.prototype, field);
        }
        return target;
    }
    function schema(fieldsAndMethods, name, inherits = Schema) {
        const fields = {};
        const methods = {};
        const defaultValues = {};
        const viewTagFields = {};
        for (let fieldName in fieldsAndMethods) {
            const value = fieldsAndMethods[fieldName];
            if (typeof (value) === "object") {
                if (value['view'] !== undefined) {
                    viewTagFields[fieldName] = (typeof (value['view']) === "boolean")
                        ? DEFAULT_VIEW_TAG
                        : value['view'];
                }
                fields[fieldName] = getNormalizedType(value);
                // If no explicit default provided, handle automatic instantiation for collection types
                if (!Object.prototype.hasOwnProperty.call(value, 'default')) {
                    // TODO: remove Array.isArray() check. Use ['array'] !== undefined only.
                    if (Array.isArray(value) || value['array'] !== undefined) {
                        // Collection: Array  new ArraySchema()
                        defaultValues[fieldName] = new ArraySchema();
                    }
                    else if (value['map'] !== undefined) {
                        // Collection: Map  new MapSchema()
                        defaultValues[fieldName] = new MapSchema();
                    }
                    else if (value['collection'] !== undefined) {
                        // Collection: Collection  new CollectionSchema()
                        defaultValues[fieldName] = new CollectionSchema();
                    }
                    else if (value['set'] !== undefined) {
                        // Collection: Set  new SetSchema()
                        defaultValues[fieldName] = new SetSchema();
                    }
                    else if (value['type'] !== undefined && Schema.is(value['type'])) {
                        // Direct Schema type: Type  new Type()
                        if (!value['type'].prototype.initialize || value['type'].prototype.initialize.length === 0) {
                            // only auto-initialize Schema instances if:
                            // - they don't have an initialize method
                            // - or initialize method doesn't accept any parameters
                            defaultValues[fieldName] = new value['type']();
                        }
                    }
                }
                else {
                    defaultValues[fieldName] = value['default'];
                }
            }
            else if (typeof (value) === "function") {
                if (Schema.is(value)) {
                    // Direct Schema type: Type  new Type()
                    if (!value.prototype.initialize || value.prototype.initialize.length === 0) {
                        // only auto-initialize Schema instances if:
                        // - they don't have an initialize method
                        // - or initialize method doesn't accept any parameters
                        defaultValues[fieldName] = new value();
                    }
                    fields[fieldName] = getNormalizedType(value);
                }
                else {
                    methods[fieldName] = value;
                }
            }
            else {
                fields[fieldName] = getNormalizedType(value);
            }
        }
        const getDefaultValues = () => {
            const defaults = {};
            // use current class default values
            for (const fieldName in defaultValues) {
                const defaultValue = defaultValues[fieldName];
                if (defaultValue && typeof defaultValue.clone === 'function') {
                    // complex, cloneable values, e.g. Schema, ArraySchema, MapSchema, CollectionSchema, SetSchema
                    defaults[fieldName] = defaultValue.clone();
                }
                else {
                    // primitives and non-cloneable values
                    defaults[fieldName] = defaultValue;
                }
            }
            return defaults;
        };
        const getParentProps = (props) => {
            const fieldNames = Object.keys(fields);
            const parentProps = {};
            for (const key in props) {
                if (!fieldNames.includes(key)) {
                    parentProps[key] = props[key];
                }
            }
            return parentProps;
        };
        /** @codegen-ignore */
        const klass = Metadata.setFields(class extends inherits {
            constructor(...args) {
                // call initialize method
                if (methods.initialize && typeof methods.initialize === 'function') {
                    super(Object.assign({}, getDefaultValues(), getParentProps(args[0] || {})));
                    /**
                     * only call initialize() in the current class, not the parent ones.
                     * see "should not call initialize automatically when creating an instance of inherited Schema"
                     */
                    if (new.target === klass) {
                        methods.initialize.apply(this, args);
                    }
                }
                else {
                    super(Object.assign({}, getDefaultValues(), args[0] || {}));
                }
            }
        }, fields);
        // Store the getDefaultValues function on the class for inheritance
        klass._getDefaultValues = getDefaultValues;
        // Add methods to the prototype
        Object.assign(klass.prototype, methods);
        for (let fieldName in viewTagFields) {
            view(viewTagFields[fieldName])(klass.prototype, fieldName);
        }
        if (name) {
            Object.defineProperty(klass, "name", { value: name });
        }
        klass.extends = (fields, name) => schema(fields, name, klass);
        return klass;
    }

    function getIndent(level) {
        return (new Array(level).fill(0)).map((_, i) => (i === level - 1) ? ` ` : `   `).join("");
    }
    function dumpChanges(schema) {
        const $root = schema[$changes].root;
        const dump = {
            ops: {},
            refs: []
        };
        // for (const refId in $root.changes) {
        let current = $root.changes.next;
        while (current) {
            const changeTree = current.changeTree;
            // skip if ChangeTree is undefined
            if (changeTree === undefined) {
                current = current.next;
                continue;
            }
            const changes = changeTree.indexedOperations;
            dump.refs.push(`refId#${changeTree.refId}`);
            for (const index in changes) {
                const op = changes[index];
                const opName = exports.OPERATION[op];
                if (!dump.ops[opName]) {
                    dump.ops[opName] = 0;
                }
                dump.ops[exports.OPERATION[op]]++;
            }
            current = current.next;
        }
        return dump;
    }

    var _a, _b;
    /**
     * Schema encoder / decoder
     */
    class Schema {
        static { this[_a] = encodeSchemaOperation; }
        static { this[_b] = decodeSchemaOperation; }
        /**
         * Assign the property descriptors required to track changes on this instance.
         * @param instance
         */
        static initialize(instance) {
            Object.defineProperty(instance, $changes, {
                value: new ChangeTree(instance),
                enumerable: false,
                writable: true
            });
            Object.defineProperties(instance, instance.constructor[Symbol.metadata]?.[$descriptors] || {});
        }
        static is(type) {
            return typeof (type[Symbol.metadata]) === "object";
        }
        /**
         * Track property changes
         */
        static [(_a = $encoder, _b = $decoder, $track)](changeTree, index, operation = exports.OPERATION.ADD) {
            changeTree.change(index, operation);
        }
        /**
         * Determine if a property must be filtered.
         * - If returns false, the property is NOT going to be encoded.
         * - If returns true, the property is going to be encoded.
         *
         * Encoding with "filters" happens in two steps:
         * - First, the encoder iterates over all "not owned" properties and encodes them.
         * - Then, the encoder iterates over all "owned" properties per instance and encodes them.
         */
        static [$filter](ref, index, view) {
            const metadata = ref.constructor[Symbol.metadata];
            const tag = metadata[index]?.tag;
            if (view === undefined) {
                // shared pass/encode: encode if doesn't have a tag
                return tag === undefined;
            }
            else if (tag === undefined) {
                // view pass: no tag
                return true;
            }
            else if (tag === DEFAULT_VIEW_TAG) {
                // view pass: default tag
                return view.isChangeTreeVisible(ref[$changes]);
            }
            else {
                // view pass: custom tag
                const tags = view.tags?.get(ref[$changes]);
                return tags && tags.has(tag);
            }
        }
        // allow inherited classes to have a constructor
        constructor(arg) {
            //
            // inline
            // Schema.initialize(this);
            //
            Schema.initialize(this);
            //
            // Assign initial values
            //
            if (arg) {
                Object.assign(this, arg);
            }
        }
        assign(props) {
            Object.assign(this, props);
            return this;
        }
        /**
         * (Server-side): Flag a property to be encoded for the next patch.
         * @param instance Schema instance
         * @param property string representing the property name, or number representing the index of the property.
         * @param operation OPERATION to perform (detected automatically)
         */
        setDirty(property, operation) {
            const metadata = this.constructor[Symbol.metadata];
            this[$changes].change(metadata[metadata[property]].index, operation);
        }
        clone() {
            // Create instance without calling custom constructor
            const cloned = Object.create(this.constructor.prototype);
            Schema.initialize(cloned);
            const metadata = this.constructor[Symbol.metadata];
            //
            // TODO: clone all properties, not only annotated ones
            //
            // for (const field in this) {
            for (const fieldIndex in metadata) {
                const field = metadata[fieldIndex].name;
                if (typeof (this[field]) === "object" &&
                    typeof (this[field]?.clone) === "function") {
                    // deep clone
                    cloned[field] = this[field].clone();
                }
                else {
                    // primitive values
                    cloned[field] = this[field];
                }
            }
            return cloned;
        }
        toJSON() {
            const obj = {};
            const metadata = this.constructor[Symbol.metadata];
            for (const index in metadata) {
                const field = metadata[index];
                const fieldName = field.name;
                if (!field.deprecated && this[fieldName] !== null && typeof (this[fieldName]) !== "undefined") {
                    obj[fieldName] = (typeof (this[fieldName]['toJSON']) === "function")
                        ? this[fieldName]['toJSON']()
                        : this[fieldName];
                }
            }
            return obj;
        }
        /**
         * Used in tests only
         * @internal
         */
        discardAllChanges() {
            this[$changes].discardAll();
        }
        [$getByIndex](index) {
            const metadata = this.constructor[Symbol.metadata];
            return this[metadata[index].name];
        }
        [$deleteByIndex](index) {
            const metadata = this.constructor[Symbol.metadata];
            this[metadata[index].name] = undefined;
        }
        /**
         * Inspect the `refId` of all Schema instances in the tree. Optionally display the contents of the instance.
         *
         * @param ref Schema instance
         * @param showContents display JSON contents of the instance
         * @returns
         */
        static debugRefIds(ref, showContents = false, level = 0, decoder, keyPrefix = "") {
            const contents = (showContents) ? ` - ${JSON.stringify(ref.toJSON())}` : "";
            const changeTree = ref[$changes];
            const refId = (decoder) ? decoder.root.refIds.get(ref) : changeTree.refId;
            const root = (decoder) ? decoder.root : changeTree.root;
            // log reference count if > 1
            const refCount = (root?.refCount?.[refId] > 1)
                ? ` [${root.refCount[refId]}]`
                : '';
            let output = `${getIndent(level)}${keyPrefix}${ref.constructor.name} (refId: ${refId})${refCount}${contents}\n`;
            changeTree.forEachChild((childChangeTree, indexOrKey) => {
                let key = indexOrKey;
                if (typeof indexOrKey === 'number' && ref['$indexes']) {
                    // MapSchema
                    key = ref['$indexes'].get(indexOrKey) ?? indexOrKey;
                }
                const keyPrefix = (ref['forEach'] !== undefined && key !== undefined) ? `["${key}"]: ` : "";
                output += this.debugRefIds(childChangeTree.ref, showContents, level + 1, decoder, keyPrefix);
            });
            return output;
        }
        static debugRefIdEncodingOrder(ref, changeSet = 'allChanges') {
            let encodeOrder = [];
            let current = ref[$changes].root[changeSet].next;
            while (current) {
                if (current.changeTree) {
                    encodeOrder.push(current.changeTree.refId);
                }
                current = current.next;
            }
            return encodeOrder;
        }
        static debugRefIdsFromDecoder(decoder) {
            return this.debugRefIds(decoder.state, false, 0, decoder);
        }
        /**
         * Return a string representation of the changes on a Schema instance.
         * The list of changes is cleared after each encode.
         *
         * @param instance Schema instance
         * @param isEncodeAll Return "full encode" instead of current change set.
         * @returns
         */
        static debugChanges(instance, isEncodeAll = false) {
            const changeTree = instance[$changes];
            const changeSet = (isEncodeAll) ? changeTree.allChanges : changeTree.changes;
            const changeSetName = (isEncodeAll) ? "allChanges" : "changes";
            let output = `${instance.constructor.name} (${changeTree.refId}) -> .${changeSetName}:\n`;
            function dumpChangeSet(changeSet) {
                changeSet.operations
                    .filter(op => op)
                    .forEach((index) => {
                    const operation = changeTree.indexedOperations[index];
                    output += `- [${index}]: ${exports.OPERATION[operation]} (${JSON.stringify(changeTree.getValue(Number(index), isEncodeAll))})\n`;
                });
            }
            dumpChangeSet(changeSet);
            // display filtered changes
            if (!isEncodeAll &&
                changeTree.filteredChanges &&
                (changeTree.filteredChanges.operations).filter(op => op).length > 0) {
                output += `${instance.constructor.name} (${changeTree.refId}) -> .filteredChanges:\n`;
                dumpChangeSet(changeTree.filteredChanges);
            }
            // display filtered changes
            if (isEncodeAll &&
                changeTree.allFilteredChanges &&
                (changeTree.allFilteredChanges.operations).filter(op => op).length > 0) {
                output += `${instance.constructor.name} (${changeTree.refId}) -> .allFilteredChanges:\n`;
                dumpChangeSet(changeTree.allFilteredChanges);
            }
            return output;
        }
        static debugChangesDeep(ref, changeSetName = "changes") {
            let output = "";
            const rootChangeTree = ref[$changes];
            const root = rootChangeTree.root;
            const changeTrees = new Map();
            const instanceRefIds = [];
            let totalOperations = 0;
            // TODO: FIXME: this method is not working as expected
            for (const [refId, changes] of Object.entries(root[changeSetName])) {
                const changeTree = root.changeTrees[refId];
                if (!changeTree) {
                    continue;
                }
                let includeChangeTree = false;
                let parentChangeTrees = [];
                let parentChangeTree = changeTree.parent?.[$changes];
                if (changeTree === rootChangeTree) {
                    includeChangeTree = true;
                }
                else {
                    while (parentChangeTree !== undefined) {
                        parentChangeTrees.push(parentChangeTree);
                        if (parentChangeTree.ref === ref) {
                            includeChangeTree = true;
                            break;
                        }
                        parentChangeTree = parentChangeTree.parent?.[$changes];
                    }
                }
                if (includeChangeTree) {
                    instanceRefIds.push(changeTree.refId);
                    totalOperations += Object.keys(changes).length;
                    changeTrees.set(changeTree, parentChangeTrees.reverse());
                }
            }
            output += "---\n";
            output += `root refId: ${rootChangeTree.refId}\n`;
            output += `Total instances: ${instanceRefIds.length} (refIds: ${instanceRefIds.join(", ")})\n`;
            output += `Total changes: ${totalOperations}\n`;
            output += "---\n";
            // based on root.changes, display a tree of changes that has the "ref" instance as parent
            const visitedParents = new WeakSet();
            for (const [changeTree, parentChangeTrees] of changeTrees.entries()) {
                parentChangeTrees.forEach((parentChangeTree, level) => {
                    if (!visitedParents.has(parentChangeTree)) {
                        output += `${getIndent(level)}${parentChangeTree.ref.constructor.name} (refId: ${parentChangeTree.refId})\n`;
                        visitedParents.add(parentChangeTree);
                    }
                });
                const changes = changeTree.indexedOperations;
                const level = parentChangeTrees.length;
                const indent = getIndent(level);
                const parentIndex = (level > 0) ? `(${changeTree.parentIndex}) ` : "";
                output += `${indent}${parentIndex}${changeTree.ref.constructor.name} (refId: ${changeTree.refId}) - changes: ${Object.keys(changes).length}\n`;
                for (const index in changes) {
                    const operation = changes[index];
                    output += `${getIndent(level + 1)}${exports.OPERATION[operation]}: ${index}\n`;
                }
            }
            return `${output}`;
        }
    }

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol, Iterator */


    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    class Root {
        constructor(types) {
            this.types = types;
            this.nextUniqueId = 0;
            this.refCount = {};
            this.changeTrees = {};
            // all changes
            this.allChanges = createChangeTreeList();
            this.allFilteredChanges = createChangeTreeList(); // TODO: do not initialize it if filters are not used
            // pending changes to be encoded
            this.changes = createChangeTreeList();
            this.filteredChanges = createChangeTreeList(); // TODO: do not initialize it if filters are not used
        }
        getNextUniqueId() {
            return this.nextUniqueId++;
        }
        add(changeTree) {
            // Assign unique `refId` to changeTree if it doesn't have one yet.
            if (changeTree.refId === undefined) {
                changeTree.refId = this.getNextUniqueId();
            }
            const isNewChangeTree = (this.changeTrees[changeTree.refId] === undefined);
            if (isNewChangeTree) {
                this.changeTrees[changeTree.refId] = changeTree;
            }
            const previousRefCount = this.refCount[changeTree.refId];
            if (previousRefCount === 0) {
                //
                // When a ChangeTree is re-added, it means that it was previously removed.
                // We need to re-add all changes to the `changes` map.
                //
                const ops = changeTree.allChanges.operations;
                let len = ops.length;
                while (len--) {
                    changeTree.indexedOperations[ops[len]] = exports.OPERATION.ADD;
                    setOperationAtIndex(changeTree.changes, len);
                }
            }
            this.refCount[changeTree.refId] = (previousRefCount || 0) + 1;
            // console.log("ADD", { refId: changeTree.refId, ref: changeTree.ref.constructor.name, refCount: this.refCount[changeTree.refId], isNewChangeTree });
            return isNewChangeTree;
        }
        remove(changeTree) {
            const refCount = (this.refCount[changeTree.refId]) - 1;
            // console.log("REMOVE", { refId: changeTree.refId, ref: changeTree.ref.constructor.name, refCount, needRemove: refCount <= 0 });
            if (refCount <= 0) {
                //
                // Only remove "root" reference if it's the last reference
                //
                changeTree.root = undefined;
                delete this.changeTrees[changeTree.refId];
                this.removeChangeFromChangeSet("allChanges", changeTree);
                this.removeChangeFromChangeSet("changes", changeTree);
                if (changeTree.filteredChanges) {
                    this.removeChangeFromChangeSet("allFilteredChanges", changeTree);
                    this.removeChangeFromChangeSet("filteredChanges", changeTree);
                }
                this.refCount[changeTree.refId] = 0;
                changeTree.forEachChild((child, _) => {
                    if (child.removeParent(changeTree.ref)) {
                        if ((child.parentChain === undefined || // no parent, remove it
                            (child.parentChain && this.refCount[child.refId] > 0) // parent is still in use, but has more than one reference, remove it
                        )) {
                            this.remove(child);
                        }
                        else if (child.parentChain) {
                            // re-assigning a child of the same root, move it next to parent
                            this.moveNextToParent(child);
                        }
                    }
                });
            }
            else {
                this.refCount[changeTree.refId] = refCount;
                //
                // When losing a reference to an instance, it is best to move the
                // ChangeTree next to its parent in the encoding queue.
                //
                // This way, at decoding time, the instance that contains the
                // ChangeTree will be available before the ChangeTree itself. If the
                // containing instance is not available, the Decoder will throw
                // "refId not found" error.
                //
                this.recursivelyMoveNextToParent(changeTree);
            }
            return refCount;
        }
        recursivelyMoveNextToParent(changeTree) {
            this.moveNextToParent(changeTree);
            changeTree.forEachChild((child, _) => this.recursivelyMoveNextToParent(child));
        }
        moveNextToParent(changeTree) {
            if (changeTree.filteredChanges) {
                this.moveNextToParentInChangeTreeList("filteredChanges", changeTree);
                this.moveNextToParentInChangeTreeList("allFilteredChanges", changeTree);
            }
            else {
                this.moveNextToParentInChangeTreeList("changes", changeTree);
                this.moveNextToParentInChangeTreeList("allChanges", changeTree);
            }
        }
        moveNextToParentInChangeTreeList(changeSetName, changeTree) {
            const changeSet = this[changeSetName];
            const node = changeTree[changeSetName].queueRootNode;
            if (!node)
                return;
            // Find the parent in the linked list
            const parent = changeTree.parent;
            if (!parent || !parent[$changes])
                return;
            const parentNode = parent[$changes][changeSetName]?.queueRootNode;
            if (!parentNode || parentNode === node)
                return;
            // Use cached positions - no iteration needed!
            const parentPosition = parentNode.position;
            const childPosition = node.position;
            // If child is already after parent, no need to move
            if (childPosition > parentPosition)
                return;
            // Child is before parent, so we need to move it after parent
            // This maintains decoding order (parent before child)
            // Remove node from current position
            if (node.prev) {
                node.prev.next = node.next;
            }
            else {
                changeSet.next = node.next;
            }
            if (node.next) {
                node.next.prev = node.prev;
            }
            else {
                changeSet.tail = node.prev;
            }
            // Insert node right after parent
            node.prev = parentNode;
            node.next = parentNode.next;
            if (parentNode.next) {
                parentNode.next.prev = node;
            }
            else {
                changeSet.tail = node;
            }
            parentNode.next = node;
            // Update positions after the move
            this.updatePositionsAfterMove(changeSet, node, parentPosition + 1);
        }
        enqueueChangeTree(changeTree, changeSet, queueRootNode = changeTree[changeSet].queueRootNode) {
            // skip
            if (queueRootNode) {
                return;
            }
            // Add to linked list if not already present
            changeTree[changeSet].queueRootNode = this.addToChangeTreeList(this[changeSet], changeTree);
        }
        addToChangeTreeList(list, changeTree) {
            const node = {
                changeTree,
                next: undefined,
                prev: undefined,
                position: list.tail ? list.tail.position + 1 : 0
            };
            if (!list.next) {
                list.next = node;
                list.tail = node;
            }
            else {
                node.prev = list.tail;
                list.tail.next = node;
                list.tail = node;
            }
            return node;
        }
        updatePositionsAfterRemoval(list, removedPosition) {
            // Update positions for all nodes after the removed position
            let current = list.next;
            let position = 0;
            while (current) {
                if (position >= removedPosition) {
                    current.position = position;
                }
                current = current.next;
                position++;
            }
        }
        updatePositionsAfterMove(list, node, newPosition) {
            // Recalculate all positions - this is more reliable than trying to be clever
            let current = list.next;
            let position = 0;
            while (current) {
                current.position = position;
                current = current.next;
                position++;
            }
        }
        removeChangeFromChangeSet(changeSetName, changeTree) {
            const changeSet = this[changeSetName];
            const node = changeTree[changeSetName].queueRootNode;
            if (node && node.changeTree === changeTree) {
                const removedPosition = node.position;
                // Remove the node from the linked list
                if (node.prev) {
                    node.prev.next = node.next;
                }
                else {
                    changeSet.next = node.next;
                }
                if (node.next) {
                    node.next.prev = node.prev;
                }
                else {
                    changeSet.tail = node.prev;
                }
                // Update positions for nodes that came after the removed node
                this.updatePositionsAfterRemoval(changeSet, removedPosition);
                // Clear ChangeTree reference
                changeTree[changeSetName].queueRootNode = undefined;
                return true;
            }
            return false;
        }
    }

    class Encoder {
        static { this.BUFFER_SIZE = (typeof (Buffer) !== "undefined") && Buffer.poolSize || 8 * 1024; } // 8KB
        constructor(state) {
            this.sharedBuffer = Buffer.allocUnsafe(Encoder.BUFFER_SIZE);
            //
            // Use .cache() here to avoid re-creating a new context for every new room instance.
            //
            // We may need to make this optional in case of dynamically created
            // schemas - which would lead to memory leaks
            //
            this.context = TypeContext.cache(state.constructor);
            this.root = new Root(this.context);
            this.setState(state);
            // console.log(">>>>>>>>>>>>>>>> Encoder types");
            // this.context.schemas.forEach((id, schema) => {
            //     console.log("type:", id, schema.name, Object.keys(schema[Symbol.metadata]));
            // });
        }
        setState(state) {
            this.state = state;
            this.state[$changes].setRoot(this.root);
        }
        encode(it = { offset: 0 }, view, buffer = this.sharedBuffer, changeSetName = "changes", isEncodeAll = changeSetName === "allChanges", initialOffset = it.offset // cache current offset in case we need to resize the buffer
        ) {
            const hasView = (view !== undefined);
            const rootChangeTree = this.state[$changes];
            let current = this.root[changeSetName];
            while (current = current.next) {
                const changeTree = current.changeTree;
                if (hasView) {
                    if (!view.isChangeTreeVisible(changeTree)) {
                        // console.log("MARK AS INVISIBLE:", { ref: changeTree.ref.constructor.name, refId: changeTree.refId, raw: changeTree.ref.toJSON() });
                        view.invisible.add(changeTree);
                        continue; // skip this change tree
                    }
                    view.invisible.delete(changeTree); // remove from invisible list
                }
                const changeSet = changeTree[changeSetName];
                const ref = changeTree.ref;
                // TODO: avoid iterating over change tree if no changes were made
                const numChanges = changeSet.operations.length;
                if (numChanges === 0) {
                    continue;
                }
                const ctor = ref.constructor;
                const encoder = ctor[$encoder];
                const filter = ctor[$filter];
                const metadata = ctor[Symbol.metadata];
                // skip root `refId` if it's the first change tree
                // (unless it "hasView", which will need to revisit the root)
                if (hasView || it.offset > initialOffset || changeTree !== rootChangeTree) {
                    buffer[it.offset++] = SWITCH_TO_STRUCTURE & 255;
                    encode.number(buffer, changeTree.refId, it);
                }
                for (let j = 0; j < numChanges; j++) {
                    const fieldIndex = changeSet.operations[j];
                    if (fieldIndex < 0) {
                        // "pure" operation without fieldIndex (e.g. CLEAR, REVERSE, etc.)
                        // encode and continue early - no need to reach $filter check
                        buffer[it.offset++] = Math.abs(fieldIndex) & 255;
                        continue;
                    }
                    const operation = (isEncodeAll)
                        ? exports.OPERATION.ADD
                        : changeTree.indexedOperations[fieldIndex];
                    //
                    // first pass (encodeAll), identify "filtered" operations without encoding them
                    // they will be encoded per client, based on their view.
                    //
                    // TODO: how can we optimize filtering out "encode all" operations?
                    // TODO: avoid checking if no view tags were defined
                    //
                    if (fieldIndex === undefined || operation === undefined || (filter && !filter(ref, fieldIndex, view))) {
                        // console.log("ADD AS INVISIBLE:", fieldIndex, changeTree.ref.constructor.name)
                        // view?.invisible.add(changeTree);
                        continue;
                    }
                    encoder(this, buffer, changeTree, fieldIndex, operation, it, isEncodeAll, hasView, metadata);
                }
            }
            if (it.offset > buffer.byteLength) {
                // we can assume that n + 1 poolSize will suffice given that we are likely done with encoding at this point
                // multiples of poolSize are faster to allocate than arbitrary sizes
                // if we are on an older platform that doesn't implement pooling use 8kb as poolSize (that's the default for node)
                const newSize = Math.ceil(it.offset / (Buffer.poolSize ?? 8 * 1024)) * (Buffer.poolSize ?? 8 * 1024);
                console.warn(`@colyseus/schema buffer overflow. Encoded state is higher than default BUFFER_SIZE. Use the following to increase default BUFFER_SIZE:

    import { Encoder } from "@colyseus/schema";
    Encoder.BUFFER_SIZE = ${Math.round(newSize / 1024)} * 1024; // ${Math.round(newSize / 1024)} KB
`);
                //
                // resize buffer and re-encode (TODO: can we avoid re-encoding here?)
                // -> No we probably can't unless we catch the need for resize before encoding which is likely more computationally expensive than resizing on demand
                //
                buffer = Buffer.alloc(newSize, buffer); // fill with buffer here to memcpy previous encoding steps beyond the initialOffset
                // assign resized buffer to local sharedBuffer
                if (buffer === this.sharedBuffer) {
                    this.sharedBuffer = buffer;
                }
                return this.encode({ offset: initialOffset }, view, buffer, changeSetName, isEncodeAll);
            }
            else {
                return buffer.subarray(0, it.offset);
            }
        }
        encodeAll(it = { offset: 0 }, buffer = this.sharedBuffer) {
            return this.encode(it, undefined, buffer, "allChanges", true);
        }
        encodeAllView(view, sharedOffset, it, bytes = this.sharedBuffer) {
            const viewOffset = it.offset;
            // try to encode "filtered" changes
            this.encode(it, view, bytes, "allFilteredChanges", true, viewOffset);
            return Buffer.concat([
                bytes.subarray(0, sharedOffset),
                bytes.subarray(viewOffset, it.offset)
            ]);
        }
        encodeView(view, sharedOffset, it, bytes = this.sharedBuffer) {
            const viewOffset = it.offset;
            // encode visibility changes (add/remove for this view)
            for (const [refId, changes] of view.changes) {
                const changeTree = this.root.changeTrees[refId];
                if (changeTree === undefined) {
                    // detached instance, remove from view and skip.
                    // console.log("detached instance, remove from view and skip.", refId);
                    view.changes.delete(refId);
                    continue;
                }
                const keys = Object.keys(changes);
                if (keys.length === 0) {
                    // FIXME: avoid having empty changes if no changes were made
                    // console.log("changes.size === 0, skip", refId, changeTree.ref.constructor.name);
                    continue;
                }
                const ref = changeTree.ref;
                const ctor = ref.constructor;
                const encoder = ctor[$encoder];
                const metadata = ctor[Symbol.metadata];
                bytes[it.offset++] = SWITCH_TO_STRUCTURE & 255;
                encode.number(bytes, changeTree.refId, it);
                for (let i = 0, numChanges = keys.length; i < numChanges; i++) {
                    const index = Number(keys[i]);
                    // workaround when using view.add() on item that has been deleted from state (see test "adding to view item that has been removed from state")
                    const value = changeTree.ref[$getByIndex](index);
                    const operation = (value !== undefined && changes[index]) || exports.OPERATION.DELETE;
                    // isEncodeAll = false
                    // hasView = true
                    encoder(this, bytes, changeTree, index, operation, it, false, true, metadata);
                }
            }
            //
            // TODO: only clear view changes after all views are encoded
            // (to allow re-using StateView's for multiple clients)
            //
            // clear "view" changes after encoding
            view.changes.clear();
            // try to encode "filtered" changes
            this.encode(it, view, bytes, "filteredChanges", false, viewOffset);
            return Buffer.concat([
                bytes.subarray(0, sharedOffset),
                bytes.subarray(viewOffset, it.offset)
            ]);
        }
        discardChanges() {
            // discard shared changes
            let current = this.root.changes.next;
            while (current) {
                current.changeTree.endEncode('changes');
                current = current.next;
            }
            this.root.changes = createChangeTreeList();
            // discard filtered changes
            current = this.root.filteredChanges.next;
            while (current) {
                current.changeTree.endEncode('filteredChanges');
                current = current.next;
            }
            this.root.filteredChanges = createChangeTreeList();
        }
        tryEncodeTypeId(bytes, baseType, targetType, it) {
            const baseTypeId = this.context.getTypeId(baseType);
            const targetTypeId = this.context.getTypeId(targetType);
            if (targetTypeId === undefined) {
                console.warn(`@colyseus/schema WARNING: Class "${targetType.name}" is not registered on TypeRegistry - Please either tag the class with @entity or define a @type() field.`);
                return;
            }
            if (baseTypeId !== targetTypeId) {
                bytes[it.offset++] = TYPE_ID & 255;
                encode.number(bytes, targetTypeId, it);
            }
        }
        get hasChanges() {
            return (this.root.changes.next !== undefined ||
                this.root.filteredChanges.next !== undefined);
        }
    }

    function spliceOne(arr, index) {
        // manually splice an array
        if (index === -1 || index >= arr.length) {
            return false;
        }
        const len = arr.length - 1;
        for (let i = index; i < len; i++) {
            arr[i] = arr[i + 1];
        }
        arr.length = len;
        return true;
    }

    class DecodingWarning extends Error {
        constructor(message) {
            super(message);
            this.name = "DecodingWarning";
        }
    }
    class ReferenceTracker {
        constructor() {
            //
            // Relation of refId => Schema structure
            // For direct access of structures during decoding time.
            //
            this.refs = new Map();
            this.refIds = new WeakMap();
            this.refCount = {};
            this.deletedRefs = new Set();
            this.callbacks = {};
            this.nextUniqueId = 0;
        }
        getNextUniqueId() {
            return this.nextUniqueId++;
        }
        // for decoding
        addRef(refId, ref, incrementCount = true) {
            this.refs.set(refId, ref);
            this.refIds.set(ref, refId);
            if (incrementCount) {
                this.refCount[refId] = (this.refCount[refId] || 0) + 1;
            }
            if (this.deletedRefs.has(refId)) {
                this.deletedRefs.delete(refId);
            }
        }
        // for decoding
        removeRef(refId) {
            const refCount = this.refCount[refId];
            if (refCount === undefined) {
                try {
                    throw new DecodingWarning("trying to remove refId that doesn't exist: " + refId);
                }
                catch (e) {
                    console.warn(e);
                }
                return;
            }
            if (refCount === 0) {
                try {
                    const ref = this.refs.get(refId);
                    throw new DecodingWarning(`trying to remove refId '${refId}' with 0 refCount (${ref.constructor.name}: ${JSON.stringify(ref)})`);
                }
                catch (e) {
                    console.warn(e);
                }
                return;
            }
            if ((this.refCount[refId] = refCount - 1) <= 0) {
                this.deletedRefs.add(refId);
            }
        }
        clearRefs() {
            this.refs.clear();
            this.deletedRefs.clear();
            this.callbacks = {};
            this.refCount = {};
        }
        // for decoding
        garbageCollectDeletedRefs() {
            this.deletedRefs.forEach((refId) => {
                //
                // Skip active references.
                //
                if (this.refCount[refId] > 0) {
                    return;
                }
                const ref = this.refs.get(refId);
                //
                // Ensure child schema instances have their references removed as well.
                //
                if (ref.constructor[Symbol.metadata] !== undefined) {
                    const metadata = ref.constructor[Symbol.metadata];
                    for (const index in metadata) {
                        const field = metadata[index].name;
                        const childRefId = typeof (ref[field]) === "object" && this.refIds.get(ref[field]);
                        if (childRefId && !this.deletedRefs.has(childRefId)) {
                            this.removeRef(childRefId);
                        }
                    }
                }
                else {
                    if (typeof (ref[$childType]) === "function") {
                        Array.from(ref.values())
                            .forEach((child) => {
                            const childRefId = this.refIds.get(child);
                            if (!this.deletedRefs.has(childRefId)) {
                                this.removeRef(childRefId);
                            }
                        });
                    }
                }
                this.refs.delete(refId); // remove ref
                delete this.refCount[refId]; // remove ref count
                delete this.callbacks[refId]; // remove callbacks
            });
            // clear deleted refs.
            this.deletedRefs.clear();
        }
        addCallback(refId, fieldOrOperation, callback) {
            if (refId === undefined) {
                const name = (typeof (fieldOrOperation) === "number")
                    ? exports.OPERATION[fieldOrOperation]
                    : fieldOrOperation;
                throw new Error(`Can't addCallback on '${name}' (refId is undefined)`);
            }
            if (!this.callbacks[refId]) {
                this.callbacks[refId] = {};
            }
            if (!this.callbacks[refId][fieldOrOperation]) {
                this.callbacks[refId][fieldOrOperation] = [];
            }
            this.callbacks[refId][fieldOrOperation].push(callback);
            return () => this.removeCallback(refId, fieldOrOperation, callback);
        }
        removeCallback(refId, field, callback) {
            const index = this.callbacks?.[refId]?.[field]?.indexOf(callback);
            if (index !== undefined && index !== -1) {
                spliceOne(this.callbacks[refId][field], index);
            }
        }
    }

    class Decoder {
        constructor(root, context) {
            this.currentRefId = 0;
            this.setState(root);
            this.context = context || new TypeContext(root.constructor);
            // console.log(">>>>>>>>>>>>>>>> Decoder types");
            // this.context.schemas.forEach((id, schema) => {
            //     console.log("type:", id, schema.name, Object.keys(schema[Symbol.metadata]));
            // });
        }
        setState(root) {
            this.state = root;
            this.root = new ReferenceTracker();
            this.root.addRef(0, root);
        }
        decode(bytes, it = { offset: 0 }, ref = this.state) {
            const allChanges = [];
            const $root = this.root;
            const totalBytes = bytes.byteLength;
            let decoder = ref['constructor'][$decoder];
            this.currentRefId = 0;
            while (it.offset < totalBytes) {
                //
                // Peek ahead, check if it's a switch to a different structure
                //
                if (bytes[it.offset] == SWITCH_TO_STRUCTURE) {
                    it.offset++;
                    ref[$onDecodeEnd]?.();
                    const nextRefId = decode.number(bytes, it);
                    const nextRef = $root.refs.get(nextRefId);
                    //
                    // Trying to access a reference that haven't been decoded yet.
                    //
                    if (!nextRef) {
                        // throw new Error(`"refId" not found: ${nextRefId}`);
                        console.error(`"refId" not found: ${nextRefId}`, { previousRef: ref, previousRefId: this.currentRefId });
                        console.warn("Please report this issue to the developers.");
                        this.skipCurrentStructure(bytes, it, totalBytes);
                    }
                    else {
                        ref = nextRef;
                        decoder = ref.constructor[$decoder];
                        this.currentRefId = nextRefId;
                    }
                    continue;
                }
                const result = decoder(this, bytes, it, ref, allChanges);
                if (result === DEFINITION_MISMATCH) {
                    console.warn("@colyseus/schema: definition mismatch");
                    this.skipCurrentStructure(bytes, it, totalBytes);
                    continue;
                }
            }
            // FIXME: DRY with SWITCH_TO_STRUCTURE block.
            ref[$onDecodeEnd]?.();
            // trigger changes
            this.triggerChanges?.(allChanges);
            // drop references of unused schemas
            $root.garbageCollectDeletedRefs();
            return allChanges;
        }
        skipCurrentStructure(bytes, it, totalBytes) {
            //
            // keep skipping next bytes until reaches a known structure
            // by local decoder.
            //
            const nextIterator = { offset: it.offset };
            while (it.offset < totalBytes) {
                if (bytes[it.offset] === SWITCH_TO_STRUCTURE) {
                    nextIterator.offset = it.offset + 1;
                    if (this.root.refs.has(decode.number(bytes, nextIterator))) {
                        break;
                    }
                }
                it.offset++;
            }
        }
        getInstanceType(bytes, it, defaultType) {
            let type;
            if (bytes[it.offset] === TYPE_ID) {
                it.offset++;
                const type_id = decode.number(bytes, it);
                type = this.context.get(type_id);
            }
            return type || defaultType;
        }
        createInstanceOfType(type) {
            return new type();
        }
        removeChildRefs(ref, allChanges) {
            const needRemoveRef = typeof (ref[$childType]) !== "string";
            const refId = this.root.refIds.get(ref);
            ref.forEach((value, key) => {
                allChanges.push({
                    ref: ref,
                    refId,
                    op: exports.OPERATION.DELETE,
                    field: key,
                    value: undefined,
                    previousValue: value
                });
                if (needRemoveRef) {
                    this.root.removeRef(this.root.refIds.get(value));
                }
            });
        }
    }

    /**
     * Reflection
     */
    class ReflectionField extends Schema {
    }
    __decorate([
        type("string")
    ], ReflectionField.prototype, "name", void 0);
    __decorate([
        type("string")
    ], ReflectionField.prototype, "type", void 0);
    __decorate([
        type("number")
    ], ReflectionField.prototype, "referencedType", void 0);
    class ReflectionType extends Schema {
        constructor() {
            super(...arguments);
            this.fields = new ArraySchema();
        }
    }
    __decorate([
        type("number")
    ], ReflectionType.prototype, "id", void 0);
    __decorate([
        type("number")
    ], ReflectionType.prototype, "extendsId", void 0);
    __decorate([
        type([ReflectionField])
    ], ReflectionType.prototype, "fields", void 0);
    class Reflection extends Schema {
        constructor() {
            super(...arguments);
            this.types = new ArraySchema();
        }
        /**
         * Encodes the TypeContext of an Encoder into a buffer.
         *
         * @param encoder Encoder instance
         * @param it
         * @returns
         */
        static encode(encoder, it = { offset: 0 }) {
            const context = encoder.context;
            const reflection = new Reflection();
            const reflectionEncoder = new Encoder(reflection);
            // rootType is usually the first schema passed to the Encoder
            // (unless it inherits from another schema)
            const rootType = context.schemas.get(encoder.state.constructor);
            if (rootType > 0) {
                reflection.rootType = rootType;
            }
            const includedTypeIds = new Set();
            const pendingReflectionTypes = {};
            // add type to reflection in a way that respects inheritance
            // (parent types should be added before their children)
            const addType = (type) => {
                if (type.extendsId === undefined || includedTypeIds.has(type.extendsId)) {
                    includedTypeIds.add(type.id);
                    reflection.types.push(type);
                    const deps = pendingReflectionTypes[type.id];
                    if (deps !== undefined) {
                        delete pendingReflectionTypes[type.id];
                        deps.forEach((childType) => addType(childType));
                    }
                }
                else {
                    if (pendingReflectionTypes[type.extendsId] === undefined) {
                        pendingReflectionTypes[type.extendsId] = [];
                    }
                    pendingReflectionTypes[type.extendsId].push(type);
                }
            };
            context.schemas.forEach((typeid, klass) => {
                const type = new ReflectionType();
                type.id = Number(typeid);
                // support inheritance
                const inheritFrom = Object.getPrototypeOf(klass);
                if (inheritFrom !== Schema) {
                    type.extendsId = context.schemas.get(inheritFrom);
                }
                const metadata = klass[Symbol.metadata];
                //
                // FIXME: this is a workaround for inherited types without additional fields
                // if metadata is the same reference as the parent class - it means the class has no own metadata
                //
                if (metadata !== inheritFrom[Symbol.metadata]) {
                    for (const fieldIndex in metadata) {
                        const index = Number(fieldIndex);
                        const fieldName = metadata[index].name;
                        // skip fields from parent classes
                        if (!Object.prototype.hasOwnProperty.call(metadata, fieldName)) {
                            continue;
                        }
                        const reflectionField = new ReflectionField();
                        reflectionField.name = fieldName;
                        let fieldType;
                        const field = metadata[index];
                        if (typeof (field.type) === "string") {
                            fieldType = field.type;
                        }
                        else {
                            let childTypeSchema;
                            //
                            // TODO: refactor below.
                            //
                            if (Schema.is(field.type)) {
                                fieldType = "ref";
                                childTypeSchema = field.type;
                            }
                            else {
                                fieldType = Object.keys(field.type)[0];
                                if (typeof (field.type[fieldType]) === "string") {
                                    fieldType += ":" + field.type[fieldType]; // array:string
                                }
                                else {
                                    childTypeSchema = field.type[fieldType];
                                }
                            }
                            reflectionField.referencedType = (childTypeSchema)
                                ? context.getTypeId(childTypeSchema)
                                : -1;
                        }
                        reflectionField.type = fieldType;
                        type.fields.push(reflectionField);
                    }
                }
                addType(type);
            });
            // in case there are types that were not added due to inheritance
            for (const typeid in pendingReflectionTypes) {
                pendingReflectionTypes[typeid].forEach((type) => reflection.types.push(type));
            }
            const buf = reflectionEncoder.encodeAll(it);
            return buf.slice(0, it.offset);
            // return Buffer.from(buf, 0, it.offset);
        }
        /**
         * Decodes the TypeContext from a buffer into a Decoder instance.
         *
         * @param bytes Reflection.encode() output
         * @param it
         * @returns Decoder instance
         */
        static decode(bytes, it) {
            const reflection = new Reflection();
            const reflectionDecoder = new Decoder(reflection);
            reflectionDecoder.decode(bytes, it);
            const typeContext = new TypeContext();
            // 1st pass, initialize metadata + inheritance
            reflection.types.forEach((reflectionType) => {
                const parentClass = typeContext.get(reflectionType.extendsId) ?? Schema;
                const schema = class _ extends parentClass {
                };
                // register for inheritance support
                TypeContext.register(schema);
                // // for inheritance support
                // Metadata.initialize(schema);
                typeContext.add(schema, reflectionType.id);
            }, {});
            // define fields
            const addFields = (metadata, reflectionType, parentFieldIndex) => {
                reflectionType.fields.forEach((field, i) => {
                    const fieldIndex = parentFieldIndex + i;
                    if (field.referencedType !== undefined) {
                        let fieldType = field.type;
                        let refType = typeContext.get(field.referencedType);
                        // map or array of primitive type (-1)
                        if (!refType) {
                            const typeInfo = field.type.split(":");
                            fieldType = typeInfo[0];
                            refType = typeInfo[1]; // string
                        }
                        if (fieldType === "ref") {
                            Metadata.addField(metadata, fieldIndex, field.name, refType);
                        }
                        else {
                            Metadata.addField(metadata, fieldIndex, field.name, { [fieldType]: refType });
                        }
                    }
                    else {
                        Metadata.addField(metadata, fieldIndex, field.name, field.type);
                    }
                });
            };
            // 2nd pass, set fields
            reflection.types.forEach((reflectionType) => {
                const schema = typeContext.get(reflectionType.id);
                // for inheritance support
                const metadata = Metadata.initialize(schema);
                const inheritedTypes = [];
                let parentType = reflectionType;
                do {
                    inheritedTypes.push(parentType);
                    parentType = reflection.types.find((t) => t.id === parentType.extendsId);
                } while (parentType);
                let parentFieldIndex = 0;
                inheritedTypes.reverse().forEach((reflectionType) => {
                    // add fields from all inherited classes
                    // TODO: refactor this to avoid adding fields from parent classes
                    addFields(metadata, reflectionType, parentFieldIndex);
                    parentFieldIndex += reflectionType.fields.length;
                });
            });
            const state = new (typeContext.get(reflection.rootType || 0))();
            return new Decoder(state, typeContext);
        }
    }
    __decorate([
        type([ReflectionType])
    ], Reflection.prototype, "types", void 0);
    __decorate([
        type("number")
    ], Reflection.prototype, "rootType", void 0);

    function getDecoderStateCallbacks(decoder) {
        const $root = decoder.root;
        const callbacks = $root.callbacks;
        const onAddCalls = new WeakMap();
        let currentOnAddCallback;
        decoder.triggerChanges = function (allChanges) {
            const uniqueRefIds = new Set();
            for (let i = 0, l = allChanges.length; i < l; i++) {
                const change = allChanges[i];
                const refId = change.refId;
                const ref = change.ref;
                const $callbacks = callbacks[refId];
                if (!$callbacks) {
                    continue;
                }
                //
                // trigger onRemove on child structure.
                //
                if ((change.op & exports.OPERATION.DELETE) === exports.OPERATION.DELETE &&
                    change.previousValue instanceof Schema) {
                    const deleteCallbacks = callbacks[$root.refIds.get(change.previousValue)]?.[exports.OPERATION.DELETE];
                    for (let i = deleteCallbacks?.length - 1; i >= 0; i--) {
                        deleteCallbacks[i]();
                    }
                }
                if (ref instanceof Schema) {
                    //
                    // Handle schema instance
                    //
                    if (!uniqueRefIds.has(refId)) {
                        // trigger onChange
                        const replaceCallbacks = $callbacks?.[exports.OPERATION.REPLACE];
                        for (let i = replaceCallbacks?.length - 1; i >= 0; i--) {
                            replaceCallbacks[i]();
                            // try {
                            // } catch (e) {
                            //     console.error(e);
                            // }
                        }
                    }
                    if ($callbacks.hasOwnProperty(change.field)) {
                        const fieldCallbacks = $callbacks[change.field];
                        for (let i = fieldCallbacks?.length - 1; i >= 0; i--) {
                            fieldCallbacks[i](change.value, change.previousValue);
                            // try {
                            // } catch (e) {
                            //     console.error(e);
                            // }
                        }
                    }
                }
                else {
                    //
                    // Handle collection of items
                    //
                    if ((change.op & exports.OPERATION.DELETE) === exports.OPERATION.DELETE) {
                        //
                        // FIXME: `previousValue` should always be available.
                        //
                        if (change.previousValue !== undefined) {
                            // triger onRemove
                            const deleteCallbacks = $callbacks[exports.OPERATION.DELETE];
                            for (let i = deleteCallbacks?.length - 1; i >= 0; i--) {
                                deleteCallbacks[i](change.previousValue, change.dynamicIndex ?? change.field);
                            }
                        }
                        // Handle DELETE_AND_ADD operations
                        if ((change.op & exports.OPERATION.ADD) === exports.OPERATION.ADD) {
                            const addCallbacks = $callbacks[exports.OPERATION.ADD];
                            for (let i = addCallbacks?.length - 1; i >= 0; i--) {
                                addCallbacks[i](change.value, change.dynamicIndex ?? change.field);
                            }
                        }
                    }
                    else if ((change.op & exports.OPERATION.ADD) === exports.OPERATION.ADD &&
                        change.previousValue !== change.value) {
                        // triger onAdd
                        const addCallbacks = $callbacks[exports.OPERATION.ADD];
                        for (let i = addCallbacks?.length - 1; i >= 0; i--) {
                            addCallbacks[i](change.value, change.dynamicIndex ?? change.field);
                        }
                    }
                    // trigger onChange
                    if (change.value !== change.previousValue &&
                        // FIXME: see "should not encode item if added and removed at the same patch" test case.
                        // some "ADD" + "DELETE" operations on same patch are being encoded as "DELETE"
                        (change.value !== undefined || change.previousValue !== undefined)) {
                        const replaceCallbacks = $callbacks[exports.OPERATION.REPLACE];
                        for (let i = replaceCallbacks?.length - 1; i >= 0; i--) {
                            replaceCallbacks[i](change.value, change.dynamicIndex ?? change.field);
                        }
                    }
                }
                uniqueRefIds.add(refId);
            }
        };
        function getProxy(metadataOrType, context) {
            let metadata = context.instance?.constructor[Symbol.metadata] || metadataOrType;
            let isCollection = ((context.instance && typeof (context.instance['forEach']) === "function") ||
                (metadataOrType && typeof (metadataOrType[Symbol.metadata]) === "undefined"));
            if (metadata && !isCollection) {
                const onAddListen = function (ref, prop, callback, immediate) {
                    // immediate trigger
                    if (immediate &&
                        context.instance[prop] !== undefined &&
                        !onAddCalls.has(currentOnAddCallback) // Workaround for https://github.com/colyseus/schema/issues/147
                    ) {
                        callback(context.instance[prop], undefined);
                    }
                    return $root.addCallback($root.refIds.get(ref), prop, callback);
                };
                /**
                 * Schema instances
                 */
                return new Proxy({
                    listen: function listen(prop, callback, immediate = true) {
                        if (context.instance) {
                            return onAddListen(context.instance, prop, callback, immediate);
                        }
                        else {
                            // collection instance not received yet
                            let detachCallback = () => { };
                            context.onInstanceAvailable((ref, existing) => {
                                detachCallback = onAddListen(ref, prop, callback, immediate && existing && !onAddCalls.has(currentOnAddCallback));
                            });
                            return () => detachCallback();
                        }
                    },
                    onChange: function onChange(callback) {
                        return $root.addCallback($root.refIds.get(context.instance), exports.OPERATION.REPLACE, callback);
                    },
                    //
                    // TODO: refactor `bindTo()` implementation.
                    // There is room for improvement.
                    //
                    bindTo: function bindTo(targetObject, properties) {
                        if (!properties) {
                            properties = Object.keys(metadata).map((index) => metadata[index].name);
                        }
                        return $root.addCallback($root.refIds.get(context.instance), exports.OPERATION.REPLACE, () => {
                            properties.forEach((prop) => targetObject[prop] = context.instance[prop]);
                        });
                    }
                }, {
                    get(target, prop) {
                        const metadataField = metadata[metadata[prop]];
                        if (metadataField) {
                            const instance = context.instance?.[prop];
                            const onInstanceAvailable = ((callback) => {
                                const unbind = $(context.instance).listen(prop, (value, _) => {
                                    callback(value, false);
                                    // FIXME: by "unbinding" the callback here,
                                    // it will not support when the server
                                    // re-instantiates the instance.
                                    //
                                    unbind?.();
                                }, false);
                                // has existing value
                                if ($root.refIds.get(instance) !== undefined) {
                                    callback(instance, true);
                                }
                            });
                            return getProxy(metadataField.type, {
                                // make sure refId is available, otherwise need to wait for the instance to be available.
                                instance: ($root.refIds.get(instance) && instance),
                                parentInstance: context.instance,
                                onInstanceAvailable,
                            });
                        }
                        else {
                            // accessing the function
                            return target[prop];
                        }
                    },
                    has(target, prop) { return metadata[prop] !== undefined; },
                    set(_, _1, _2) { throw new Error("not allowed"); },
                    deleteProperty(_, _1) { throw new Error("not allowed"); },
                });
            }
            else {
                /**
                 * Collection instances
                 */
                const onAdd = function (ref, callback, immediate) {
                    // Trigger callback on existing items
                    if (immediate) {
                        ref.forEach((v, k) => callback(v, k));
                    }
                    return $root.addCallback($root.refIds.get(ref), exports.OPERATION.ADD, (value, key) => {
                        onAddCalls.set(callback, true);
                        currentOnAddCallback = callback;
                        callback(value, key);
                        onAddCalls.delete(callback);
                        currentOnAddCallback = undefined;
                    });
                };
                const onRemove = function (ref, callback) {
                    return $root.addCallback($root.refIds.get(ref), exports.OPERATION.DELETE, callback);
                };
                const onChange = function (ref, callback) {
                    return $root.addCallback($root.refIds.get(ref), exports.OPERATION.REPLACE, callback);
                };
                return new Proxy({
                    onAdd: function (callback, immediate = true) {
                        //
                        // https://github.com/colyseus/schema/issues/147
                        // If parent instance has "onAdd" registered, avoid triggering immediate callback.
                        //
                        if (context.instance) {
                            return onAdd(context.instance, callback, immediate && !onAddCalls.has(currentOnAddCallback));
                        }
                        else if (context.onInstanceAvailable) {
                            // collection instance not received yet
                            let detachCallback = () => { };
                            context.onInstanceAvailable((ref, existing) => {
                                detachCallback = onAdd(ref, callback, immediate && existing && !onAddCalls.has(currentOnAddCallback));
                            });
                            return () => detachCallback();
                        }
                    },
                    onRemove: function (callback) {
                        if (context.instance) {
                            return onRemove(context.instance, callback);
                        }
                        else if (context.onInstanceAvailable) {
                            // collection instance not received yet
                            let detachCallback = () => { };
                            context.onInstanceAvailable((ref) => {
                                detachCallback = onRemove(ref, callback);
                            });
                            return () => detachCallback();
                        }
                    },
                    onChange: function (callback) {
                        if (context.instance) {
                            return onChange(context.instance, callback);
                        }
                        else if (context.onInstanceAvailable) {
                            // collection instance not received yet
                            let detachCallback = () => { };
                            context.onInstanceAvailable((ref) => {
                                detachCallback = onChange(ref, callback);
                            });
                            return () => detachCallback();
                        }
                    },
                }, {
                    get(target, prop) {
                        if (!target[prop]) {
                            throw new Error(`Can't access '${prop}' through callback proxy. access the instance directly.`);
                        }
                        return target[prop];
                    },
                    has(target, prop) { return target[prop] !== undefined; },
                    set(_, _1, _2) { throw new Error("not allowed"); },
                    deleteProperty(_, _1) { throw new Error("not allowed"); },
                });
            }
        }
        function $(instance) {
            return getProxy(undefined, { instance });
        }
        return $;
    }

    function getRawChangesCallback(decoder, callback) {
        decoder.triggerChanges = callback;
    }

    class StateView {
        constructor(iterable = false) {
            this.iterable = iterable;
            /**
             * List of ChangeTree's that are visible to this view
             */
            this.visible = new WeakSet();
            /**
             * List of ChangeTree's that are invisible to this view
             */
            this.invisible = new WeakSet();
            /**
             * Manual "ADD" operations for changes per ChangeTree, specific to this view.
             * (This is used to force encoding a property, even if it was not changed)
             */
            this.changes = new Map();
            if (iterable) {
                this.items = [];
            }
        }
        // TODO: allow to set multiple tags at once
        add(obj, tag = DEFAULT_VIEW_TAG, checkIncludeParent = true) {
            const changeTree = obj?.[$changes];
            const parentChangeTree = changeTree.parent;
            if (!changeTree) {
                console.warn("StateView#add(), invalid object:", obj);
                return false;
            }
            else if (!parentChangeTree &&
                changeTree.refId !== 0 // allow root object
            ) {
                /**
                 * TODO: can we avoid this?
                 *
                 * When the "parent" structure has the @view() tag, it is currently
                 * not possible to identify it has to be added to the view as well
                 * (this.addParentOf() is not called).
                 */
                throw new Error(`Cannot add a detached instance to the StateView. Make sure to assign the "${changeTree.ref.constructor.name}" instance to the state before calling view.add()`);
            }
            // FIXME: ArraySchema/MapSchema do not have metadata
            const metadata = obj.constructor[Symbol.metadata];
            this.visible.add(changeTree);
            // add to iterable list (only the explicitly added items)
            if (this.iterable && checkIncludeParent) {
                this.items.push(obj);
            }
            // add parent ChangeTree's
            // - if it was invisible to this view
            // - if it were previously filtered out
            if (checkIncludeParent && parentChangeTree) {
                this.addParentOf(changeTree, tag);
            }
            let changes = this.changes.get(changeTree.refId);
            if (changes === undefined) {
                changes = {};
                // FIXME / OPTIMIZE: do not add if no changes are needed
                this.changes.set(changeTree.refId, changes);
            }
            let isChildAdded = false;
            //
            // Add children of this ChangeTree first.
            // If successful, we must link the current ChangeTree to the child.
            //
            changeTree.forEachChild((change, index) => {
                // Do not ADD children that don't have the same tag
                if (metadata &&
                    metadata[index].tag !== undefined &&
                    metadata[index].tag !== tag) {
                    return;
                }
                if (this.add(change.ref, tag, false)) {
                    isChildAdded = true;
                }
            });
            // set tag
            if (tag !== DEFAULT_VIEW_TAG) {
                if (!this.tags) {
                    this.tags = new WeakMap();
                }
                let tags;
                if (!this.tags.has(changeTree)) {
                    tags = new Set();
                    this.tags.set(changeTree, tags);
                }
                else {
                    tags = this.tags.get(changeTree);
                }
                tags.add(tag);
                // Ref: add tagged properties
                metadata?.[$fieldIndexesByViewTag]?.[tag]?.forEach((index) => {
                    if (changeTree.getChange(index) !== exports.OPERATION.DELETE) {
                        changes[index] = exports.OPERATION.ADD;
                    }
                });
            }
            else if (!changeTree.isNew || isChildAdded) {
                // new structures will be added as part of .encode() call, no need to force it to .encodeView()
                const changeSet = (changeTree.filteredChanges !== undefined)
                    ? changeTree.allFilteredChanges
                    : changeTree.allChanges;
                const isInvisible = this.invisible.has(changeTree);
                for (let i = 0, len = changeSet.operations.length; i < len; i++) {
                    const index = changeSet.operations[i];
                    if (index === undefined) {
                        continue;
                    } // skip "undefined" indexes
                    const op = changeTree.indexedOperations[index] ?? exports.OPERATION.ADD;
                    const tagAtIndex = metadata?.[index].tag;
                    if (op !== exports.OPERATION.DELETE &&
                        (isInvisible || // if "invisible", include all
                            tagAtIndex === undefined || // "all change" with no tag
                            tagAtIndex === tag // tagged property
                        )) {
                        changes[index] = op;
                        isChildAdded = true; // FIXME: assign only once
                    }
                }
            }
            return isChildAdded;
        }
        addParentOf(childChangeTree, tag) {
            const changeTree = childChangeTree.parent[$changes];
            const parentIndex = childChangeTree.parentIndex;
            if (!this.visible.has(changeTree)) {
                // view must have all "changeTree" parent tree
                this.visible.add(changeTree);
                // add parent's parent
                const parentChangeTree = changeTree.parent?.[$changes];
                if (parentChangeTree && (parentChangeTree.filteredChanges !== undefined)) {
                    this.addParentOf(changeTree, tag);
                }
                // // parent is already available, no need to add it!
                // if (!this.invisible.has(changeTree)) { return; }
            }
            // add parent's tag properties
            if (changeTree.getChange(parentIndex) !== exports.OPERATION.DELETE) {
                let changes = this.changes.get(changeTree.refId);
                if (changes === undefined) {
                    changes = {};
                    this.changes.set(changeTree.refId, changes);
                }
                if (!this.tags) {
                    this.tags = new WeakMap();
                }
                let tags;
                if (!this.tags.has(changeTree)) {
                    tags = new Set();
                    this.tags.set(changeTree, tags);
                }
                else {
                    tags = this.tags.get(changeTree);
                }
                tags.add(tag);
                changes[parentIndex] = exports.OPERATION.ADD;
            }
        }
        remove(obj, tag = DEFAULT_VIEW_TAG, _isClear = false) {
            const changeTree = obj[$changes];
            if (!changeTree) {
                console.warn("StateView#remove(), invalid object:", obj);
                return this;
            }
            this.visible.delete(changeTree);
            // remove from iterable list
            if (this.iterable &&
                !_isClear // no need to remove during clear(), as it will be cleared entirely
            ) {
                spliceOne(this.items, this.items.indexOf(obj));
            }
            const ref = changeTree.ref;
            const metadata = ref.constructor[Symbol.metadata]; // ArraySchema/MapSchema do not have metadata
            let changes = this.changes.get(changeTree.refId);
            if (changes === undefined) {
                changes = {};
                this.changes.set(changeTree.refId, changes);
            }
            if (tag === DEFAULT_VIEW_TAG) {
                // parent is collection (Map/Array)
                const parent = changeTree.parent;
                if (parent && !Metadata.isValidInstance(parent) && changeTree.isFiltered) {
                    const parentChangeTree = parent[$changes];
                    let changes = this.changes.get(parentChangeTree.refId);
                    if (changes === undefined) {
                        changes = {};
                        this.changes.set(parentChangeTree.refId, changes);
                    }
                    else if (changes[changeTree.parentIndex] === exports.OPERATION.ADD) {
                        //
                        // SAME PATCH ADD + REMOVE:
                        // The 'changes' of deleted structure should be ignored.
                        //
                        this.changes.delete(changeTree.refId);
                    }
                    // DELETE / DELETE BY REF ID
                    changes[changeTree.parentIndex] = exports.OPERATION.DELETE;
                    // Remove child schema from visible set
                    this._recursiveDeleteVisibleChangeTree(changeTree);
                }
                else {
                    // delete all "tagged" properties.
                    metadata?.[$viewFieldIndexes]?.forEach((index) => changes[index] = exports.OPERATION.DELETE);
                }
            }
            else {
                // delete only tagged properties
                metadata?.[$fieldIndexesByViewTag][tag].forEach((index) => changes[index] = exports.OPERATION.DELETE);
            }
            // remove tag
            if (this.tags && this.tags.has(changeTree)) {
                const tags = this.tags.get(changeTree);
                if (tag === undefined) {
                    // delete all tags
                    this.tags.delete(changeTree);
                }
                else {
                    // delete specific tag
                    tags.delete(tag);
                    // if tag set is empty, delete it entirely
                    if (tags.size === 0) {
                        this.tags.delete(changeTree);
                    }
                }
            }
            return this;
        }
        has(obj) {
            return this.visible.has(obj[$changes]);
        }
        hasTag(ob, tag = DEFAULT_VIEW_TAG) {
            const tags = this.tags?.get(ob[$changes]);
            return tags?.has(tag) ?? false;
        }
        clear() {
            if (!this.iterable) {
                throw new Error("StateView#clear() is only available for iterable StateView's. Use StateView(iterable: true) constructor.");
            }
            for (let i = 0, l = this.items.length; i < l; i++) {
                this.remove(this.items[i], DEFAULT_VIEW_TAG, true);
            }
            // clear items array
            this.items.length = 0;
        }
        isChangeTreeVisible(changeTree) {
            let isVisible = this.visible.has(changeTree);
            //
            // TODO: avoid checking for parent visibility, most of the time it's not needed
            // See test case: 'should not be required to manually call view.add() items to child arrays without @view() tag'
            //
            if (!isVisible && changeTree.isVisibilitySharedWithParent) {
                // console.log("CHECK AGAINST PARENT...", {
                //     ref: changeTree.ref.constructor.name,
                //     refId: changeTree.refId,
                //     parent: changeTree.parent.constructor.name,
                // });
                if (this.visible.has(changeTree.parent[$changes])) {
                    this.visible.add(changeTree);
                    isVisible = true;
                }
            }
            return isVisible;
        }
        _recursiveDeleteVisibleChangeTree(changeTree) {
            changeTree.forEachChild((childChangeTree) => {
                this.visible.delete(childChangeTree);
                this._recursiveDeleteVisibleChangeTree(childChangeTree);
            });
        }
    }

    registerType("map", { constructor: MapSchema });
    registerType("array", { constructor: ArraySchema });
    registerType("set", { constructor: SetSchema });
    registerType("collection", { constructor: CollectionSchema, });

    exports.$changes = $changes;
    exports.$childType = $childType;
    exports.$decoder = $decoder;
    exports.$deleteByIndex = $deleteByIndex;
    exports.$encoder = $encoder;
    exports.$filter = $filter;
    exports.$getByIndex = $getByIndex;
    exports.$track = $track;
    exports.ArraySchema = ArraySchema;
    exports.ChangeTree = ChangeTree;
    exports.CollectionSchema = CollectionSchema;
    exports.Decoder = Decoder;
    exports.Encoder = Encoder;
    exports.MapSchema = MapSchema;
    exports.Metadata = Metadata;
    exports.Reflection = Reflection;
    exports.ReflectionField = ReflectionField;
    exports.ReflectionType = ReflectionType;
    exports.Schema = Schema;
    exports.SetSchema = SetSchema;
    exports.StateView = StateView;
    exports.TypeContext = TypeContext;
    exports.decode = decode;
    exports.decodeKeyValueOperation = decodeKeyValueOperation;
    exports.decodeSchemaOperation = decodeSchemaOperation;
    exports.defineCustomTypes = defineCustomTypes;
    exports.defineTypes = defineTypes;
    exports.deprecated = deprecated;
    exports.dumpChanges = dumpChanges;
    exports.encode = encode;
    exports.encodeArray = encodeArray;
    exports.encodeKeyValueOperation = encodeKeyValueOperation;
    exports.encodeSchemaOperation = encodeSchemaOperation;
    exports.entity = entity;
    exports.getDecoderStateCallbacks = getDecoderStateCallbacks;
    exports.getRawChangesCallback = getRawChangesCallback;
    exports.registerType = registerType;
    exports.schema = schema;
    exports.type = type;
    exports.view = view;

}));


},
"./node_modules/assert/build/assert.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";
/* provided dependency */ var process = __webpack_require__("./node_modules/process/browser.js");
/* provided dependency */ var console = __webpack_require__("./node_modules/console-browserify/index.js");
// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b

// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
var _require = __webpack_require__("./node_modules/assert/build/internal/errors.js"),
  _require$codes = _require.codes,
  ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE,
  ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE,
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
var AssertionError = __webpack_require__("./node_modules/assert/build/internal/assert/assertion_error.js");
var _require2 = __webpack_require__("./node_modules/util/util.js"),
  inspect = _require2.inspect;
var _require$types = (__webpack_require__("./node_modules/util/util.js")/* .types */.types),
  isPromise = _require$types.isPromise,
  isRegExp = _require$types.isRegExp;
var objectAssign = __webpack_require__("./node_modules/object.assign/polyfill.js")();
var objectIs = __webpack_require__("./node_modules/object-is/polyfill.js")();
var RegExpPrototypeTest = __webpack_require__("./node_modules/call-bind/callBound.js")('RegExp.prototype.test');
var errorCache = new Map();
var isDeepEqual;
var isDeepStrictEqual;
var parseExpressionAt;
var findNodeAround;
var decoder;
function lazyLoadComparison() {
  var comparison = __webpack_require__("./node_modules/assert/build/internal/util/comparisons.js");
  isDeepEqual = comparison.isDeepEqual;
  isDeepStrictEqual = comparison.isDeepStrictEqual;
}

// Escape control characters but not \n and \t to keep the line breaks and
// indentation intact.
// eslint-disable-next-line no-control-regex
var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
var meta = ["\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007", '\\b', '', '', "\\u000b", '\\f', '', "\\u000e", "\\u000f", "\\u0010", "\\u0011", "\\u0012", "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001a", "\\u001b", "\\u001c", "\\u001d", "\\u001e", "\\u001f"];
var escapeFn = function escapeFn(str) {
  return meta[str.charCodeAt(0)];
};
var warned = false;

// The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;
var NO_EXCEPTION_SENTINEL = {};

// All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided. All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function innerFail(obj) {
  if (obj.message instanceof Error) throw obj.message;
  throw new AssertionError(obj);
}
function fail(actual, expected, message, operator, stackStartFn) {
  var argsLen = arguments.length;
  var internalMessage;
  if (argsLen === 0) {
    internalMessage = 'Failed';
  } else if (argsLen === 1) {
    message = actual;
    actual = undefined;
  } else {
    if (warned === false) {
      warned = true;
      var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
      warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
    }
    if (argsLen === 2) operator = '!=';
  }
  if (message instanceof Error) throw message;
  var errArgs = {
    actual: actual,
    expected: expected,
    operator: operator === undefined ? 'fail' : operator,
    stackStartFn: stackStartFn || fail
  };
  if (message !== undefined) {
    errArgs.message = message;
  }
  var err = new AssertionError(errArgs);
  if (internalMessage) {
    err.message = internalMessage;
    err.generatedMessage = true;
  }
  throw err;
}
assert.fail = fail;

// The AssertionError is defined in internal/error.
assert.AssertionError = AssertionError;
function innerOk(fn, argLen, value, message) {
  if (!value) {
    var generatedMessage = false;
    if (argLen === 0) {
      generatedMessage = true;
      message = 'No value argument passed to `assert.ok()`';
    } else if (message instanceof Error) {
      throw message;
    }
    var err = new AssertionError({
      actual: value,
      expected: true,
      message: message,
      operator: '==',
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
}

// Pure assertion tests whether a value is truthy, as determined
// by !!value.
function ok() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  innerOk.apply(void 0, [ok, args.length].concat(args));
}
assert.ok = ok;

// The equality assertion tests shallow, coercive equality with ==.
/* eslint-disable no-restricted-properties */
assert.equal = function equal(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  // eslint-disable-next-line eqeqeq
  if (actual != expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '==',
      stackStartFn: equal
    });
  }
};

// The non-equality assertion tests for whether two objects are not
// equal with !=.
assert.notEqual = function notEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  // eslint-disable-next-line eqeqeq
  if (actual == expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '!=',
      stackStartFn: notEqual
    });
  }
};

// The equivalence assertion tests a deep equality relation.
assert.deepEqual = function deepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (!isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepEqual',
      stackStartFn: deepEqual
    });
  }
};

// The non-equivalence assertion tests for any deep inequality.
assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepEqual',
      stackStartFn: notDeepEqual
    });
  }
};
/* eslint-enable */

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (!isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepStrictEqual',
      stackStartFn: deepStrictEqual
    });
  }
};
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepStrictEqual',
      stackStartFn: notDeepStrictEqual
    });
  }
}
assert.strictEqual = function strictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (!objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'strictEqual',
      stackStartFn: strictEqual
    });
  }
};
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notStrictEqual',
      stackStartFn: notStrictEqual
    });
  }
};
var Comparison = /*#__PURE__*/_createClass(function Comparison(obj, keys, actual) {
  var _this = this;
  _classCallCheck(this, Comparison);
  keys.forEach(function (key) {
    if (key in obj) {
      if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && RegExpPrototypeTest(obj[key], actual[key])) {
        _this[key] = actual[key];
      } else {
        _this[key] = obj[key];
      }
    }
  });
});
function compareExceptionKey(actual, expected, key, message, keys, fn) {
  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
    if (!message) {
      // Create placeholder objects to create a nice output.
      var a = new Comparison(actual, keys);
      var b = new Comparison(expected, keys, actual);
      var err = new AssertionError({
        actual: a,
        expected: b,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.actual = actual;
      err.expected = expected;
      err.operator = fn.name;
      throw err;
    }
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: fn.name,
      stackStartFn: fn
    });
  }
}
function expectedException(actual, expected, msg, fn) {
  if (typeof expected !== 'function') {
    if (isRegExp(expected)) return RegExpPrototypeTest(expected, actual);
    // assert.doesNotThrow does not accept objects.
    if (arguments.length === 2) {
      throw new ERR_INVALID_ARG_TYPE('expected', ['Function', 'RegExp'], expected);
    }

    // Handle primitives properly.
    if (_typeof(actual) !== 'object' || actual === null) {
      var err = new AssertionError({
        actual: actual,
        expected: expected,
        message: msg,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.operator = fn.name;
      throw err;
    }
    var keys = Object.keys(expected);
    // Special handle errors to make sure the name and the message are compared
    // as well.
    if (expected instanceof Error) {
      keys.push('name', 'message');
    } else if (keys.length === 0) {
      throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
    }
    if (isDeepEqual === undefined) lazyLoadComparison();
    keys.forEach(function (key) {
      if (typeof actual[key] === 'string' && isRegExp(expected[key]) && RegExpPrototypeTest(expected[key], actual[key])) {
        return;
      }
      compareExceptionKey(actual, expected, key, msg, keys, fn);
    });
    return true;
  }
  // Guard instanceof against arrow functions as they don't have a prototype.
  if (expected.prototype !== undefined && actual instanceof expected) {
    return true;
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function getActual(fn) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
  }
  try {
    fn();
  } catch (e) {
    return e;
  }
  return NO_EXCEPTION_SENTINEL;
}
function checkIsPromise(obj) {
  // Accept native ES6 promises and promises that are implemented in a similar
  // way. Do not accept thenables that use a function as `obj` and that have no
  // `catch` handler.

  // TODO: thenables are checked up until they have the correct methods,
  // but according to documentation, the `then` method should receive
  // the `fulfill` and `reject` arguments as well or it may be never resolved.

  return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
}
function waitForActual(promiseFn) {
  return Promise.resolve().then(function () {
    var resultPromise;
    if (typeof promiseFn === 'function') {
      // Return a rejected promise if `promiseFn` throws synchronously.
      resultPromise = promiseFn();
      // Fail in case no promise is returned.
      if (!checkIsPromise(resultPromise)) {
        throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
      }
    } else if (checkIsPromise(promiseFn)) {
      resultPromise = promiseFn;
    } else {
      throw new ERR_INVALID_ARG_TYPE('promiseFn', ['Function', 'Promise'], promiseFn);
    }
    return Promise.resolve().then(function () {
      return resultPromise;
    }).then(function () {
      return NO_EXCEPTION_SENTINEL;
    }).catch(function (e) {
      return e;
    });
  });
}
function expectsError(stackStartFn, actual, error, message) {
  if (typeof error === 'string') {
    if (arguments.length === 4) {
      throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
    }
    if (_typeof(actual) === 'object' && actual !== null) {
      if (actual.message === error) {
        throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
      }
    } else if (actual === error) {
      throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
    }
    message = error;
    error = undefined;
  } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
  }
  if (actual === NO_EXCEPTION_SENTINEL) {
    var details = '';
    if (error && error.name) {
      details += " (".concat(error.name, ")");
    }
    details += message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
    innerFail({
      actual: undefined,
      expected: error,
      operator: stackStartFn.name,
      message: "Missing expected ".concat(fnType).concat(details),
      stackStartFn: stackStartFn
    });
  }
  if (error && !expectedException(actual, error, message, stackStartFn)) {
    throw actual;
  }
}
function expectsNoError(stackStartFn, actual, error, message) {
  if (actual === NO_EXCEPTION_SENTINEL) return;
  if (typeof error === 'string') {
    message = error;
    error = undefined;
  }
  if (!error || expectedException(actual, error)) {
    var details = message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
    innerFail({
      actual: actual,
      expected: error,
      operator: stackStartFn.name,
      message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
      stackStartFn: stackStartFn
    });
  }
  throw actual;
}
assert.throws = function throws(promiseFn) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
};
assert.rejects = function rejects(promiseFn) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }
  return waitForActual(promiseFn).then(function (result) {
    return expectsError.apply(void 0, [rejects, result].concat(args));
  });
};
assert.doesNotThrow = function doesNotThrow(fn) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }
  expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
};
assert.doesNotReject = function doesNotReject(fn) {
  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }
  return waitForActual(fn).then(function (result) {
    return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
  });
};
assert.ifError = function ifError(err) {
  if (err !== null && err !== undefined) {
    var message = 'ifError got unwanted exception: ';
    if (_typeof(err) === 'object' && typeof err.message === 'string') {
      if (err.message.length === 0 && err.constructor) {
        message += err.constructor.name;
      } else {
        message += err.message;
      }
    } else {
      message += inspect(err);
    }
    var newErr = new AssertionError({
      actual: err,
      expected: null,
      operator: 'ifError',
      message: message,
      stackStartFn: ifError
    });

    // Make sure we actually have a stack trace!
    var origStack = err.stack;
    if (typeof origStack === 'string') {
      // This will remove any duplicated frames from the error frames taken
      // from within `ifError` and add the original error frames to the newly
      // created ones.
      var tmp2 = origStack.split('\n');
      tmp2.shift();
      // Filter all frames existing in err.stack.
      var tmp1 = newErr.stack.split('\n');
      for (var i = 0; i < tmp2.length; i++) {
        // Find the first occurrence of the frame.
        var pos = tmp1.indexOf(tmp2[i]);
        if (pos !== -1) {
          // Only keep new frames.
          tmp1 = tmp1.slice(0, pos);
          break;
        }
      }
      newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
    }
    throw newErr;
  }
};

// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a871df3dfb8ea663ef5e1f8f62701ec51384ecb
function internalMatch(string, regexp, message, fn, fnName) {
  if (!isRegExp(regexp)) {
    throw new ERR_INVALID_ARG_TYPE('regexp', 'RegExp', regexp);
  }
  var match = fnName === 'match';
  if (typeof string !== 'string' || RegExpPrototypeTest(regexp, string) !== match) {
    if (message instanceof Error) {
      throw message;
    }
    var generatedMessage = !message;

    // 'The input was expected to not match the regular expression ' +
    message = message || (typeof string !== 'string' ? 'The "string" argument must be of type string. Received type ' + "".concat(_typeof(string), " (").concat(inspect(string), ")") : (match ? 'The input did not match the regular expression ' : 'The input was expected to not match the regular expression ') + "".concat(inspect(regexp), ". Input:\n\n").concat(inspect(string), "\n"));
    var err = new AssertionError({
      actual: string,
      expected: regexp,
      message: message,
      operator: fnName,
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
}
assert.match = function match(string, regexp, message) {
  internalMatch(string, regexp, message, match, 'match');
};
assert.doesNotMatch = function doesNotMatch(string, regexp, message) {
  internalMatch(string, regexp, message, doesNotMatch, 'doesNotMatch');
};

// Expose a strict only variant of assert
function strict() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }
  innerOk.apply(void 0, [strict, args.length].concat(args));
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

},
"./node_modules/assert/build/internal/assert/assertion_error.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";
/* provided dependency */ var process = __webpack_require__("./node_modules/process/browser.js");
// Currently in sync with Node.js lib/internal/assert/assertion_error.js
// https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c



function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _require = __webpack_require__("./node_modules/util/util.js"),
  inspect = _require.inspect;
var _require2 = __webpack_require__("./node_modules/assert/build/internal/errors.js"),
  ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
function repeat(str, count) {
  count = Math.floor(count);
  if (str.length == 0 || count == 0) return '';
  var maxCount = str.length * count;
  count = Math.floor(Math.log(count) / Math.log(2));
  while (count) {
    str += str;
    count--;
  }
  str += str.substring(0, maxCount - str.length);
  return str;
}
var blue = '';
var green = '';
var red = '';
var white = '';
var kReadableOperator = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
  deepEqual: 'Expected values to be loosely deep-equal:',
  equal: 'Expected values to be loosely equal:',
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:',
  notIdentical: 'Values identical but not reference-equal:'
};

// Comparing short primitives should just show === / !== instead of using the
// diff.
var kMaxShortLength = 10;
function copyError(source) {
  var keys = Object.keys(source);
  var target = Object.create(Object.getPrototypeOf(source));
  keys.forEach(function (key) {
    target[key] = source[key];
  });
  Object.defineProperty(target, 'message', {
    value: source.message
  });
  return target;
}
function inspectValue(val) {
  // The util.inspect default values could be changed. This makes sure the
  // error messages contain the necessary information nevertheless.
  return inspect(val, {
    compact: false,
    customInspect: false,
    depth: 1000,
    maxArrayLength: Infinity,
    // Assert compares only enumerable properties (with a few exceptions).
    showHidden: false,
    // Having a long line as error is better than wrapping the line for
    // comparison for now.
    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
    // have meta information about the inspected properties (i.e., know where
    // in what line the property starts and ends).
    breakLength: Infinity,
    // Assert does not detect proxies currently.
    showProxy: false,
    sorted: true,
    // Inspect getters as we also check them when comparing entries.
    getters: true
  });
}
function createErrDiff(actual, expected, operator) {
  var other = '';
  var res = '';
  var lastPos = 0;
  var end = '';
  var skipped = false;
  var actualInspected = inspectValue(actual);
  var actualLines = actualInspected.split('\n');
  var expectedLines = inspectValue(expected).split('\n');
  var i = 0;
  var indicator = '';

  // In case both values are objects explicitly mark them as not reference equal
  // for the `strictEqual` operator.
  if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
    operator = 'strictEqualObject';
  }

  // If "actual" and "expected" fit on a single line and they are not strictly
  // equal, check further special handling.
  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
    var inputLength = actualLines[0].length + expectedLines[0].length;
    // If the character length of "actual" and "expected" together is less than
    // kMaxShortLength and if neither is an object and at least one of them is
    // not `zero`, use the strict equal comparison to visualize the output.
    if (inputLength <= kMaxShortLength) {
      if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
        // -0 === +0
        return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
      }
    } else if (operator !== 'strictEqualObject') {
      // If the stderr is a tty and the input length is lower than the current
      // columns per line, add a mismatch indicator below the output. If it is
      // not a tty, use a default value of 80 characters.
      var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
      if (inputLength < maxLength) {
        while (actualLines[0][i] === expectedLines[0][i]) {
          i++;
        }
        // Ignore the first characters.
        if (i > 2) {
          // Add position indicator for the first mismatch in case it is a
          // single line and the input length is less than the column length.
          indicator = "\n  ".concat(repeat(' ', i), "^");
          i = 0;
        }
      }
    }
  }

  // Remove all ending lines that match (this optimizes the output for
  // readability by reducing the number of total changed lines).
  var a = actualLines[actualLines.length - 1];
  var b = expectedLines[expectedLines.length - 1];
  while (a === b) {
    if (i++ < 2) {
      end = "\n  ".concat(a).concat(end);
    } else {
      other = a;
    }
    actualLines.pop();
    expectedLines.pop();
    if (actualLines.length === 0 || expectedLines.length === 0) break;
    a = actualLines[actualLines.length - 1];
    b = expectedLines[expectedLines.length - 1];
  }
  var maxLines = Math.max(actualLines.length, expectedLines.length);
  // Strict equal with identical objects that are not identical by reference.
  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
  if (maxLines === 0) {
    // We have to get the result again. The lines were all removed before.
    var _actualLines = actualInspected.split('\n');

    // Only remove lines in case it makes sense to collapse those.
    // TODO: Accept env to always show the full error.
    if (_actualLines.length > 30) {
      _actualLines[26] = "".concat(blue, "...").concat(white);
      while (_actualLines.length > 27) {
        _actualLines.pop();
      }
    }
    return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
  }
  if (i > 3) {
    end = "\n".concat(blue, "...").concat(white).concat(end);
    skipped = true;
  }
  if (other !== '') {
    end = "\n  ".concat(other).concat(end);
    other = '';
  }
  var printedLines = 0;
  var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
  var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
  for (i = 0; i < maxLines; i++) {
    // Only extra expected lines exist
    var cur = i - lastPos;
    if (actualLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(expectedLines[i - 2]);
          printedLines++;
        }
        res += "\n  ".concat(expectedLines[i - 1]);
        printedLines++;
      }
      // Mark the current line as the last diverging one.
      lastPos = i;
      // Add the expected line to the cache.
      other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
      printedLines++;
      // Only extra actual lines exist
    } else if (expectedLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(actualLines[i - 2]);
          printedLines++;
        }
        res += "\n  ".concat(actualLines[i - 1]);
        printedLines++;
      }
      // Mark the current line as the last diverging one.
      lastPos = i;
      // Add the actual line to the result.
      res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
      printedLines++;
      // Lines diverge
    } else {
      var expectedLine = expectedLines[i];
      var actualLine = actualLines[i];
      // If the lines diverge, specifically check for lines that only diverge by
      // a trailing comma. In that case it is actually identical and we should
      // mark it as such.
      var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine);
      // If the expected line has a trailing comma but is otherwise identical,
      // add a comma at the end of the actual line. Otherwise the output could
      // look weird as in:
      //
      //   [
      //     1         // No comma at the end!
      // +   2
      //   ]
      //
      if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
        divergingLines = false;
        actualLine += ',';
      }
      if (divergingLines) {
        // If the last diverging line is more than one line above and the
        // current line is at least line three, add some of the former lines and
        // also add dots to indicate skipped entries.
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += "\n".concat(blue, "...").concat(white);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(actualLines[i - 2]);
            printedLines++;
          }
          res += "\n  ".concat(actualLines[i - 1]);
          printedLines++;
        }
        // Mark the current line as the last diverging one.
        lastPos = i;
        // Add the actual line to the result and cache the expected diverging
        // line so consecutive diverging lines show up as +++--- and not +-+-+-.
        res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
        other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
        printedLines += 2;
        // Lines are identical
      } else {
        // Add all cached information to the result before adding other things
        // and reset the cache.
        res += other;
        other = '';
        // If the last diverging line is exactly one line above or if it is the
        // very first line, add the line to the result.
        if (cur === 1 || i === 0) {
          res += "\n  ".concat(actualLine);
          printedLines++;
        }
      }
    }
    // Inspected object to big (Show ~20 rows max)
    if (printedLines > 20 && i < maxLines - 2) {
      return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
    }
  }
  return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
}
var AssertionError = /*#__PURE__*/function (_Error, _inspect$custom) {
  _inherits(AssertionError, _Error);
  var _super = _createSuper(AssertionError);
  function AssertionError(options) {
    var _this;
    _classCallCheck(this, AssertionError);
    if (_typeof(options) !== 'object' || options === null) {
      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
    }
    var message = options.message,
      operator = options.operator,
      stackStartFn = options.stackStartFn;
    var actual = options.actual,
      expected = options.expected;
    var limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    if (message != null) {
      _this = _super.call(this, String(message));
    } else {
      if (process.stderr && process.stderr.isTTY) {
        // Reset on each call to make sure we handle dynamically set environment
        // variables correct.
        if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
          blue = "\x1B[34m";
          green = "\x1B[32m";
          white = "\x1B[39m";
          red = "\x1B[31m";
        } else {
          blue = '';
          green = '';
          white = '';
          red = '';
        }
      }
      // Prevent the error stack from being visible by duplicating the error
      // in a very close way to the original in case both sides are actually
      // instances of Error.
      if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
        actual = copyError(actual);
        expected = copyError(expected);
      }
      if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
        _this = _super.call(this, createErrDiff(actual, expected, operator));
      } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
        // In case the objects are equal but the operator requires unequal, show
        // the first object and say A equals B
        var base = kReadableOperator[operator];
        var res = inspectValue(actual).split('\n');

        // In case "actual" is an object, it should not be reference equal.
        if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
          base = kReadableOperator.notStrictEqualObject;
        }

        // Only remove lines in case it makes sense to collapse those.
        // TODO: Accept env to always show the full error.
        if (res.length > 30) {
          res[26] = "".concat(blue, "...").concat(white);
          while (res.length > 27) {
            res.pop();
          }
        }

        // Only print a single input.
        if (res.length === 1) {
          _this = _super.call(this, "".concat(base, " ").concat(res[0]));
        } else {
          _this = _super.call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n"));
        }
      } else {
        var _res = inspectValue(actual);
        var other = '';
        var knownOperators = kReadableOperator[operator];
        if (operator === 'notDeepEqual' || operator === 'notEqual') {
          _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
          if (_res.length > 1024) {
            _res = "".concat(_res.slice(0, 1021), "...");
          }
        } else {
          other = "".concat(inspectValue(expected));
          if (_res.length > 512) {
            _res = "".concat(_res.slice(0, 509), "...");
          }
          if (other.length > 512) {
            other = "".concat(other.slice(0, 509), "...");
          }
          if (operator === 'deepEqual' || operator === 'equal') {
            _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
          } else {
            other = " ".concat(operator, " ").concat(other);
          }
        }
        _this = _super.call(this, "".concat(_res).concat(other));
      }
    }
    Error.stackTraceLimit = limit;
    _this.generatedMessage = !message;
    Object.defineProperty(_assertThisInitialized(_this), 'name', {
      value: 'AssertionError [ERR_ASSERTION]',
      enumerable: false,
      writable: true,
      configurable: true
    });
    _this.code = 'ERR_ASSERTION';
    _this.actual = actual;
    _this.expected = expected;
    _this.operator = operator;
    if (Error.captureStackTrace) {
      // eslint-disable-next-line no-restricted-syntax
      Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
    }
    // Create error message including the error code in the name.
    _this.stack;
    // Reset the name.
    _this.name = 'AssertionError';
    return _possibleConstructorReturn(_this);
  }
  _createClass(AssertionError, [{
    key: "toString",
    value: function toString() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    }
  }, {
    key: _inspect$custom,
    value: function value(recurseTimes, ctx) {
      // This limits the `actual` and `expected` property default inspection to
      // the minimum depth. Otherwise those values would be too verbose compared
      // to the actual error message which contains a combined view of these two
      // input values.
      return inspect(this, _objectSpread(_objectSpread({}, ctx), {}, {
        customInspect: false,
        depth: 0
      }));
    }
  }]);
  return AssertionError;
}( /*#__PURE__*/_wrapNativeSuper(Error), inspect.custom);
module.exports = AssertionError;

},
"./node_modules/assert/build/internal/errors.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";
// Currently in sync with Node.js lib/internal/errors.js
// https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f

/* eslint node-core/documented-errors: "error" */
/* eslint node-core/alphabetize-errors: "error" */
/* eslint node-core/prefer-util-format-errors: "error" */



// The whole point behind this internal module is to allow Node.js to no
// longer be forced to treat every error message change as a semver-major
// change. The NodeError classes here all expose a `code` property whose
// value statically and permanently identifies the error. While the error
// message may change, the code should not.
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var codes = {};

// Lazy loaded
var assert;
var util;
function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }
  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = /*#__PURE__*/function (_Base) {
    _inherits(NodeError, _Base);
    var _super = _createSuper(NodeError);
    function NodeError(arg1, arg2, arg3) {
      var _this;
      _classCallCheck(this, NodeError);
      _this = _super.call(this, getMessage(arg1, arg2, arg3));
      _this.code = code;
      return _this;
    }
    return _createClass(NodeError);
  }(Base);
  codes[code] = NodeError;
}

// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });
    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }
  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}
createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  if (assert === undefined) assert = __webpack_require__("./node_modules/assert/build/assert.js");
  assert(typeof name === 'string', "'name' must be a string");

  // determiner: 'must be' or 'must not be'
  var determiner;
  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }
  var msg;
  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  // TODO(BridgeAR): Improve the output by showing `null` and similar.
  msg += ". Received type ".concat(_typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_INVALID_ARG_VALUE', function (name, value) {
  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
  if (util === undefined) util = __webpack_require__("./node_modules/util/util.js");
  var inspected = util.inspect(value);
  if (inspected.length > 128) {
    inspected = "".concat(inspected.slice(0, 128), "...");
  }
  return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
}, TypeError, RangeError);
createErrorType('ERR_INVALID_RETURN_VALUE', function (input, name, value) {
  var type;
  if (value && value.constructor && value.constructor.name) {
    type = "instance of ".concat(value.constructor.name);
  } else {
    type = "type ".concat(_typeof(value));
  }
  return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
}, TypeError);
createErrorType('ERR_MISSING_ARGS', function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (assert === undefined) assert = __webpack_require__("./node_modules/assert/build/assert.js");
  assert(args.length > 0, 'At least one arg needs to be specified');
  var msg = 'The ';
  var len = args.length;
  args = args.map(function (a) {
    return "\"".concat(a, "\"");
  });
  switch (len) {
    case 1:
      msg += "".concat(args[0], " argument");
      break;
    case 2:
      msg += "".concat(args[0], " and ").concat(args[1], " arguments");
      break;
    default:
      msg += args.slice(0, len - 1).join(', ');
      msg += ", and ".concat(args[len - 1], " arguments");
      break;
  }
  return "".concat(msg, " must be specified");
}, TypeError);
module.exports.codes = codes;

},
"./node_modules/assert/build/internal/util/comparisons.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";
// Currently in sync with Node.js lib/internal/util/comparisons.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9



function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var regexFlagsSupported = /a/g.flags !== undefined;
var arrayFromSet = function arrayFromSet(set) {
  var array = [];
  set.forEach(function (value) {
    return array.push(value);
  });
  return array;
};
var arrayFromMap = function arrayFromMap(map) {
  var array = [];
  map.forEach(function (value, key) {
    return array.push([key, value]);
  });
  return array;
};
var objectIs = Object.is ? Object.is : __webpack_require__("./node_modules/object-is/index.js");
var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {
  return [];
};
var numberIsNaN = Number.isNaN ? Number.isNaN : __webpack_require__("./node_modules/is-nan/index.js");
function uncurryThis(f) {
  return f.call.bind(f);
}
var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
var objectToString = uncurryThis(Object.prototype.toString);
var _require$types = (__webpack_require__("./node_modules/util/util.js")/* .types */.types),
  isAnyArrayBuffer = _require$types.isAnyArrayBuffer,
  isArrayBufferView = _require$types.isArrayBufferView,
  isDate = _require$types.isDate,
  isMap = _require$types.isMap,
  isRegExp = _require$types.isRegExp,
  isSet = _require$types.isSet,
  isNativeError = _require$types.isNativeError,
  isBoxedPrimitive = _require$types.isBoxedPrimitive,
  isNumberObject = _require$types.isNumberObject,
  isStringObject = _require$types.isStringObject,
  isBooleanObject = _require$types.isBooleanObject,
  isBigIntObject = _require$types.isBigIntObject,
  isSymbolObject = _require$types.isSymbolObject,
  isFloat32Array = _require$types.isFloat32Array,
  isFloat64Array = _require$types.isFloat64Array;
function isNonIndex(key) {
  if (key.length === 0 || key.length > 10) return true;
  for (var i = 0; i < key.length; i++) {
    var code = key.charCodeAt(i);
    if (code < 48 || code > 57) return true;
  }
  // The maximum size for an array is 2 ** 32 -1.
  return key.length === 10 && key >= Math.pow(2, 32);
}
function getOwnNonIndexProperties(value) {
  return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
}

// Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
var ONLY_ENUMERABLE = undefined;
var kStrict = true;
var kLoose = false;
var kNoIterator = 0;
var kIsArray = 1;
var kIsSet = 2;
var kIsMap = 3;

// Check if they have the same source and flags
function areSimilarRegExps(a, b) {
  return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
}
function areSimilarFloatArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (var offset = 0; offset < a.byteLength; offset++) {
    if (a[offset] !== b[offset]) {
      return false;
    }
  }
  return true;
}
function areSimilarTypedArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(val1, val2) {
  if (isNumberObject(val1)) {
    return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
  }
  if (isStringObject(val1)) {
    return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
  }
  if (isBooleanObject(val1)) {
    return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
  }
  if (isBigIntObject(val1)) {
    return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
  }
  return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
}

// Notes: Type tags are historical [[Class]] properties that can be set by
// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
// and retrieved using Object.prototype.toString.call(obj) in JS
// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
// for a list of tags pre-defined in the spec.
// There are some unspecified tags in the wild too (e.g. typed array tags).
// Since tags can be altered, they only serve fast failures
//
// Typed arrays and buffers are checked by comparing the content in their
// underlying ArrayBuffer. This optimization requires that it's
// reasonable to interpret their underlying memory in the same way,
// which is checked by comparing their type tags.
// (e.g. a Uint8Array and a Uint16Array with the same memory content
// could still be different because they will be interpreted differently).
//
// For strict comparison, objects should have
// a) The same built-in type tags
// b) The same prototypes.

function innerDeepEqual(val1, val2, strict, memos) {
  // All identical values are equivalent, as determined by ===.
  if (val1 === val2) {
    if (val1 !== 0) return true;
    return strict ? objectIs(val1, val2) : true;
  }

  // Check more closely if val1 and val2 are equal.
  if (strict) {
    if (_typeof(val1) !== 'object') {
      return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
    }
    if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
      return false;
    }
    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || _typeof(val1) !== 'object') {
      if (val2 === null || _typeof(val2) !== 'object') {
        // eslint-disable-next-line eqeqeq
        return val1 == val2;
      }
      return false;
    }
    if (val2 === null || _typeof(val2) !== 'object') {
      return false;
    }
  }
  var val1Tag = objectToString(val1);
  var val2Tag = objectToString(val2);
  if (val1Tag !== val2Tag) {
    return false;
  }
  if (Array.isArray(val1)) {
    // Check for sparse arrays and general fast path
    if (val1.length !== val2.length) {
      return false;
    }
    var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
    var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
    if (keys1.length !== keys2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
  }
  // [browserify] This triggers on certain types in IE (Map/Set) so we don't
  // wan't to early return out of the rest of the checks. However we can check
  // if the second value is one of these values and the first isn't.
  if (val1Tag === '[object Object]') {
    // return keyCheck(val1, val2, strict, memos, kNoIterator);
    if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
      return false;
    }
  }
  if (isDate(val1)) {
    if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
      return false;
    }
  } else if (isRegExp(val1)) {
    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
      return false;
    }
  } else if (isNativeError(val1) || val1 instanceof Error) {
    // Do not compare the stack as it might differ even though the error itself
    // is otherwise identical.
    if (val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if (isArrayBufferView(val1)) {
    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
      if (!areSimilarFloatArrays(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays(val1, val2)) {
      return false;
    }
    // Buffer.compare returns true, so val1.length === val2.length. If they both
    // only contain numeric keys, we don't need to exam further than checking
    // the symbols.
    var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
    var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
    if (_keys.length !== _keys2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
  } else if (isSet(val1)) {
    if (!isSet(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kIsSet);
  } else if (isMap(val1)) {
    if (!isMap(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kIsMap);
  } else if (isAnyArrayBuffer(val1)) {
    if (!areEqualArrayBuffers(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
    return false;
  }
  return keyCheck(val1, val2, strict, memos, kNoIterator);
}
function getEnumerables(val, keys) {
  return keys.filter(function (k) {
    return propertyIsEnumerable(val, k);
  });
}
function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
  // For all remaining Object pairs, including Array, objects and Maps,
  // equivalence is determined by having:
  // a) The same number of owned enumerable properties
  // b) The same set of keys/indexes (although not necessarily the same order)
  // c) Equivalent values for every corresponding key/index
  // d) For Sets and Maps, equal contents
  // Note: this accounts for both named and indexed properties on Arrays.
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    var bKeys = Object.keys(val2);

    // The pair must have the same number of owned properties.
    if (aKeys.length !== bKeys.length) {
      return false;
    }
  }

  // Cheap key test
  var i = 0;
  for (; i < aKeys.length; i++) {
    if (!hasOwnProperty(val2, aKeys[i])) {
      return false;
    }
  }
  if (strict && arguments.length === 5) {
    var symbolKeysA = objectGetOwnPropertySymbols(val1);
    if (symbolKeysA.length !== 0) {
      var count = 0;
      for (i = 0; i < symbolKeysA.length; i++) {
        var key = symbolKeysA[i];
        if (propertyIsEnumerable(val1, key)) {
          if (!propertyIsEnumerable(val2, key)) {
            return false;
          }
          aKeys.push(key);
          count++;
        } else if (propertyIsEnumerable(val2, key)) {
          return false;
        }
      }
      var symbolKeysB = objectGetOwnPropertySymbols(val2);
      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      var _symbolKeysB = objectGetOwnPropertySymbols(val2);
      if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
        return false;
      }
    }
  }
  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
    return true;
  }

  // Use memos to handle cycles.
  if (memos === undefined) {
    memos = {
      val1: new Map(),
      val2: new Map(),
      position: 0
    };
  } else {
    // We prevent up to two map.has(x) calls by directly retrieving the value
    // and checking for undefined. The map can only contain numbers, so it is
    // safe to check for undefined only.
    var val2MemoA = memos.val1.get(val1);
    if (val2MemoA !== undefined) {
      var val2MemoB = memos.val2.get(val2);
      if (val2MemoB !== undefined) {
        return val2MemoA === val2MemoB;
      }
    }
    memos.position++;
  }
  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}
function setHasEqualElement(set, val1, strict, memo) {
  // Go looking.
  var setValues = arrayFromSet(set);
  for (var i = 0; i < setValues.length; i++) {
    var val2 = setValues[i];
    if (innerDeepEqual(val1, val2, strict, memo)) {
      // Remove the matching element to make sure we do not check that again.
      set.delete(val2);
      return true;
    }
  }
  return false;
}

// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
// Sadly it is not possible to detect corresponding values properly in case the
// type is a string, number, bigint or boolean. The reason is that those values
// can match lots of different string values (e.g., 1n == '+00001').
function findLooseMatchingPrimitives(prim) {
  switch (_typeof(prim)) {
    case 'undefined':
      return null;
    case 'object':
      // Only pass in null as object!
      return undefined;
    case 'symbol':
      return false;
    case 'string':
      prim = +prim;
    // Loose equal entries exist only if the string is possible to convert to
    // a regular number and not NaN.
    // Fall through
    case 'number':
      if (numberIsNaN(prim)) {
        return false;
      }
  }
  return true;
}
function setMightHaveLoosePrim(a, b, prim) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) return altValue;
  return b.has(altValue) && !a.has(altValue);
}
function mapMightHaveLoosePrim(a, b, prim, item, memo) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) {
    return altValue;
  }
  var curB = b.get(altValue);
  if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
    return false;
  }
  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
}
function setEquiv(a, b, strict, memo) {
  // This is a lazily initiated Set of entries which have to be compared
  // pairwise.
  var set = null;
  var aValues = arrayFromSet(a);
  for (var i = 0; i < aValues.length; i++) {
    var val = aValues[i];
    // Note: Checking for the objects first improves the performance for object
    // heavy sets but it is a minor slow down for primitives. As they are fast
    // to check this improves the worst case scenario instead.
    if (_typeof(val) === 'object' && val !== null) {
      if (set === null) {
        set = new Set();
      }
      // If the specified value doesn't exist in the second set its an not null
      // object (or non strict only: a not matching primitive) we'll need to go
      // hunting for something thats deep-(strict-)equal to it. To make this
      // O(n log n) complexity we have to copy these values in a new set first.
      set.add(val);
    } else if (!b.has(val)) {
      if (strict) return false;

      // Fast path to detect missing string, symbol, undefined and null values.
      if (!setMightHaveLoosePrim(a, b, val)) {
        return false;
      }
      if (set === null) {
        set = new Set();
      }
      set.add(val);
    }
  }
  if (set !== null) {
    var bValues = arrayFromSet(b);
    for (var _i = 0; _i < bValues.length; _i++) {
      var _val = bValues[_i];
      // We have to check if a primitive value is already
      // matching and only if it's not, go hunting for it.
      if (_typeof(_val) === 'object' && _val !== null) {
        if (!setHasEqualElement(set, _val, strict, memo)) return false;
      } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
  // To be able to handle cases like:
  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
  // ... we need to consider *all* matching keys, not just the first we find.
  var setValues = arrayFromSet(set);
  for (var i = 0; i < setValues.length; i++) {
    var key2 = setValues[i];
    if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
      set.delete(key2);
      return true;
    }
  }
  return false;
}
function mapEquiv(a, b, strict, memo) {
  var set = null;
  var aEntries = arrayFromMap(a);
  for (var i = 0; i < aEntries.length; i++) {
    var _aEntries$i = _slicedToArray(aEntries[i], 2),
      key = _aEntries$i[0],
      item1 = _aEntries$i[1];
    if (_typeof(key) === 'object' && key !== null) {
      if (set === null) {
        set = new Set();
      }
      set.add(key);
    } else {
      // By directly retrieving the value we prevent another b.has(key) check in
      // almost all possible cases.
      var item2 = b.get(key);
      if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
        if (strict) return false;
        // Fast path to detect missing string, symbol, undefined and null
        // keys.
        if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
        if (set === null) {
          set = new Set();
        }
        set.add(key);
      }
    }
  }
  if (set !== null) {
    var bEntries = arrayFromMap(b);
    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
      var _bEntries$_i = _slicedToArray(bEntries[_i2], 2),
        _key = _bEntries$_i[0],
        item = _bEntries$_i[1];
      if (_typeof(_key) === 'object' && _key !== null) {
        if (!mapHasEqualEntry(set, a, _key, item, strict, memo)) return false;
      } else if (!strict && (!a.has(_key) || !innerDeepEqual(a.get(_key), item, false, memo)) && !mapHasEqualEntry(set, a, _key, item, false, memo)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function objEquiv(a, b, strict, keys, memos, iterationType) {
  // Sets and maps don't have their entries accessible via normal object
  // properties.
  var i = 0;
  if (iterationType === kIsSet) {
    if (!setEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsMap) {
    if (!mapEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsArray) {
    for (; i < a.length; i++) {
      if (hasOwnProperty(a, i)) {
        if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
          return false;
        }
      } else if (hasOwnProperty(b, i)) {
        return false;
      } else {
        // Array is sparse.
        var keysA = Object.keys(a);
        for (; i < keysA.length; i++) {
          var key = keysA[i];
          if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
            return false;
          }
        }
        if (keysA.length !== Object.keys(b).length) {
          return false;
        }
        return true;
      }
    }
  }

  // The pair must have equivalent values for every corresponding key.
  // Possibly expensive deep test:
  for (i = 0; i < keys.length; i++) {
    var _key2 = keys[i];
    if (!innerDeepEqual(a[_key2], b[_key2], strict, memos)) {
      return false;
    }
  }
  return true;
}
function isDeepEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kLoose);
}
function isDeepStrictEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kStrict);
}
module.exports = {
  isDeepEqual: isDeepEqual,
  isDeepStrictEqual: isDeepStrictEqual
};

},
"./node_modules/base64-js/index.js"(__unused_rspack_module, exports) {
"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


},
"./node_modules/buffer/index.js"(__unused_rspack_module, exports, __webpack_require__) {
"use strict";
/* provided dependency */ var console = __webpack_require__("./node_modules/console-browserify/index.js");
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



const base64 = __webpack_require__("./node_modules/base64-js/index.js")
const ieee754 = __webpack_require__("./node_modules/ieee754/index.js")
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}


},
"./node_modules/call-bind-apply-helpers/actualApply.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var bind = __webpack_require__("./node_modules/function-bind/index.js");

var $apply = __webpack_require__("./node_modules/call-bind-apply-helpers/functionApply.js");
var $call = __webpack_require__("./node_modules/call-bind-apply-helpers/functionCall.js");
var $reflectApply = __webpack_require__("./node_modules/call-bind-apply-helpers/reflectApply.js");

/** @type {import('./actualApply')} */
module.exports = $reflectApply || bind.call($call, $apply);


},
"./node_modules/call-bind-apply-helpers/applyBind.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var bind = __webpack_require__("./node_modules/function-bind/index.js");
var $apply = __webpack_require__("./node_modules/call-bind-apply-helpers/functionApply.js");
var actualApply = __webpack_require__("./node_modules/call-bind-apply-helpers/actualApply.js");

/** @type {import('./applyBind')} */
module.exports = function applyBind() {
	return actualApply(bind, $apply, arguments);
};


},
"./node_modules/call-bind-apply-helpers/functionApply.js"(module) {
"use strict";


/** @type {import('./functionApply')} */
module.exports = Function.prototype.apply;


},
"./node_modules/call-bind-apply-helpers/functionCall.js"(module) {
"use strict";


/** @type {import('./functionCall')} */
module.exports = Function.prototype.call;


},
"./node_modules/call-bind-apply-helpers/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var bind = __webpack_require__("./node_modules/function-bind/index.js");
var $TypeError = __webpack_require__("./node_modules/es-errors/type.js");

var $call = __webpack_require__("./node_modules/call-bind-apply-helpers/functionCall.js");
var $actualApply = __webpack_require__("./node_modules/call-bind-apply-helpers/actualApply.js");

/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
module.exports = function callBindBasic(args) {
	if (args.length < 1 || typeof args[0] !== 'function') {
		throw new $TypeError('a function is required');
	}
	return $actualApply(bind, $call, args);
};


},
"./node_modules/call-bind-apply-helpers/reflectApply.js"(module) {
"use strict";


/** @type {import('./reflectApply')} */
module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;


},
"./node_modules/call-bind/callBound.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var GetIntrinsic = __webpack_require__("./node_modules/get-intrinsic/index.js");

var callBind = __webpack_require__("./node_modules/call-bind/index.js");

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


},
"./node_modules/call-bind/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var setFunctionLength = __webpack_require__("./node_modules/set-function-length/index.js");

var $defineProperty = __webpack_require__("./node_modules/es-define-property/index.js");

var callBindBasic = __webpack_require__("./node_modules/call-bind-apply-helpers/index.js");
var applyBind = __webpack_require__("./node_modules/call-bind-apply-helpers/applyBind.js");

module.exports = function callBind(originalFunction) {
	var func = callBindBasic(arguments);
	var adjustedLength = originalFunction.length - (arguments.length - 1);
	return setFunctionLength(
		func,
		1 + (adjustedLength > 0 ? adjustedLength : 0),
		true
	);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


},
"./node_modules/call-bound/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var GetIntrinsic = __webpack_require__("./node_modules/get-intrinsic/index.js");

var callBindBasic = __webpack_require__("./node_modules/call-bind-apply-helpers/index.js");

/** @type {(thisArg: string, searchString: string, position?: number) => number} */
var $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);

/** @type {import('.')} */
module.exports = function callBoundIntrinsic(name, allowMissing) {
	/* eslint no-extra-parens: 0 */

	var intrinsic = /** @type {(this: unknown, ...args: unknown[]) => unknown} */ (GetIntrinsic(name, !!allowMissing));
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBindBasic(/** @type {const} */ ([intrinsic]));
	}
	return intrinsic;
};


},
"./node_modules/console-browserify/index.js"(module, __unused_rspack_exports, __webpack_require__) {
/*global window, global*/
var util = __webpack_require__("./node_modules/util/util.js")
var assert = __webpack_require__("./node_modules/assert/build/assert.js")
function now() { return new Date().getTime() }

var slice = Array.prototype.slice
var console
var times = {}

if (typeof __webpack_require__.g !== "undefined" && __webpack_require__.g.console) {
    console = __webpack_require__.g.console
} else if (typeof window !== "undefined" && window.console) {
    console = window.console
} else {
    console = {}
}

var functions = [
    [log, "log"],
    [info, "info"],
    [warn, "warn"],
    [error, "error"],
    [time, "time"],
    [timeEnd, "timeEnd"],
    [trace, "trace"],
    [dir, "dir"],
    [consoleAssert, "assert"]
]

for (var i = 0; i < functions.length; i++) {
    var tuple = functions[i]
    var f = tuple[0]
    var name = tuple[1]

    if (!console[name]) {
        console[name] = f
    }
}

module.exports = console

function log() {}

function info() {
    console.log.apply(console, arguments)
}

function warn() {
    console.log.apply(console, arguments)
}

function error() {
    console.warn.apply(console, arguments)
}

function time(label) {
    times[label] = now()
}

function timeEnd(label) {
    var time = times[label]
    if (!time) {
        throw new Error("No such label: " + label)
    }

    delete times[label]
    var duration = now() - time
    console.log(label + ": " + duration + "ms")
}

function trace() {
    var err = new Error()
    err.name = "Trace"
    err.message = util.format.apply(null, arguments)
    console.error(err.stack)
}

function dir(object) {
    console.log(util.inspect(object) + "\n")
}

function consoleAssert(expression) {
    if (!expression) {
        var arr = slice.call(arguments, 1)
        assert.ok(false, util.format.apply(null, arr))
    }
}


},
"./node_modules/define-data-property/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var $defineProperty = __webpack_require__("./node_modules/es-define-property/index.js");

var $SyntaxError = __webpack_require__("./node_modules/es-errors/syntax.js");
var $TypeError = __webpack_require__("./node_modules/es-errors/type.js");

var gopd = __webpack_require__("./node_modules/gopd/index.js");

/** @type {import('.')} */
module.exports = function defineDataProperty(
	obj,
	property,
	value
) {
	if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
		throw new $TypeError('`obj` must be an object or a function`');
	}
	if (typeof property !== 'string' && typeof property !== 'symbol') {
		throw new $TypeError('`property` must be a string or a symbol`');
	}
	if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
		throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
		throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
		throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('`loose`, if provided, must be a boolean');
	}

	var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
	var nonWritable = arguments.length > 4 ? arguments[4] : null;
	var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
	var loose = arguments.length > 6 ? arguments[6] : false;

	/* @type {false | TypedPropertyDescriptor<unknown>} */
	var desc = !!gopd && gopd(obj, property);

	if ($defineProperty) {
		$defineProperty(obj, property, {
			configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
			enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
			value: value,
			writable: nonWritable === null && desc ? desc.writable : !nonWritable
		});
	} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
		// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
		obj[property] = value; // eslint-disable-line no-param-reassign
	} else {
		throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
	}
};


},
"./node_modules/define-properties/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var keys = __webpack_require__("./node_modules/object-keys/index.js");
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var defineDataProperty = __webpack_require__("./node_modules/define-data-property/index.js");

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var supportsDescriptors = __webpack_require__("./node_modules/has-property-descriptors/index.js")();

var defineProperty = function (object, name, value, predicate) {
	if (name in object) {
		if (predicate === true) {
			if (object[name] === value) {
				return;
			}
		} else if (!isFunction(predicate) || !predicate()) {
			return;
		}
	}

	if (supportsDescriptors) {
		defineDataProperty(object, name, value, true);
	} else {
		defineDataProperty(object, name, value);
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;


},
"./node_modules/dunder-proto/get.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var callBind = __webpack_require__("./node_modules/call-bind-apply-helpers/index.js");
var gOPD = __webpack_require__("./node_modules/gopd/index.js");

var hasProtoAccessor;
try {
	// eslint-disable-next-line no-extra-parens, no-proto
	hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
} catch (e) {
	if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
		throw e;
	}
}

// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;

/** @type {import('./get')} */
module.exports = desc && typeof desc.get === 'function'
	? callBind([desc.get])
	: typeof $getPrototypeOf === 'function'
		? /** @type {import('./get')} */ function getDunder(value) {
			// eslint-disable-next-line eqeqeq
			return $getPrototypeOf(value == null ? value : $Object(value));
		}
		: false;


},
"./node_modules/es-define-property/index.js"(module) {
"use strict";


/** @type {import('.')} */
var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;


},
"./node_modules/es-errors/eval.js"(module) {
"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;


},
"./node_modules/es-errors/index.js"(module) {
"use strict";


/** @type {import('.')} */
module.exports = Error;


},
"./node_modules/es-errors/range.js"(module) {
"use strict";


/** @type {import('./range')} */
module.exports = RangeError;


},
"./node_modules/es-errors/ref.js"(module) {
"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;


},
"./node_modules/es-errors/syntax.js"(module) {
"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;


},
"./node_modules/es-errors/type.js"(module) {
"use strict";


/** @type {import('./type')} */
module.exports = TypeError;


},
"./node_modules/es-errors/uri.js"(module) {
"use strict";


/** @type {import('./uri')} */
module.exports = URIError;


},
"./node_modules/es-object-atoms/index.js"(module) {
"use strict";


/** @type {import('.')} */
module.exports = Object;


},
"./node_modules/for-each/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var isCallable = __webpack_require__("./node_modules/is-callable/index.js");

var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

/** @type {<This, A extends readonly unknown[]>(arr: A, iterator: (this: This | void, value: A[number], index: number, arr: A) => void, receiver: This | undefined) => void} */
var forEachArray = function forEachArray(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};

/** @type {<This, S extends string>(string: S, iterator: (this: This | void, value: S[number], index: number, string: S) => void, receiver: This | undefined) => void} */
var forEachString = function forEachString(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};

/** @type {<This, O>(obj: O, iterator: (this: This | void, value: O[keyof O], index: keyof O, obj: O) => void, receiver: This | undefined) => void} */
var forEachObject = function forEachObject(object, iterator, receiver) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};

/** @type {(x: unknown) => x is readonly unknown[]} */
function isArray(x) {
    return toStr.call(x) === '[object Array]';
}

/** @type {import('.')._internal} */
module.exports = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }

    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }

    if (isArray(list)) {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};


},
"./node_modules/function-bind/implementation.js"(module) {
"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


},
"./node_modules/function-bind/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var implementation = __webpack_require__("./node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


},
"./node_modules/generator-function/index.js"(module) {
"use strict";


// eslint-disable-next-line no-extra-parens, no-empty-function
const cached = /** @type {GeneratorFunctionConstructor} */ (function* () {}.constructor);

/** @type {import('.')} */
module.exports = () => cached;



},
"./node_modules/get-intrinsic/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var undefined;

var $Object = __webpack_require__("./node_modules/es-object-atoms/index.js");

var $Error = __webpack_require__("./node_modules/es-errors/index.js");
var $EvalError = __webpack_require__("./node_modules/es-errors/eval.js");
var $RangeError = __webpack_require__("./node_modules/es-errors/range.js");
var $ReferenceError = __webpack_require__("./node_modules/es-errors/ref.js");
var $SyntaxError = __webpack_require__("./node_modules/es-errors/syntax.js");
var $TypeError = __webpack_require__("./node_modules/es-errors/type.js");
var $URIError = __webpack_require__("./node_modules/es-errors/uri.js");

var abs = __webpack_require__("./node_modules/math-intrinsics/abs.js");
var floor = __webpack_require__("./node_modules/math-intrinsics/floor.js");
var max = __webpack_require__("./node_modules/math-intrinsics/max.js");
var min = __webpack_require__("./node_modules/math-intrinsics/min.js");
var pow = __webpack_require__("./node_modules/math-intrinsics/pow.js");
var round = __webpack_require__("./node_modules/math-intrinsics/round.js");
var sign = __webpack_require__("./node_modules/math-intrinsics/sign.js");

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = __webpack_require__("./node_modules/gopd/index.js");
var $defineProperty = __webpack_require__("./node_modules/es-define-property/index.js");

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__("./node_modules/has-symbols/index.js")();

var getProto = __webpack_require__("./node_modules/get-proto/index.js");
var $ObjectGPO = __webpack_require__("./node_modules/get-proto/Object.getPrototypeOf.js");
var $ReflectGPO = __webpack_require__("./node_modules/get-proto/Reflect.getPrototypeOf.js");

var $apply = __webpack_require__("./node_modules/call-bind-apply-helpers/functionApply.js");
var $call = __webpack_require__("./node_modules/call-bind-apply-helpers/functionCall.js");

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': $Object,
	'%Object.getOwnPropertyDescriptor%': $gOPD,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,

	'%Function.prototype.call%': $call,
	'%Function.prototype.apply%': $apply,
	'%Object.defineProperty%': $defineProperty,
	'%Object.getPrototypeOf%': $ObjectGPO,
	'%Math.abs%': abs,
	'%Math.floor%': floor,
	'%Math.max%': max,
	'%Math.min%': min,
	'%Math.pow%': pow,
	'%Math.round%': round,
	'%Math.sign%': sign,
	'%Reflect.getPrototypeOf%': $ReflectGPO
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__("./node_modules/function-bind/index.js");
var hasOwn = __webpack_require__("./node_modules/hasown/index.js");
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


},
"./node_modules/get-proto/Object.getPrototypeOf.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var $Object = __webpack_require__("./node_modules/es-object-atoms/index.js");

/** @type {import('./Object.getPrototypeOf')} */
module.exports = $Object.getPrototypeOf || null;


},
"./node_modules/get-proto/Reflect.getPrototypeOf.js"(module) {
"use strict";


/** @type {import('./Reflect.getPrototypeOf')} */
module.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;


},
"./node_modules/get-proto/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var reflectGetProto = __webpack_require__("./node_modules/get-proto/Reflect.getPrototypeOf.js");
var originalGetProto = __webpack_require__("./node_modules/get-proto/Object.getPrototypeOf.js");

var getDunderProto = __webpack_require__("./node_modules/dunder-proto/get.js");

/** @type {import('.')} */
module.exports = reflectGetProto
	? function getProto(O) {
		// @ts-expect-error TS can't narrow inside a closure, for some reason
		return reflectGetProto(O);
	}
	: originalGetProto
		? function getProto(O) {
			if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
				throw new TypeError('getProto: not an object');
			}
			// @ts-expect-error TS can't narrow inside a closure, for some reason
			return originalGetProto(O);
		}
		: getDunderProto
			? function getProto(O) {
				// @ts-expect-error TS can't narrow inside a closure, for some reason
				return getDunderProto(O);
			}
			: null;


},
"./node_modules/gopd/gOPD.js"(module) {
"use strict";


/** @type {import('./gOPD')} */
module.exports = Object.getOwnPropertyDescriptor;


},
"./node_modules/gopd/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


/** @type {import('.')} */
var $gOPD = __webpack_require__("./node_modules/gopd/gOPD.js");

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


},
"./node_modules/has-property-descriptors/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var $defineProperty = __webpack_require__("./node_modules/es-define-property/index.js");

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	return !!$defineProperty;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!$defineProperty) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;


},
"./node_modules/has-symbols/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__("./node_modules/has-symbols/shams.js");

/** @type {import('.')} */
module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


},
"./node_modules/has-symbols/shams.js"(module) {
"use strict";


/** @type {import('./shams')} */
/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	/** @type {{ [k in symbol]?: unknown }} */
	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


},
"./node_modules/has-tostringtag/shams.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var hasSymbols = __webpack_require__("./node_modules/has-symbols/shams.js");

/** @type {import('.')} */
module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};


},
"./node_modules/hasown/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__("./node_modules/function-bind/index.js");

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);


},
"./node_modules/ieee754/index.js"(__unused_rspack_module, exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


},
"./node_modules/inherits/inherits_browser.js"(module) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


},
"./node_modules/is-arguments/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var hasToStringTag = __webpack_require__("./node_modules/has-tostringtag/shams.js")();
var callBound = __webpack_require__("./node_modules/call-bound/index.js");

var $toString = callBound('Object.prototype.toString');

/** @type {import('.')} */
var isStandardArguments = function isArguments(value) {
	if (
		hasToStringTag
		&& value
		&& typeof value === 'object'
		&& Symbol.toStringTag in value
	) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

/** @type {import('.')} */
var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null
		&& typeof value === 'object'
		&& 'length' in value
		&& typeof value.length === 'number'
		&& value.length >= 0
		&& $toString(value) !== '[object Array]'
		&& 'callee' in value
		&& $toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

// @ts-expect-error TODO make this not error
isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

/** @type {import('.')} */
module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;


},
"./node_modules/is-callable/index.js"(module) {
"use strict";


var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
	try {
		badArrayLike = Object.defineProperty({}, 'length', {
			get: function () {
				throw isCallableMarker;
			}
		});
		isCallableMarker = {};
		// eslint-disable-next-line no-throw-literal
		reflectApply(function () { throw 42; }, null, badArrayLike);
	} catch (_) {
		if (_ !== isCallableMarker) {
			reflectApply = null;
		}
	}
} else {
	reflectApply = null;
}

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]'; // IE 11
var ddaClass2 = '[object HTML document.all class]';
var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

var isDDA = function isDocumentDotAll() { return false; };
if (typeof document === 'object') {
	// Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
	var all = document.all;
	if (toStr.call(all) === toStr.call(document.all)) {
		isDDA = function isDocumentDotAll(value) {
			/* globals document: false */
			// in IE 6-8, typeof document.all is "object" and it's truthy
			if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
				try {
					var str = toStr.call(value);
					return (
						str === ddaClass
						|| str === ddaClass2
						|| str === ddaClass3 // opera 12.16
						|| str === objectClass // IE 6-8
					) && value('') == null; // eslint-disable-line eqeqeq
				} catch (e) { /**/ }
			}
			return false;
		};
	}
}

module.exports = reflectApply
	? function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		try {
			reflectApply(value, null, badArrayLike);
		} catch (e) {
			if (e !== isCallableMarker) { return false; }
		}
		return !isES6ClassFn(value) && tryFunctionObject(value);
	}
	: function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		if (strClass !== fnClass && strClass !== genClass && !(/^\[object HTML/).test(strClass)) { return false; }
		return tryFunctionObject(value);
	};


},
"./node_modules/is-generator-function/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var callBound = __webpack_require__("./node_modules/call-bound/index.js");
var safeRegexTest = __webpack_require__("./node_modules/safe-regex-test/index.js");
var isFnRegex = safeRegexTest(/^\s*(?:function)?\*/);
var hasToStringTag = __webpack_require__("./node_modules/has-tostringtag/shams.js")();
var getProto = __webpack_require__("./node_modules/get-proto/index.js");

var toStr = callBound('Object.prototype.toString');
var fnToStr = callBound('Function.prototype.toString');

var getGeneratorFunction = __webpack_require__("./node_modules/generator-function/index.js");

/** @type {import('.')} */
module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex(fnToStr(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr(fn);
		return str === '[object GeneratorFunction]';
	}
	if (!getProto) {
		return false;
	}
	var GeneratorFunction = getGeneratorFunction();
	return GeneratorFunction && getProto(fn) === GeneratorFunction.prototype;
};


},
"./node_modules/is-nan/implementation.js"(module) {
"use strict";


/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function isNaN(value) {
	return value !== value;
};


},
"./node_modules/is-nan/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var callBind = __webpack_require__("./node_modules/call-bind/index.js");
var define = __webpack_require__("./node_modules/define-properties/index.js");

var implementation = __webpack_require__("./node_modules/is-nan/implementation.js");
var getPolyfill = __webpack_require__("./node_modules/is-nan/polyfill.js");
var shim = __webpack_require__("./node_modules/is-nan/shim.js");

var polyfill = callBind(getPolyfill(), Number);

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


},
"./node_modules/is-nan/polyfill.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var implementation = __webpack_require__("./node_modules/is-nan/implementation.js");

module.exports = function getPolyfill() {
	if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
		return Number.isNaN;
	}
	return implementation;
};


},
"./node_modules/is-nan/shim.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var define = __webpack_require__("./node_modules/define-properties/index.js");
var getPolyfill = __webpack_require__("./node_modules/is-nan/polyfill.js");

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function shimNumberIsNaN() {
	var polyfill = getPolyfill();
	define(Number, { isNaN: polyfill }, {
		isNaN: function testIsNaN() {
			return Number.isNaN !== polyfill;
		}
	});
	return polyfill;
};


},
"./node_modules/is-regex/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var callBound = __webpack_require__("./node_modules/call-bound/index.js");
var hasToStringTag = __webpack_require__("./node_modules/has-tostringtag/shams.js")();
var hasOwn = __webpack_require__("./node_modules/hasown/index.js");
var gOPD = __webpack_require__("./node_modules/gopd/index.js");

/** @type {import('.')} */
var fn;

if (hasToStringTag) {
	/** @type {(receiver: ThisParameterType<typeof RegExp.prototype.exec>, ...args: Parameters<typeof RegExp.prototype.exec>) => ReturnType<typeof RegExp.prototype.exec>} */
	var $exec = callBound('RegExp.prototype.exec');
	/** @type {object} */
	var isRegexMarker = {};

	var throwRegexMarker = function () {
		throw isRegexMarker;
	};
	/** @type {{ toString(): never, valueOf(): never, [Symbol.toPrimitive]?(): never }} */
	var badStringifier = {
		toString: throwRegexMarker,
		valueOf: throwRegexMarker
	};

	if (typeof Symbol.toPrimitive === 'symbol') {
		badStringifier[Symbol.toPrimitive] = throwRegexMarker;
	}

	/** @type {import('.')} */
	// @ts-expect-error TS can't figure out that the $exec call always throws
	// eslint-disable-next-line consistent-return
	fn = function isRegex(value) {
		if (!value || typeof value !== 'object') {
			return false;
		}

		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {NonNullable<typeof gOPD>} */ (gOPD)(/** @type {{ lastIndex?: unknown }} */ (value), 'lastIndex');
		var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, 'value');
		if (!hasLastIndexDataProperty) {
			return false;
		}

		try {
			// eslint-disable-next-line no-extra-parens
			$exec(value, /** @type {string} */ (/** @type {unknown} */ (badStringifier)));
		} catch (e) {
			return e === isRegexMarker;
		}
	};
} else {
	/** @type {(receiver: ThisParameterType<typeof Object.prototype.toString>, ...args: Parameters<typeof Object.prototype.toString>) => ReturnType<typeof Object.prototype.toString>} */
	var $toString = callBound('Object.prototype.toString');
	/** @const @type {'[object RegExp]'} */
	var regexClass = '[object RegExp]';

	/** @type {import('.')} */
	fn = function isRegex(value) {
		// In older browsers, typeof regex incorrectly returns 'function'
		if (!value || (typeof value !== 'object' && typeof value !== 'function')) {
			return false;
		}

		return $toString(value) === regexClass;
	};
}

module.exports = fn;


},
"./node_modules/is-typed-array/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var whichTypedArray = __webpack_require__("./node_modules/which-typed-array/index.js");

/** @type {import('.')} */
module.exports = function isTypedArray(value) {
	return !!whichTypedArray(value);
};


},
"./node_modules/math-intrinsics/abs.js"(module) {
"use strict";


/** @type {import('./abs')} */
module.exports = Math.abs;


},
"./node_modules/math-intrinsics/floor.js"(module) {
"use strict";


/** @type {import('./floor')} */
module.exports = Math.floor;


},
"./node_modules/math-intrinsics/isNaN.js"(module) {
"use strict";


/** @type {import('./isNaN')} */
module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};


},
"./node_modules/math-intrinsics/max.js"(module) {
"use strict";


/** @type {import('./max')} */
module.exports = Math.max;


},
"./node_modules/math-intrinsics/min.js"(module) {
"use strict";


/** @type {import('./min')} */
module.exports = Math.min;


},
"./node_modules/math-intrinsics/pow.js"(module) {
"use strict";


/** @type {import('./pow')} */
module.exports = Math.pow;


},
"./node_modules/math-intrinsics/round.js"(module) {
"use strict";


/** @type {import('./round')} */
module.exports = Math.round;


},
"./node_modules/math-intrinsics/sign.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var $isNaN = __webpack_require__("./node_modules/math-intrinsics/isNaN.js");

/** @type {import('./sign')} */
module.exports = function sign(number) {
	if ($isNaN(number) || number === 0) {
		return number;
	}
	return number < 0 ? -1 : +1;
};


},
"./node_modules/object-is/implementation.js"(module) {
"use strict";


var numberIsNaN = function (value) {
	return value !== value;
};

module.exports = function is(a, b) {
	if (a === 0 && b === 0) {
		return 1 / a === 1 / b;
	}
	if (a === b) {
		return true;
	}
	if (numberIsNaN(a) && numberIsNaN(b)) {
		return true;
	}
	return false;
};



},
"./node_modules/object-is/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var define = __webpack_require__("./node_modules/define-properties/index.js");
var callBind = __webpack_require__("./node_modules/call-bind/index.js");

var implementation = __webpack_require__("./node_modules/object-is/implementation.js");
var getPolyfill = __webpack_require__("./node_modules/object-is/polyfill.js");
var shim = __webpack_require__("./node_modules/object-is/shim.js");

var polyfill = callBind(getPolyfill(), Object);

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


},
"./node_modules/object-is/polyfill.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var implementation = __webpack_require__("./node_modules/object-is/implementation.js");

module.exports = function getPolyfill() {
	return typeof Object.is === 'function' ? Object.is : implementation;
};


},
"./node_modules/object-is/shim.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var getPolyfill = __webpack_require__("./node_modules/object-is/polyfill.js");
var define = __webpack_require__("./node_modules/define-properties/index.js");

module.exports = function shimObjectIs() {
	var polyfill = getPolyfill();
	define(Object, { is: polyfill }, {
		is: function testObjectIs() {
			return Object.is !== polyfill;
		}
	});
	return polyfill;
};


},
"./node_modules/object-keys/implementation.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = __webpack_require__("./node_modules/object-keys/isArguments.js"); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;


},
"./node_modules/object-keys/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var slice = Array.prototype.slice;
var isArgs = __webpack_require__("./node_modules/object-keys/isArguments.js");

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__("./node_modules/object-keys/implementation.js");

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;


},
"./node_modules/object-keys/isArguments.js"(module) {
"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};


},
"./node_modules/object.assign/implementation.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


// modified from https://github.com/es-shims/es6-shim
var objectKeys = __webpack_require__("./node_modules/object-keys/index.js");
var hasSymbols = __webpack_require__("./node_modules/has-symbols/shams.js")();
var callBound = __webpack_require__("./node_modules/call-bound/index.js");
var $Object = __webpack_require__("./node_modules/es-object-atoms/index.js");
var $push = callBound('Array.prototype.push');
var $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');
var originalGetSymbols = hasSymbols ? $Object.getOwnPropertySymbols : null;

// eslint-disable-next-line no-unused-vars
module.exports = function assign(target, source1) {
	if (target == null) { throw new TypeError('target must be an object'); }
	var to = $Object(target); // step 1
	if (arguments.length === 1) {
		return to; // step 2
	}
	for (var s = 1; s < arguments.length; ++s) {
		var from = $Object(arguments[s]); // step 3.a.i

		// step 3.a.ii:
		var keys = objectKeys(from);
		var getSymbols = hasSymbols && ($Object.getOwnPropertySymbols || originalGetSymbols);
		if (getSymbols) {
			var syms = getSymbols(from);
			for (var j = 0; j < syms.length; ++j) {
				var key = syms[j];
				if ($propIsEnumerable(from, key)) {
					$push(keys, key);
				}
			}
		}

		// step 3.a.iii:
		for (var i = 0; i < keys.length; ++i) {
			var nextKey = keys[i];
			if ($propIsEnumerable(from, nextKey)) { // step 3.a.iii.2
				var propValue = from[nextKey]; // step 3.a.iii.2.a
				to[nextKey] = propValue; // step 3.a.iii.2.b
			}
		}
	}

	return to; // step 4
};


},
"./node_modules/object.assign/polyfill.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var implementation = __webpack_require__("./node_modules/object.assign/implementation.js");

var lacksProperEnumerationOrder = function () {
	if (!Object.assign) {
		return false;
	}
	/*
	 * v8, specifically in node 4.x, has a bug with incorrect property enumeration order
	 * note: this does not detect the bug unless there's 20 characters
	 */
	var str = 'abcdefghijklmnopqrst';
	var letters = str.split('');
	var map = {};
	for (var i = 0; i < letters.length; ++i) {
		map[letters[i]] = letters[i];
	}
	var obj = Object.assign({}, map);
	var actual = '';
	for (var k in obj) {
		actual += k;
	}
	return str !== actual;
};

var assignHasPendingExceptions = function () {
	if (!Object.assign || !Object.preventExtensions) {
		return false;
	}
	/*
	 * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
	 * which is 72% slower than our shim, and Firefox 40's native implementation.
	 */
	var thrower = Object.preventExtensions({ 1: 2 });
	try {
		Object.assign(thrower, 'xy');
	} catch (e) {
		return thrower[1] === 'y';
	}
	return false;
};

module.exports = function getPolyfill() {
	if (!Object.assign) {
		return implementation;
	}
	if (lacksProperEnumerationOrder()) {
		return implementation;
	}
	if (assignHasPendingExceptions()) {
		return implementation;
	}
	return Object.assign;
};


},
"./node_modules/possible-typed-array-names/index.js"(module) {
"use strict";


/** @type {import('.')} */
module.exports = [
	'Float16Array',
	'Float32Array',
	'Float64Array',
	'Int8Array',
	'Int16Array',
	'Int32Array',
	'Uint8Array',
	'Uint8ClampedArray',
	'Uint16Array',
	'Uint32Array',
	'BigInt64Array',
	'BigUint64Array'
];


},
"./node_modules/process/browser.js"(module) {
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


},
"./node_modules/safe-regex-test/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var callBound = __webpack_require__("./node_modules/call-bound/index.js");
var isRegex = __webpack_require__("./node_modules/is-regex/index.js");

var $exec = callBound('RegExp.prototype.exec');
var $TypeError = __webpack_require__("./node_modules/es-errors/type.js");

/** @type {import('.')} */
module.exports = function regexTester(regex) {
	if (!isRegex(regex)) {
		throw new $TypeError('`regex` must be a RegExp');
	}
	return function test(s) {
		return $exec(regex, s) !== null;
	};
};


},
"./node_modules/set-function-length/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var GetIntrinsic = __webpack_require__("./node_modules/get-intrinsic/index.js");
var define = __webpack_require__("./node_modules/define-data-property/index.js");
var hasDescriptors = __webpack_require__("./node_modules/has-property-descriptors/index.js")();
var gOPD = __webpack_require__("./node_modules/gopd/index.js");

var $TypeError = __webpack_require__("./node_modules/es-errors/type.js");
var $floor = GetIntrinsic('%Math.floor%');

/** @type {import('.')} */
module.exports = function setFunctionLength(fn, length) {
	if (typeof fn !== 'function') {
		throw new $TypeError('`fn` is not a function');
	}
	if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
		throw new $TypeError('`length` must be a positive 32-bit integer');
	}

	var loose = arguments.length > 2 && !!arguments[2];

	var functionLengthIsConfigurable = true;
	var functionLengthIsWritable = true;
	if ('length' in fn && gOPD) {
		var desc = gOPD(fn, 'length');
		if (desc && !desc.configurable) {
			functionLengthIsConfigurable = false;
		}
		if (desc && !desc.writable) {
			functionLengthIsWritable = false;
		}
	}

	if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
		if (hasDescriptors) {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
		} else {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
		}
	}
	return fn;
};


},
"./node_modules/util/support/isBufferBrowser.js"(module) {
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

},
"./node_modules/util/support/types.js"(__unused_rspack_module, exports, __webpack_require__) {
"use strict";
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9



var isArgumentsObject = __webpack_require__("./node_modules/is-arguments/index.js");
var isGeneratorFunction = __webpack_require__("./node_modules/is-generator-function/index.js");
var whichTypedArray = __webpack_require__("./node_modules/which-typed-array/index.js");
var isTypedArray = __webpack_require__("./node_modules/is-typed-array/index.js");

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }

  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});


},
"./node_modules/util/util.js"(__unused_rspack_module, exports, __webpack_require__) {
/* provided dependency */ var process = __webpack_require__("./node_modules/process/browser.js");
/* provided dependency */ var console = __webpack_require__("./node_modules/console-browserify/index.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').slice(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.slice(1, -1);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = __webpack_require__("./node_modules/util/support/types.js");

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__("./node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;


},
"./node_modules/which-typed-array/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var forEach = __webpack_require__("./node_modules/for-each/index.js");
var availableTypedArrays = __webpack_require__("./node_modules/available-typed-arrays/index.js");
var callBind = __webpack_require__("./node_modules/call-bind/index.js");
var callBound = __webpack_require__("./node_modules/call-bound/index.js");
var gOPD = __webpack_require__("./node_modules/gopd/index.js");
var getProto = __webpack_require__("./node_modules/get-proto/index.js");

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = __webpack_require__("./node_modules/has-tostringtag/shams.js")();

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');

/** @type {<T = unknown>(array: readonly T[], value: unknown) => number} */
var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};

/** @typedef {import('./types').Getter} Getter */
/** @type {import('./types').Cache} */
var cache = { __proto__: null };
if (hasToStringTag && gOPD && getProto) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr && getProto) {
			var proto = getProto(arr);
			// @ts-expect-error TS won't narrow inside a closure
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor && proto) {
				var superProto = getProto(proto);
				// @ts-expect-error TS won't narrow inside a closure
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			if (descriptor && descriptor.get) {
				var bound = callBind(descriptor.get);
				cache[
					/** @type {`$${import('.').TypedArrayName}`} */ ('$' + typedArray)
				] = bound;
			}
		}
	});
} else {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		var fn = arr.slice || arr.set;
		if (fn) {
			var bound = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */ (
				// @ts-expect-error TODO FIXME
				callBind(fn)
			);
			cache[
				/** @type {`$${import('.').TypedArrayName}`} */ ('$' + typedArray)
			] = bound;
		}
	});
}

/** @type {(value: object) => false | import('.').TypedArrayName} */
var tryTypedArrays = function tryAllTypedArrays(value) {
	/** @type {ReturnType<typeof tryAllTypedArrays>} */ var found = false;
	forEach(
		/** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */ (cache),
		/** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
		function (getter, typedArray) {
			if (!found) {
				try {
					// @ts-expect-error a throw is fine here
					if ('$' + getter(value) === typedArray) {
						found = /** @type {import('.').TypedArrayName} */ ($slice(typedArray, 1));
					}
				} catch (e) { /**/ }
			}
		}
	);
	return found;
};

/** @type {(value: object) => false | import('.').TypedArrayName} */
var trySlices = function tryAllSlices(value) {
	/** @type {ReturnType<typeof tryAllSlices>} */ var found = false;
	forEach(
		/** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */(cache),
		/** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */ function (getter, name) {
			if (!found) {
				try {
					// @ts-expect-error a throw is fine here
					getter(value);
					found = /** @type {import('.').TypedArrayName} */ ($slice(name, 1));
				} catch (e) { /**/ }
			}
		}
	);
	return found;
};

/** @type {import('.')} */
module.exports = function whichTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag) {
		/** @type {string} */
		var tag = $slice($toString(value), 8, -1);
		if ($indexOf(typedArrays, tag) > -1) {
			return tag;
		}
		if (tag !== 'Object') {
			return false;
		}
		// node < 0.6 hits here on real Typed Arrays
		return trySlices(value);
	}
	if (!gOPD) { return null; } // unknown engine
	return tryTypedArrays(value);
};


},
"./src/enums.ts"(__unused_rspack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  CustomMessageType: () => (CustomMessageType),
  Protocol: () => (Protocol)
});
var Protocol = /*#__PURE__*/ function(Protocol) {
    // Room-related (10~19)
    Protocol[Protocol["HANDSHAKE"] = 9] = "HANDSHAKE";
    Protocol[Protocol["JOIN_ROOM"] = 10] = "JOIN_ROOM";
    Protocol[Protocol["ERROR"] = 11] = "ERROR";
    Protocol[Protocol["LEAVE_ROOM"] = 12] = "LEAVE_ROOM";
    Protocol[Protocol["ROOM_DATA"] = 13] = "ROOM_DATA";
    Protocol[Protocol["ROOM_STATE"] = 14] = "ROOM_STATE";
    Protocol[Protocol["ROOM_STATE_PATCH"] = 15] = "ROOM_STATE_PATCH";
    Protocol[Protocol["ROOM_DATA_SCHEMA"] = 16] = "ROOM_DATA_SCHEMA";
    Protocol[Protocol["ROOM_DATA_BYTES"] = 17] = "ROOM_DATA_BYTES";
    return Protocol;
}({});
var CustomMessageType = /*#__PURE__*/ function(CustomMessageType) {
    CustomMessageType[CustomMessageType["PositionUpdate"] = 43] = "PositionUpdate";
    CustomMessageType[CustomMessageType["Chat"] = 62] = "Chat";
    CustomMessageType[CustomMessageType["UserDataChanged"] = 38] = "UserDataChanged";
    CustomMessageType[CustomMessageType["Ping"] = 30] = "Ping";
    CustomMessageType[CustomMessageType["Pong"] = 31] = "Pong";
    CustomMessageType[CustomMessageType["SceneLoaded"] = 66] = "SceneLoaded";
    CustomMessageType[CustomMessageType["LogInfo"] = 36] = "LogInfo";
    CustomMessageType[CustomMessageType["LogError"] = 79] = "LogError";
    CustomMessageType[CustomMessageType["LogSuccess"] = 46] = "LogSuccess";
    CustomMessageType[CustomMessageType["LogWarning"] = 82] = "LogWarning";
    CustomMessageType[CustomMessageType["Crouch"] = 75] = "Crouch";
    CustomMessageType[CustomMessageType["PlantSeed"] = 59] = "PlantSeed";
    CustomMessageType[CustomMessageType["CollectPlant"] = 56] = "CollectPlant";
    CustomMessageType[CustomMessageType["WaterPlant"] = 35] = "WaterPlant";
    CustomMessageType[CustomMessageType["BuyItem"] = 87] = "BuyItem";
    CustomMessageType[CustomMessageType["SellItem"] = 48] = "SellItem";
    CustomMessageType[CustomMessageType["UseItem"] = 73] = "UseItem";
    CustomMessageType[CustomMessageType["ExpandGarden"] = 65] = "ExpandGarden";
    CustomMessageType[CustomMessageType["RequestHoldItem"] = 86] = "RequestHoldItem";
    CustomMessageType[CustomMessageType["LikeGarden"] = 63] = "LikeGarden";
    CustomMessageType[CustomMessageType["BuyEgg"] = 47] = "BuyEgg";
    CustomMessageType[CustomMessageType["BuyTool"] = 33] = "BuyTool";
    CustomMessageType[CustomMessageType["PlaceEgg"] = 54] = "PlaceEgg";
    CustomMessageType[CustomMessageType["OpenEgg"] = 77] = "OpenEgg";
    CustomMessageType[CustomMessageType["RemoveTree"] = 34] = "RemoveTree";
    CustomMessageType[CustomMessageType["SwapInventorySlots"] = 89] = "SwapInventorySlots";
    CustomMessageType[CustomMessageType["PlacePet"] = 83] = "PlacePet";
    CustomMessageType[CustomMessageType["RemovePet"] = 60] = "RemovePet";
    CustomMessageType[CustomMessageType["GrowAll"] = 78] = "GrowAll";
    CustomMessageType[CustomMessageType["SpinWheel"] = 39] = "SpinWheel";
    CustomMessageType[CustomMessageType["GetWorth"] = 84] = "GetWorth";
    CustomMessageType[CustomMessageType["SendGift"] = 90] = "SendGift";
    CustomMessageType[CustomMessageType["RespondToGift"] = 72] = "RespondToGift";
    CustomMessageType[CustomMessageType["PlaceSprinkler"] = 61] = "PlaceSprinkler";
    CustomMessageType[CustomMessageType["MoveTree"] = 45] = "MoveTree";
    return CustomMessageType;
}({});


},
"./src/schemas.ts"(__unused_rspack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  Egg: () => (Egg),
  Garden: () => (Garden),
  InventoryItem: () => (InventoryItem),
  MyRoomState: () => (MyRoomState),
  Pet: () => (Pet),
  Plant: () => (Plant),
  Player: () => (Player),
  PublicUserData: () => (PublicUserData),
  Sprinkler: () => (Sprinkler)
});
/* import */ var _colyseus_schema__rspack_import_0 = __webpack_require__("./node_modules/@colyseus/schema/build/umd/index.js");
/* import */ var _colyseus_schema__rspack_import_0_default = /*#__PURE__*/__webpack_require__.n(_colyseus_schema__rspack_import_0);
function _assert_this_initialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _call_super(_this, derived, args) {
    derived = _get_prototype_of(derived);
    return _possible_constructor_return(_this, _is_native_reflect_construct() ? Reflect.construct(derived, args || [], _get_prototype_of(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _get_prototype_of(o) {
    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of(o);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of(subClass, superClass);
}
function _possible_constructor_return(self, call) {
    if (call && (_type_of(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized(self);
}
function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of(o, p);
}
function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _is_native_reflect_construct() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct = function() {
        return !!result;
    })();
}
function _ts_decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// remember to update alongside the game
var ColyVector3 = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(ColyVector3, Schema);
    function ColyVector3() {
        _class_call_check(this, ColyVector3);
        var _this;
        _this = _call_super(this, ColyVector3, arguments), _define_property(_this, "x", void 0), _define_property(_this, "y", void 0), _define_property(_this, "z", void 0);
        return _this;
    }
    return ColyVector3;
}(_colyseus_schema__rspack_import_0.Schema);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], ColyVector3.prototype, "x", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], ColyVector3.prototype, "y", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], ColyVector3.prototype, "z", void 0);
var ColyRigid = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(ColyRigid, Schema);
    function ColyRigid() {
        _class_call_check(this, ColyRigid);
        var _this;
        _this = _call_super(this, ColyRigid, arguments), _define_property(_this, "position", void 0), _define_property(_this, "rotationY", void 0), _define_property(_this, "air", void 0);
        return _this;
    }
    return ColyRigid;
}(_colyseus_schema__rspack_import_0.Schema);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)(ColyVector3)
], ColyRigid.prototype, "position", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], ColyRigid.prototype, "rotationY", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("boolean")
], ColyRigid.prototype, "air", void 0);
var InventoryItem = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(InventoryItem, Schema);
    function InventoryItem() {
        _class_call_check(this, InventoryItem);
        var _this;
        _this = _call_super(this, InventoryItem, arguments), _define_property(_this, "id", void 0), _define_property(_this, "type", void 0), _define_property(_this, "amount", void 0), _define_property(_this, "customParam", void 0);
        return _this;
    }
    return InventoryItem;
}(_colyseus_schema__rspack_import_0.Schema);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("int8")
], InventoryItem.prototype, "id", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("string")
], InventoryItem.prototype, "type", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], InventoryItem.prototype, "amount", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], InventoryItem.prototype, "customParam", void 0);
var PublicUserData = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(PublicUserData, Schema);
    function PublicUserData() {
        _class_call_check(this, PublicUserData);
        var _this;
        _this = _call_super(this, PublicUserData, arguments), _define_property(_this, "createdAt", void 0), _define_property(_this, "pfp", void 0), _define_property(_this, "username", void 0);
        return _this;
    }
    return PublicUserData;
}(_colyseus_schema__rspack_import_0.Schema);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("string")
], PublicUserData.prototype, "createdAt", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("string")
], PublicUserData.prototype, "pfp", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("string")
], PublicUserData.prototype, "username", void 0);
var Player = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(Player, Schema);
    function Player() {
        _class_call_check(this, Player);
        var _this;
        _this = _call_super(this, Player, arguments), _define_property(_this, "playerId", void 0), _define_property(_this, "nickname", void 0), _define_property(_this, "userId", void 0), _define_property(_this, "coins", void 0), _define_property(_this, "score", void 0), _define_property(_this, "inventory", new _colyseus_schema__rspack_import_0.MapSchema()), _define_property(_this, "backpackSize", void 0), _define_property(_this, "currentHoldingItem", void 0), _define_property(_this, "stock", new _colyseus_schema__rspack_import_0.MapSchema()), _define_property(_this, "freeSeedStock", new _colyseus_schema__rspack_import_0.ArraySchema()), _define_property(_this, "gems", void 0), _define_property(_this, "skin", void 0), _define_property(_this, "hat", void 0), _define_property(_this, "back", void 0), _define_property(_this, "rigid", void 0), _define_property(_this, "sceneLoaded", void 0), _define_property(_this, "crouching", void 0), _define_property(_this, "party", void 0), _define_property(_this, "user", void 0), _define_property(_this, "startPlayTime", void 0), _define_property(_this, "eggStock", new _colyseus_schema__rspack_import_0.MapSchema()), _define_property(_this, "toolStock", new _colyseus_schema__rspack_import_0.MapSchema()), _define_property(_this, "nextSpinAvailable", void 0);
        return _this;
    }
    return Player;
}(_colyseus_schema__rspack_import_0.Schema);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("string")
], Player.prototype, "playerId", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("string")
], Player.prototype, "nickname", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("string")
], Player.prototype, "userId", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("uint64")
], Player.prototype, "coins", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("uint32")
], Player.prototype, "score", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)({
        map: InventoryItem
    })
], Player.prototype, "inventory", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("uint8")
], Player.prototype, "backpackSize", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("int32")
], Player.prototype, "currentHoldingItem", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)({
        map: "uint32"
    })
], Player.prototype, "stock", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)([
        "uint32"
    ])
], Player.prototype, "freeSeedStock", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], Player.prototype, "gems", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("int16")
], Player.prototype, "skin", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("int16")
], Player.prototype, "hat", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("int16")
], Player.prototype, "back", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)(ColyRigid)
], Player.prototype, "rigid", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("boolean")
], Player.prototype, "sceneLoaded", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("boolean")
], Player.prototype, "crouching", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("string")
], Player.prototype, "party", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)(PublicUserData)
], Player.prototype, "user", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], Player.prototype, "startPlayTime", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)({
        map: "uint8"
    })
], Player.prototype, "eggStock", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)({
        map: "uint32"
    })
], Player.prototype, "toolStock", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], Player.prototype, "nextSpinAvailable", void 0);
var Egg = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(Egg, Schema);
    function Egg() {
        _class_call_check(this, Egg);
        var _this;
        _this = _call_super(this, Egg, arguments), _define_property(_this, "eggId", void 0), _define_property(_this, "id", void 0), _define_property(_this, "placedAt", void 0), _define_property(_this, "x", void 0), _define_property(_this, "y", void 0);
        return _this;
    }
    return Egg;
}(_colyseus_schema__rspack_import_0.Schema);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("uint32")
], Egg.prototype, "eggId", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("int8")
], Egg.prototype, "id", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], Egg.prototype, "placedAt", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], Egg.prototype, "x", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], Egg.prototype, "y", void 0);
var Pet = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(Pet, Schema);
    function Pet() {
        _class_call_check(this, Pet);
        var _this;
        _this = _call_super(this, Pet, arguments), _define_property(_this, "createdAt", void 0), _define_property(_this, "id", void 0), _define_property(_this, "lastCollectAttempt", void 0), _define_property(_this, "petId", void 0), _define_property(_this, "x", void 0), _define_property(_this, "y", void 0);
        return _this;
    }
    return Pet;
}(_colyseus_schema__rspack_import_0.Schema);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], Pet.prototype, "createdAt", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("int8")
], Pet.prototype, "id", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], Pet.prototype, "lastCollectAttempt", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("uint32")
], Pet.prototype, "petId", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], Pet.prototype, "x", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], Pet.prototype, "y", void 0);
var Plant = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(Plant, Schema);
    function Plant() {
        _class_call_check(this, Plant);
        var _this;
        _this = _call_super(this, Plant, arguments), _define_property(_this, "plantId", void 0), _define_property(_this, "seedId", void 0), _define_property(_this, "x", void 0), _define_property(_this, "y", void 0), _define_property(_this, "plantedAt", void 0), _define_property(_this, "mutation", void 0), _define_property(_this, "rot", void 0), _define_property(_this, "weight", void 0), _define_property(_this, "isFruitTree", void 0), _define_property(_this, "treeGrown", void 0), _define_property(_this, "lastFruitSpawn", void 0), _define_property(_this, "fruits", new _colyseus_schema__rspack_import_0.MapSchema());
        return _this;
    }
    return Plant;
}(_colyseus_schema__rspack_import_0.Schema);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("uint32")
], Plant.prototype, "plantId", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("int8")
], Plant.prototype, "seedId", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], Plant.prototype, "x", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], Plant.prototype, "y", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], Plant.prototype, "plantedAt", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("uint16")
], Plant.prototype, "mutation", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("uint8")
], Plant.prototype, "rot", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], Plant.prototype, "weight", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("boolean")
], Plant.prototype, "isFruitTree", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("boolean")
], Plant.prototype, "treeGrown", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], Plant.prototype, "lastFruitSpawn", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)({
        map: Plant
    })
], Plant.prototype, "fruits", void 0);
var Sprinkler = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(Sprinkler, Schema);
    function Sprinkler() {
        _class_call_check(this, Sprinkler);
        var _this;
        _this = _call_super(this, Sprinkler, arguments), _define_property(_this, "sprinklerId", void 0), _define_property(_this, "typeId", void 0), _define_property(_this, "x", void 0), _define_property(_this, "y", void 0), _define_property(_this, "placedAt", void 0), _define_property(_this, "radius", void 0);
        return _this;
    }
    return Sprinkler;
}(_colyseus_schema__rspack_import_0.Schema);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("uint32")
], Sprinkler.prototype, "sprinklerId", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("int16")
], Sprinkler.prototype, "typeId", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], Sprinkler.prototype, "x", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], Sprinkler.prototype, "y", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], Sprinkler.prototype, "placedAt", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("int8")
], Sprinkler.prototype, "radius", void 0);
var Garden = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(Garden, Schema);
    function Garden() {
        _class_call_check(this, Garden);
        var _this;
        _this = _call_super(this, Garden, arguments), _define_property(_this, "ownerId", void 0), _define_property(_this, "width", void 0), _define_property(_this, "height", void 0), _define_property(_this, "likes", void 0), _define_property(_this, "plants", new _colyseus_schema__rspack_import_0.ArraySchema()), _define_property(_this, "pets", new _colyseus_schema__rspack_import_0.ArraySchema()), _define_property(_this, "eggs", new _colyseus_schema__rspack_import_0.ArraySchema()), _define_property(_this, "sprinklers", new _colyseus_schema__rspack_import_0.ArraySchema()), _define_property(_this, "lastWatered", void 0);
        return _this;
    }
    return Garden;
}(_colyseus_schema__rspack_import_0.Schema);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("string")
], Garden.prototype, "ownerId", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("int8")
], Garden.prototype, "width", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("int8")
], Garden.prototype, "height", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("int32")
], Garden.prototype, "likes", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)([
        Plant
    ])
], Garden.prototype, "plants", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)([
        Pet
    ])
], Garden.prototype, "pets", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)([
        Egg
    ])
], Garden.prototype, "eggs", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)([
        Sprinkler
    ])
], Garden.prototype, "sprinklers", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("number")
], Garden.prototype, "lastWatered", void 0);
var MyRoomState = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(MyRoomState, Schema);
    function MyRoomState() {
        _class_call_check(this, MyRoomState);
        var _this;
        _this = _call_super(this, MyRoomState, arguments), _define_property(_this, "players", new _colyseus_schema__rspack_import_0.MapSchema()), _define_property(_this, "gardens", new _colyseus_schema__rspack_import_0.MapSchema()), _define_property(_this, "region", void 0), _define_property(_this, "maxPlayers", void 0), _define_property(_this, "aboutToShutdown", void 0), _define_property(_this, "weather", void 0), _define_property(_this, "seedsInStock", new _colyseus_schema__rspack_import_0.ArraySchema()), _define_property(_this, "toolsInStock", new _colyseus_schema__rspack_import_0.ArraySchema()), _define_property(_this, "currentEvent", void 0);
        return _this;
    }
    return MyRoomState;
}(_colyseus_schema__rspack_import_0.Schema);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)({
        map: Player
    })
], MyRoomState.prototype, "players", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)({
        map: Garden
    })
], MyRoomState.prototype, "gardens", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("int8")
], MyRoomState.prototype, "region", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("int8")
], MyRoomState.prototype, "maxPlayers", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("boolean")
], MyRoomState.prototype, "aboutToShutdown", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("int8")
], MyRoomState.prototype, "weather", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)([
        "uint16"
    ])
], MyRoomState.prototype, "seedsInStock", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)([
        "uint16"
    ])
], MyRoomState.prototype, "toolsInStock", void 0);
_ts_decorate([
    (0,_colyseus_schema__rspack_import_0.type)("int8")
], MyRoomState.prototype, "currentEvent", void 0);


},
"./node_modules/available-typed-arrays/index.js"(module, __unused_rspack_exports, __webpack_require__) {
"use strict";


var possibleNames = __webpack_require__("./node_modules/possible-typed-array-names/index.js");

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;

/** @type {import('.')} */
module.exports = function availableTypedArrays() {
	var /** @type {ReturnType<typeof availableTypedArrays>} */ out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			// @ts-expect-error
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};


},
"./node_modules/@colyseus/msgpackr/index.js"(__unused_rspack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  ALWAYS: () => (/* reexport safe */ _pack_js__rspack_import_0.ALWAYS),
  C1: () => (/* reexport safe */ _unpack_js__rspack_import_1.C1),
  DECIMAL_FIT: () => (/* reexport safe */ _pack_js__rspack_import_0.DECIMAL_FIT),
  DECIMAL_ROUND: () => (/* reexport safe */ _pack_js__rspack_import_0.DECIMAL_ROUND),
  Decoder: () => (/* reexport safe */ _unpack_js__rspack_import_1.Decoder),
  Encoder: () => (/* reexport safe */ _pack_js__rspack_import_0.Encoder),
  FLOAT32_OPTIONS: () => (/* reexport safe */ _unpack_js__rspack_import_1.FLOAT32_OPTIONS),
  NEVER: () => (/* reexport safe */ _pack_js__rspack_import_0.NEVER),
  Packr: () => (/* reexport safe */ _pack_js__rspack_import_0.Packr),
  RESERVE_START_SPACE: () => (/* reexport safe */ _pack_js__rspack_import_0.RESERVE_START_SPACE),
  RESET_BUFFER_MODE: () => (/* reexport safe */ _pack_js__rspack_import_0.RESET_BUFFER_MODE),
  REUSE_BUFFER_MODE: () => (/* reexport safe */ _pack_js__rspack_import_0.REUSE_BUFFER_MODE),
  Unpackr: () => (/* reexport safe */ _unpack_js__rspack_import_1.Unpackr),
  addExtension: () => (/* reexport safe */ _pack_js__rspack_import_0.addExtension),
  clearSource: () => (/* reexport safe */ _unpack_js__rspack_import_1.clearSource),
  decode: () => (/* reexport safe */ _unpack_js__rspack_import_1.decode),
  decodeIter: () => (/* reexport safe */ _iterators_js__rspack_import_2.decodeIter),
  encode: () => (/* reexport safe */ _pack_js__rspack_import_0.encode),
  encodeIter: () => (/* reexport safe */ _iterators_js__rspack_import_2.encodeIter),
  isNativeAccelerationEnabled: () => (/* reexport safe */ _unpack_js__rspack_import_1.isNativeAccelerationEnabled),
  mapsAsObjects: () => (mapsAsObjects),
  pack: () => (/* reexport safe */ _pack_js__rspack_import_0.pack),
  roundFloat32: () => (/* reexport safe */ _unpack_js__rspack_import_1.roundFloat32),
  unpack: () => (/* reexport safe */ _unpack_js__rspack_import_1.unpack),
  unpackMultiple: () => (/* reexport safe */ _unpack_js__rspack_import_1.unpackMultiple),
  useRecords: () => (useRecords)
});
/* import */ var _pack_js__rspack_import_0 = __webpack_require__("./node_modules/@colyseus/msgpackr/pack.js");
/* import */ var _unpack_js__rspack_import_1 = __webpack_require__("./node_modules/@colyseus/msgpackr/unpack.js");
/* import */ var _iterators_js__rspack_import_2 = __webpack_require__("./node_modules/@colyseus/msgpackr/iterators.js");



const useRecords = false
const mapsAsObjects = true


},
"./node_modules/@colyseus/msgpackr/iterators.js"(__unused_rspack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  decodeIter: () => (decodeIter),
  encodeIter: () => (encodeIter),
  packIter: () => (packIter),
  unpackIter: () => (unpackIter)
});
/* import */ var _pack_js__rspack_import_0 = __webpack_require__("./node_modules/@colyseus/msgpackr/pack.js");
/* import */ var _unpack_js__rspack_import_1 = __webpack_require__("./node_modules/@colyseus/msgpackr/unpack.js");
/* provided dependency */ var Buffer = __webpack_require__("./node_modules/buffer/index.js")["Buffer"];



/**
 * Given an Iterable first argument, returns an Iterable where each value is packed as a Buffer
 * If the argument is only Async Iterable, the return value will be an Async Iterable.
 * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object
 * @param {options} [options] - msgpackr pack options
 * @returns {IterableIterator|Promise.<AsyncIterableIterator>}
 */
function packIter (objectIterator, options = {}) {
  if (!objectIterator || typeof objectIterator !== 'object') {
    throw new Error('first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable')
  } else if (typeof objectIterator[Symbol.iterator] === 'function') {
    return packIterSync(objectIterator, options)
  } else if (typeof objectIterator.then === 'function' || typeof objectIterator[Symbol.asyncIterator] === 'function') {
    return packIterAsync(objectIterator, options)
  } else {
    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise')
  }
}

function * packIterSync (objectIterator, options) {
  const packr = new _pack_js__rspack_import_0.Packr(options)
  for (const value of objectIterator) {
    yield packr.pack(value)
  }
}

async function * packIterAsync (objectIterator, options) {
  const packr = new _pack_js__rspack_import_0.Packr(options)
  for await (const value of objectIterator) {
    yield packr.pack(value)
  }
}

/**
 * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects
 * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.
 * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator
 * @param {object} [options] - unpackr options
 * @returns {IterableIterator|Promise.<AsyncIterableIterator}
 */
function unpackIter (bufferIterator, options = {}) {
  if (!bufferIterator || typeof bufferIterator !== 'object') {
    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise')
  }

  const unpackr = new _unpack_js__rspack_import_1.Unpackr(options)
  let incomplete
  const parser = (chunk) => {
    let yields
    // if there's incomplete data from previous chunk, concatinate and try again
    if (incomplete) {
      chunk = Buffer.concat([incomplete, chunk])
      incomplete = undefined
    }

    try {
      yields = unpackr.unpackMultiple(chunk)
    } catch (err) {
      if (err.incomplete) {
        incomplete = chunk.slice(err.lastPosition)
        yields = err.values
      } else {
        throw err
      }
    }
    return yields
  }

  if (typeof bufferIterator[Symbol.iterator] === 'function') {
    return (function * iter () {
      for (const value of bufferIterator) {
        yield * parser(value)
      }
    })()
  } else if (typeof bufferIterator[Symbol.asyncIterator] === 'function') {
    return (async function * iter () {
      for await (const value of bufferIterator) {
        yield * parser(value)
      }
    })()
  }
}
const decodeIter = unpackIter
const encodeIter = packIter

},
"./node_modules/@colyseus/msgpackr/pack.js"(__unused_rspack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  ALWAYS: () => (ALWAYS),
  DECIMAL_FIT: () => (DECIMAL_FIT),
  DECIMAL_ROUND: () => (DECIMAL_ROUND),
  Encoder: () => (Encoder),
  FLOAT32_OPTIONS: () => (/* reexport safe */ _unpack_js__rspack_import_0.FLOAT32_OPTIONS),
  NEVER: () => (NEVER),
  Packr: () => (Packr),
  RECORD_SYMBOL: () => (RECORD_SYMBOL),
  RESERVE_START_SPACE: () => (RESERVE_START_SPACE),
  RESET_BUFFER_MODE: () => (RESET_BUFFER_MODE),
  REUSE_BUFFER_MODE: () => (REUSE_BUFFER_MODE),
  addExtension: () => (addExtension),
  encode: () => (encode),
  pack: () => (pack),
  setWriteStructSlots: () => (setWriteStructSlots)
});
/* import */ var _unpack_js__rspack_import_0 = __webpack_require__("./node_modules/@colyseus/msgpackr/unpack.js");
/* provided dependency */ var Buffer = __webpack_require__("./node_modules/buffer/index.js")["Buffer"];

let textEncoder
try {
	textEncoder = new TextEncoder()
} catch (error) {}
let extensions, extensionClasses
const hasNodeBuffer = typeof Buffer !== 'undefined'
const ByteArrayAllocate = hasNodeBuffer ?
	function(length) { return Buffer.allocUnsafeSlow(length) } : Uint8Array
const ByteArray = hasNodeBuffer ? Buffer : Uint8Array
const MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000
let target, keysTarget
let targetView
let position = 0
let safeEnd
let bundledStrings = null
let writeStructSlots
const MAX_BUNDLE_SIZE = 0x5500 // maximum characters such that the encoded bytes fits in 16 bits.
const hasNonLatin = /[\u0080-\uFFFF]/
const RECORD_SYMBOL = Symbol('record-id')
class Packr extends _unpack_js__rspack_import_0.Unpackr {
	constructor(options) {
		super(options)
		this.offset = 0
		let typeBuffer
		let start
		let hasSharedUpdate
		let structures
		let referenceMap
		let encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {
			return target.utf8Write(string, position, target.byteLength - position)
		} : (textEncoder && textEncoder.encodeInto) ?
			function(string, position) {
				return textEncoder.encodeInto(string, target.subarray(position)).written
			} : false

		let packr = this
		if (!options)
			options = {}
		let isSequential = options && options.sequential
		let hasSharedStructures = options.structures || options.saveStructures
		let maxSharedStructures = options.maxSharedStructures
		if (maxSharedStructures == null)
			maxSharedStructures = hasSharedStructures ? 32 : 0
		if (maxSharedStructures > 8160)
			throw new Error('Maximum maxSharedStructure is 8160')
		if (options.structuredClone && options.moreTypes == undefined) {
			this.moreTypes = true
		}
		let maxOwnStructures = options.maxOwnStructures
		if (maxOwnStructures == null)
			maxOwnStructures = hasSharedStructures ? 32 : 64
		if (!this.structures && options.useRecords != false)
			this.structures = []
		// two byte record ids for shared structures
		let useTwoByteRecords = maxSharedStructures > 32 || (maxOwnStructures + maxSharedStructures > 64)
		let sharedLimitId = maxSharedStructures + 0x40
		let maxStructureId = maxSharedStructures + maxOwnStructures + 0x40
		if (maxStructureId > 8256) {
			throw new Error('Maximum maxSharedStructure + maxOwnStructure is 8192')
		}
		let recordIdsToRemove = []
		let transitionsCount = 0
		let serializationsSinceTransitionRebuild = 0

		this.pack = this.encode = function(value, encodeOptions) {
			if (!target) {
				target = new ByteArrayAllocate(8192)
				targetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192))
				position = 0
			}
			safeEnd = target.length - 10
			if (safeEnd - position < 0x800) {
				// don't start too close to the end,
				target = new ByteArrayAllocate(target.length)
				targetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length))
				safeEnd = target.length - 10
				position = 0
			} else
				position = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster
			start = position
			if (encodeOptions & RESERVE_START_SPACE) position += (encodeOptions & 0xff)
			referenceMap = packr.structuredClone ? new Map() : null
			if (packr.bundleStrings && typeof value !== 'string') {
				bundledStrings = []
				bundledStrings.size = Infinity // force a new bundle start on first string
			} else
				bundledStrings = null
			structures = packr.structures
			if (structures) {
				if (structures.uninitialized)
					structures = packr._mergeStructures(packr.getStructures())
				let sharedLength = structures.sharedLength || 0
				if (sharedLength > maxSharedStructures) {
					//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids
					throw new Error('Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to ' + structures.sharedLength)
				}
				if (!structures.transitions) {
					// rebuild our structure transitions
					structures.transitions = Object.create(null)
					for (let i = 0; i < sharedLength; i++) {
						let keys = structures[i]
						if (!keys)
							continue
						let nextTransition, transition = structures.transitions
						for (let j = 0, l = keys.length; j < l; j++) {
							let key = keys[j]
							nextTransition = transition[key]
							if (!nextTransition) {
								nextTransition = transition[key] = Object.create(null)
							}
							transition = nextTransition
						}
						transition[RECORD_SYMBOL] = i + 0x40
					}
					this.lastNamedStructuresLength = sharedLength
				}
				if (!isSequential) {
					structures.nextId = sharedLength + 0x40
				}
			}
			if (hasSharedUpdate)
				hasSharedUpdate = false
			let encodingError;
			try {
				if (packr.randomAccessStructure && value && value.constructor && value.constructor === Object)
					writeStruct(value);
				else
					pack(value)
				let lastBundle = bundledStrings;
				if (bundledStrings)
					writeBundles(start, pack, 0)
				if (referenceMap && referenceMap.idsToInsert) {
					let idsToInsert = referenceMap.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);
					let i = idsToInsert.length;
					let incrementPosition = -1;
					while (lastBundle && i > 0) {
						let insertionPoint = idsToInsert[--i].offset + start;
						if (insertionPoint < (lastBundle.stringsPosition + start) && incrementPosition === -1)
							incrementPosition = 0;
						if (insertionPoint > (lastBundle.position + start)) {
							if (incrementPosition >= 0)
								incrementPosition += 6;
						} else {
							if (incrementPosition >= 0) {
								// update the bundle reference now
								targetView.setUint32(lastBundle.position + start,
									targetView.getUint32(lastBundle.position + start) + incrementPosition)
								incrementPosition = -1; // reset
							}
							lastBundle = lastBundle.previous;
							i++;
						}
					}
					if (incrementPosition >= 0 && lastBundle) {
						// update the bundle reference now
						targetView.setUint32(lastBundle.position + start,
							targetView.getUint32(lastBundle.position + start) + incrementPosition)
					}
					position += idsToInsert.length * 6;
					if (position > safeEnd)
						makeRoom(position)
					packr.offset = position
					let serialized = insertIds(target.subarray(start, position), idsToInsert)
					referenceMap = null
					return serialized
				}
				packr.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially
				if (encodeOptions & REUSE_BUFFER_MODE) {
					target.start = start
					target.end = position
					return target
				}
				return target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now
			} catch(error) {
				encodingError = error;
				throw error;
			} finally {
				if (structures) {
					resetStructures();
					if (hasSharedUpdate && packr.saveStructures) {
						let sharedLength = structures.sharedLength || 0
						// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save
						let returnBuffer = target.subarray(start, position)
						let newSharedData = prepareStructures(structures, packr);
						if (!encodingError) { // TODO: If there is an encoding error, should make the structures as uninitialized so they get rebuilt next time
							if (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {
								// get updated structures and try again if the update failed
								return packr.pack(value, encodeOptions)
							}
							packr.lastNamedStructuresLength = sharedLength
							// don't keep large buffers around
							if (target.length > 0x40000000) target = null
							return returnBuffer
						}
					}
				}
				// don't keep large buffers around, they take too much memory and cause problems (limit at 1GB)
				if (target.length > 0x40000000) target = null
				if (encodeOptions & RESET_BUFFER_MODE)
					position = start
			}
		}
		const resetStructures = () => {
			if (serializationsSinceTransitionRebuild < 10)
				serializationsSinceTransitionRebuild++
			let sharedLength = structures.sharedLength || 0
			if (structures.length > sharedLength && !isSequential)
				structures.length = sharedLength
			if (transitionsCount > 10000) {
				// force a rebuild occasionally after a lot of transitions so it can get cleaned up
				structures.transitions = null
				serializationsSinceTransitionRebuild = 0
				transitionsCount = 0
				if (recordIdsToRemove.length > 0)
					recordIdsToRemove = []
			} else if (recordIdsToRemove.length > 0 && !isSequential) {
				for (let i = 0, l = recordIdsToRemove.length; i < l; i++) {
					recordIdsToRemove[i][RECORD_SYMBOL] = 0
				}
				recordIdsToRemove = []
			}
		}
		const packArray = (value) => {
			var length = value.length
			if (length < 0x10) {
				target[position++] = 0x90 | length
			} else if (length < 0x10000) {
				target[position++] = 0xdc
				target[position++] = length >> 8
				target[position++] = length & 0xff
			} else {
				target[position++] = 0xdd
				targetView.setUint32(position, length)
				position += 4
			}
			for (let i = 0; i < length; i++) {
				pack(value[i])
			}
		}
		const pack = (value) => {
			if (position > safeEnd)
				target = makeRoom(position)

			var type = typeof value
			var length
			if (type === 'string') {
				let strLength = value.length
				if (bundledStrings && strLength >= 4 && strLength < 0x1000) {
					if ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {
						let extStart
						let maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10
						if (position + maxBytes > safeEnd)
							target = makeRoom(position + maxBytes)
						let lastBundle
						if (bundledStrings.position) { // here we use the 0x62 extension to write the last bundle and reserve space for the reference pointer to the next/current bundle
							lastBundle = bundledStrings
							target[position] = 0xc8 // ext 16
							position += 3 // reserve for the writing bundle size
							target[position++] = 0x62 // 'b'
							extStart = position - start
							position += 4 // reserve for writing bundle reference
							writeBundles(start, pack, 0) // write the last bundles
							targetView.setUint16(extStart + start - 3, position - start - extStart)
						} else { // here we use the 0x62 extension just to reserve the space for the reference pointer to the bundle (will be updated once the bundle is written)
							target[position++] = 0xd6 // fixext 4
							target[position++] = 0x62 // 'b'
							extStart = position - start
							position += 4 // reserve for writing bundle reference
						}
						bundledStrings = ['', ''] // create new ones
						bundledStrings.previous = lastBundle;
						bundledStrings.size = 0
						bundledStrings.position = extStart
					}
					let twoByte = hasNonLatin.test(value)
					bundledStrings[twoByte ? 0 : 1] += value
					target[position++] = 0xc1
					pack(twoByte ? -strLength : strLength);
					return
				}
				let headerSize
				// first we estimate the header size, so we can write to the correct location
				if (strLength < 0x20) {
					headerSize = 1
				} else if (strLength < 0x100) {
					headerSize = 2
				} else if (strLength < 0x10000) {
					headerSize = 3
				} else {
					headerSize = 5
				}
				let maxBytes = strLength * 3
				if (position + maxBytes > safeEnd)
					target = makeRoom(position + maxBytes)

				if (strLength < 0x40 || !encodeUtf8) {
					let i, c1, c2, strPosition = position + headerSize
					for (i = 0; i < strLength; i++) {
						c1 = value.charCodeAt(i)
						if (c1 < 0x80) {
							target[strPosition++] = c1
						} else if (c1 < 0x800) {
							target[strPosition++] = c1 >> 6 | 0xc0
							target[strPosition++] = c1 & 0x3f | 0x80
						} else if (
							(c1 & 0xfc00) === 0xd800 &&
							((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00
						) {
							c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)
							i++
							target[strPosition++] = c1 >> 18 | 0xf0
							target[strPosition++] = c1 >> 12 & 0x3f | 0x80
							target[strPosition++] = c1 >> 6 & 0x3f | 0x80
							target[strPosition++] = c1 & 0x3f | 0x80
						} else {
							target[strPosition++] = c1 >> 12 | 0xe0
							target[strPosition++] = c1 >> 6 & 0x3f | 0x80
							target[strPosition++] = c1 & 0x3f | 0x80
						}
					}
					length = strPosition - position - headerSize
				} else {
					length = encodeUtf8(value, position + headerSize)
				}

				if (length < 0x20) {
					target[position++] = 0xa0 | length
				} else if (length < 0x100) {
					if (headerSize < 2) {
						target.copyWithin(position + 2, position + 1, position + 1 + length)
					}
					target[position++] = 0xd9
					target[position++] = length
				} else if (length < 0x10000) {
					if (headerSize < 3) {
						target.copyWithin(position + 3, position + 2, position + 2 + length)
					}
					target[position++] = 0xda
					target[position++] = length >> 8
					target[position++] = length & 0xff
				} else {
					if (headerSize < 5) {
						target.copyWithin(position + 5, position + 3, position + 3 + length)
					}
					target[position++] = 0xdb
					targetView.setUint32(position, length)
					position += 4
				}
				position += length
			} else if (type === 'number') {
				if (value >>> 0 === value) {// positive integer, 32-bit or less
					// positive uint
					if (value < 0x20 || (value < 0x80 && this.useRecords === false) || (value < 0x40 && !this.randomAccessStructure)) {
						target[position++] = value
					} else if (value < 0x100) {
						target[position++] = 0xcc
						target[position++] = value
					} else if (value < 0x10000) {
						target[position++] = 0xcd
						target[position++] = value >> 8
						target[position++] = value & 0xff
					} else {
						target[position++] = 0xce
						targetView.setUint32(position, value)
						position += 4
					}
				} else if (value >> 0 === value) { // negative integer
					if (value >= -0x20) {
						target[position++] = 0x100 + value
					} else if (value >= -0x80) {
						target[position++] = 0xd0
						target[position++] = value + 0x100
					} else if (value >= -0x8000) {
						target[position++] = 0xd1
						targetView.setInt16(position, value)
						position += 2
					} else {
						target[position++] = 0xd2
						targetView.setInt32(position, value)
						position += 4
					}
				} else {
					let useFloat32
					if ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {
						target[position++] = 0xca
						targetView.setFloat32(position, value)
						let xShifted
						if (useFloat32 < 4 ||
								// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
								((xShifted = value * _unpack_js__rspack_import_0.mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {
							position += 4
							return
						} else
							position-- // move back into position for writing a double
					}
					target[position++] = 0xcb
					targetView.setFloat64(position, value)
					position += 8
				}
			} else if (type === 'object' || type === 'function') {
				if (!value)
					target[position++] = 0xc0
				else {
					if (referenceMap) {
						let referee = referenceMap.get(value)
						if (referee) {
							if (!referee.id) {
								let idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])
								referee.id = idsToInsert.push(referee)
							}
							target[position++] = 0xd6 // fixext 4
							target[position++] = 0x70 // "p" for pointer
							targetView.setUint32(position, referee.id)
							position += 4
							return
						} else
							referenceMap.set(value, { offset: position - start })
					}
					let constructor = value.constructor
					if (constructor === Object) {
						writeObject(value)
					} else if (constructor === Array) {
						packArray(value)
					} else if (constructor === Map) {
						if (this.mapAsEmptyObject) target[position++] = 0x80
						else {
							length = value.size
							if (length < 0x10) {
								target[position++] = 0x80 | length
							} else if (length < 0x10000) {
								target[position++] = 0xde
								target[position++] = length >> 8
								target[position++] = length & 0xff
							} else {
								target[position++] = 0xdf
								targetView.setUint32(position, length)
								position += 4
							}
							for (let [key, entryValue] of value) {
								pack(key)
								pack(entryValue)
							}
						}
					} else {
						for (let i = 0, l = extensions.length; i < l; i++) {
							let extensionClass = extensionClasses[i]
							if (value instanceof extensionClass) {
								let extension = extensions[i]
								if (extension.write) {
									if (extension.type) {
										target[position++] = 0xd4 // one byte "tag" extension
										target[position++] = extension.type
										target[position++] = 0
									}
									let writeResult = extension.write.call(this, value)
									if (writeResult === value) { // avoid infinite recursion
										if (Array.isArray(value)) {
											packArray(value)
										} else {
											writeObject(value)
										}
									} else {
										pack(writeResult)
									}
									return
								}
								let currentTarget = target
								let currentTargetView = targetView
								let currentPosition = position
								target = null
								let result
								try {
									result = extension.pack.call(this, value, (size) => {
										// restore target and use it
										target = currentTarget
										currentTarget = null
										position += size
										if (position > safeEnd)
											makeRoom(position)
										return {
											target, targetView, position: position - size
										}
									}, pack)
								} finally {
									// restore current target information (unless already restored)
									if (currentTarget) {
										target = currentTarget
										targetView = currentTargetView
										position = currentPosition
										safeEnd = target.length - 10
									}
								}
								if (result) {
									if (result.length + position > safeEnd)
										makeRoom(result.length + position)
									position = writeExtensionData(result, target, position, extension.type)
								}
								return
							}
						}
						// check isArray after extensions, because extensions can extend Array
						if (Array.isArray(value)) {
							packArray(value)
						} else {
							// use this as an alternate mechanism for expressing how to serialize
							if (value.toJSON) {
								const json = value.toJSON()
								// if for some reason value.toJSON returns itself it'll loop forever
								if (json !== value)
									return pack(json)
							}

							// if there is a writeFunction, use it, otherwise just encode as undefined
							if (type === 'function')
								return pack(this.writeFunction && this.writeFunction(value));

							// no extension found, write as plain object
							writeObject(value)
						}
					}
				}
			} else if (type === 'boolean') {
				target[position++] = value ? 0xc3 : 0xc2
			} else if (type === 'bigint') {
				if (value < (BigInt(1)<<BigInt(63)) && value >= -(BigInt(1)<<BigInt(63))) {
					// use a signed int as long as it fits
					target[position++] = 0xd3
					targetView.setBigInt64(position, value)
				} else if (value < (BigInt(1)<<BigInt(64)) && value > 0) {
					// if we can fit an unsigned int, use that
					target[position++] = 0xcf
					targetView.setBigUint64(position, value)
				} else {
					// overflow
					if (this.largeBigIntToFloat) {
						target[position++] = 0xcb
						targetView.setFloat64(position, Number(value))
					} else if (this.largeBigIntToString) {
						return pack(value.toString());
					} else if (this.useBigIntExtension && value < BigInt(2)**BigInt(1023) && value > -(BigInt(2)**BigInt(1023))) {
						target[position++] = 0xc7
						position++;
						target[position++] = 0x42 // "B" for BigInt
						let bytes = [];
						let alignedSign;
						do {
							let byte = value & BigInt(0xff);
							alignedSign = (byte & BigInt(0x80)) === (value < BigInt(0) ? BigInt(0x80) : BigInt(0));
							bytes.push(byte);
							value >>= BigInt(8);
						} while (!((value === BigInt(0) || value === BigInt(-1)) && alignedSign));
						target[position-2] = bytes.length;
						for (let i = bytes.length; i > 0;) {
							target[position++] = Number(bytes[--i]);
						}
						return
					} else {
						throw new RangeError(value + ' was too large to fit in MessagePack 64-bit integer format, use' +
							' useBigIntExtension, or set largeBigIntToFloat to convert to float-64, or set' +
							' largeBigIntToString to convert to string')
					}
				}
				position += 8
			} else if (type === 'undefined') {
				if (this.encodeUndefinedAsNil)
					target[position++] = 0xc0
				else {
					target[position++] = 0xd4 // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite
					target[position++] = 0
					target[position++] = 0
				}
			} else {
				throw new Error('Unknown type: ' + type)
			}
		}

		const writePlainObject = (this.variableMapSize || this.coercibleKeyAsNumber || this.skipValues) ? (object) => {
			// this method is slightly slower, but generates "preferred serialization" (optimally small for smaller objects)
			let keys;
			if (this.skipValues) {
				keys = [];
				for (let key in object) {
					if ((typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) &&
						!this.skipValues.includes(object[key]))
						keys.push(key);
				}
			} else {
				keys = Object.keys(object)
			}
			let length = keys.length
			if (length < 0x10) {
				target[position++] = 0x80 | length
			} else if (length < 0x10000) {
				target[position++] = 0xde
				target[position++] = length >> 8
				target[position++] = length & 0xff
			} else {
				target[position++] = 0xdf
				targetView.setUint32(position, length)
				position += 4
			}
			let key
			if (this.coercibleKeyAsNumber) {
				for (let i = 0; i < length; i++) {
					key = keys[i]
					let num = Number(key)
					pack(isNaN(num) ? key : num)
					pack(object[key])
				}

			} else {
				for (let i = 0; i < length; i++) {
					pack(key = keys[i])
					pack(object[key])
				}
			}
		} :
		(object) => {
			target[position++] = 0xde // always using map 16, so we can preallocate and set the length afterwards
			let objectOffset = position - start
			position += 2
			let size = 0
			for (let key in object) {
				if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {
					pack(key)
					pack(object[key])
					size++
				}
			}
			if (size > 0xffff) {
				throw new Error('Object is too large to serialize with fast 16-bit map size,' +
				' use the "variableMapSize" option to serialize this object');
			}
			target[objectOffset++ + start] = size >> 8
			target[objectOffset + start] = size & 0xff
		}

		const writeRecord = this.useRecords === false ? writePlainObject :
		(options.progressiveRecords && !useTwoByteRecords) ?  // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)
		(object) => {
			let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))
			let objectOffset = position++ - start
			let wroteKeys
			for (let key in object) {
				if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {
					nextTransition = transition[key]
					if (nextTransition)
						transition = nextTransition
					else {
						// record doesn't exist, create full new record and insert it
						let keys = Object.keys(object)
						let lastTransition = transition
						transition = structures.transitions
						let newTransitions = 0
						for (let i = 0, l = keys.length; i < l; i++) {
							let key = keys[i]
							nextTransition = transition[key]
							if (!nextTransition) {
								nextTransition = transition[key] = Object.create(null)
								newTransitions++
							}
							transition = nextTransition
						}
						if (objectOffset + start + 1 == position) {
							// first key, so we don't need to insert, we can just write record directly
							position--
							newRecord(transition, keys, newTransitions)
						} else // otherwise we need to insert the record, moving existing data after the record
							insertNewRecord(transition, keys, objectOffset, newTransitions)
						wroteKeys = true
						transition = lastTransition[key]
					}
					pack(object[key])
				}
			}
			if (!wroteKeys) {
				let recordId = transition[RECORD_SYMBOL]
				if (recordId)
					target[objectOffset + start] = recordId
				else
					insertNewRecord(transition, Object.keys(object), objectOffset, 0)
			}
		} :
		(object) => {
			let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))
			let newTransitions = 0
			for (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {
				nextTransition = transition[key]
				if (!nextTransition) {
					nextTransition = transition[key] = Object.create(null)
					newTransitions++
				}
				transition = nextTransition
			}
			let recordId = transition[RECORD_SYMBOL]
			if (recordId) {
				if (recordId >= 0x60 && useTwoByteRecords) {
					target[position++] = ((recordId -= 0x60) & 0x1f) + 0x60
					target[position++] = recordId >> 5
				} else
					target[position++] = recordId
			} else {
				newRecord(transition, transition.__keys__ || Object.keys(object), newTransitions)
			}
			// now write the values
			for (let key in object)
				if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {
					pack(object[key])
				}
		}

		// create reference to useRecords if useRecords is a function
		const checkUseRecords = typeof this.useRecords == 'function' && this.useRecords;

		const writeObject = checkUseRecords ? (object) => {
			checkUseRecords(object) ? writeRecord(object) : writePlainObject(object)
		} : writeRecord

		const makeRoom = (end) => {
			let newSize
			if (end > 0x1000000) {
				// special handling for really large buffers
				if ((end - start) > MAX_BUFFER_SIZE)
					throw new Error('Packed buffer would be larger than maximum buffer size')
				newSize = Math.min(MAX_BUFFER_SIZE,
					Math.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)
			} else // faster handling for smaller buffers
				newSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12
			let newBuffer = new ByteArrayAllocate(newSize)
			targetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize))
			end = Math.min(end, target.length)
			if (target.copy)
				target.copy(newBuffer, 0, start, end)
			else
				newBuffer.set(target.slice(start, end))
			position -= start
			start = 0
			safeEnd = newBuffer.length - 10
			return target = newBuffer
		}
		const newRecord = (transition, keys, newTransitions) => {
			let recordId = structures.nextId
			if (!recordId)
				recordId = 0x40
			if (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {
				recordId = structures.nextOwnId
				if (!(recordId < maxStructureId))
					recordId = sharedLimitId
				structures.nextOwnId = recordId + 1
			} else {
				if (recordId >= maxStructureId)// cycle back around
					recordId = sharedLimitId
				structures.nextId = recordId + 1
			}
			let highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? (recordId - 0x60) >> 5 : -1
			transition[RECORD_SYMBOL] = recordId
			transition.__keys__ = keys
			structures[recordId - 0x40] = keys

			if (recordId < sharedLimitId) {
				keys.isShared = true
				structures.sharedLength = recordId - 0x3f
				hasSharedUpdate = true
				if (highByte >= 0) {
					target[position++] = (recordId & 0x1f) + 0x60
					target[position++] = highByte
				} else {
					target[position++] = recordId
				}
			} else {
				if (highByte >= 0) {
					target[position++] = 0xd5 // fixext 2
					target[position++] = 0x72 // "r" record defintion extension type
					target[position++] = (recordId & 0x1f) + 0x60
					target[position++] = highByte
				} else {
					target[position++] = 0xd4 // fixext 1
					target[position++] = 0x72 // "r" record defintion extension type
					target[position++] = recordId
				}

				if (newTransitions)
					transitionsCount += serializationsSinceTransitionRebuild * newTransitions
				// record the removal of the id, we can maintain our shared structure
				if (recordIdsToRemove.length >= maxOwnStructures)
					recordIdsToRemove.shift()[RECORD_SYMBOL] = 0 // we are cycling back through, and have to remove old ones
				recordIdsToRemove.push(transition)
				pack(keys)
			}
		}
		const insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {
			let mainTarget = target
			let mainPosition = position
			let mainSafeEnd = safeEnd
			let mainStart = start
			target = keysTarget
			position = 0
			start = 0
			if (!target)
				keysTarget = target = new ByteArrayAllocate(8192)
			safeEnd = target.length - 10
			newRecord(transition, keys, newTransitions)
			keysTarget = target
			let keysPosition = position
			target = mainTarget
			position = mainPosition
			safeEnd = mainSafeEnd
			start = mainStart
			if (keysPosition > 1) {
				let newEnd = position + keysPosition - 1
				if (newEnd > safeEnd)
					makeRoom(newEnd)
				let insertionPosition = insertionOffset + start
				target.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position)
				target.set(keysTarget.slice(0, keysPosition), insertionPosition)
				position = newEnd
			} else {
				target[insertionOffset + start] = keysTarget[0]
			}
		}
		const writeStruct = (object) => {
			let newPosition = writeStructSlots(object, target, start, position, structures, makeRoom, (value, newPosition, notifySharedUpdate) => {
				if (notifySharedUpdate)
					return hasSharedUpdate = true;
				position = newPosition;
				let startTarget = target;
				pack(value);
				resetStructures();
				if (startTarget !== target) {
					return { position, targetView, target }; // indicate the buffer was re-allocated
				}
				return position;
			}, this);
			if (newPosition === 0) // bail and go to a msgpack object
				return writeObject(object);
			position = newPosition;
		}
	}
	useBuffer(buffer) {
		// this means we are finished using our own buffer and we can write over it safely
		target = buffer
		target.dataView || (target.dataView = new DataView(target.buffer, target.byteOffset, target.byteLength))
		position = 0
	}
	set position (value) {
		position = value;
	}
	get position() {
		return position;
	}
	set buffer (buffer) {
		target = buffer;
	}
	get buffer () {
		return target;
	}
	clearSharedData() {
		if (this.structures)
			this.structures = []
		if (this.typedStructs)
			this.typedStructs = []
	}
}

extensionClasses = [ Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/, _unpack_js__rspack_import_0.C1Type ]
extensions = [{
	pack(date, allocateForWrite, pack) {
		let seconds = date.getTime() / 1000
		if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {
			// Timestamp 32
			let { target, targetView, position} = allocateForWrite(6)
			target[position++] = 0xd6
			target[position++] = 0xff
			targetView.setUint32(position, seconds)
		} else if (seconds > 0 && seconds < 0x100000000) {
			// Timestamp 64
			let { target, targetView, position} = allocateForWrite(10)
			target[position++] = 0xd7
			target[position++] = 0xff
			targetView.setUint32(position, date.getMilliseconds() * 4000000 + ((seconds / 1000 / 0x100000000) >> 0))
			targetView.setUint32(position + 4, seconds)
		} else if (isNaN(seconds)) {
			if (this.onInvalidDate) {
				allocateForWrite(0)
				return pack(this.onInvalidDate())
			}
			// Intentionally invalid timestamp
			let { target, targetView, position} = allocateForWrite(3)
			target[position++] = 0xd4
			target[position++] = 0xff
			target[position++] = 0xff
		} else {
			// Timestamp 96
			let { target, targetView, position} = allocateForWrite(15)
			target[position++] = 0xc7
			target[position++] = 12
			target[position++] = 0xff
			targetView.setUint32(position, date.getMilliseconds() * 1000000)
			targetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)))
		}
	}
}, {
	pack(set, allocateForWrite, pack) {
		if (this.setAsEmptyObject) {
			allocateForWrite(0);
			return pack({})
		}
		let array = Array.from(set)
		let { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)
		if (this.moreTypes) {
			target[position++] = 0xd4
			target[position++] = 0x73 // 's' for Set
			target[position++] = 0
		}
		pack(array)
	}
}, {
	pack(error, allocateForWrite, pack) {
		let { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)
		if (this.moreTypes) {
			target[position++] = 0xd4
			target[position++] = 0x65 // 'e' for error
			target[position++] = 0
		}
		pack([ error.name, error.message, error.cause ])
	}
}, {
	pack(regex, allocateForWrite, pack) {
		let { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)
		if (this.moreTypes) {
			target[position++] = 0xd4
			target[position++] = 0x78 // 'x' for regeXp
			target[position++] = 0
		}
		pack([ regex.source, regex.flags ])
	}
}, {
	pack(arrayBuffer, allocateForWrite) {
		if (this.moreTypes)
			writeExtBuffer(arrayBuffer, 0x10, allocateForWrite)
		else
			writeBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)
	}
}, {
	pack(typedArray, allocateForWrite) {
		let constructor = typedArray.constructor
		if (constructor !== ByteArray && this.moreTypes)
			writeExtBuffer(typedArray, _unpack_js__rspack_import_0.typedArrays.indexOf(constructor.name), allocateForWrite)
		else
			writeBuffer(typedArray, allocateForWrite)
	}
}, {
	pack(c1, allocateForWrite) { // specific 0xC1 object
		let { target, position} = allocateForWrite(1)
		target[position] = 0xc1
	}
}]

function writeExtBuffer(typedArray, type, allocateForWrite, encode) {
	let length = typedArray.byteLength
	if (length + 1 < 0x100) {
		var { target, position } = allocateForWrite(4 + length)
		target[position++] = 0xc7
		target[position++] = length + 1
	} else if (length + 1 < 0x10000) {
		var { target, position } = allocateForWrite(5 + length)
		target[position++] = 0xc8
		target[position++] = (length + 1) >> 8
		target[position++] = (length + 1) & 0xff
	} else {
		var { target, position, targetView } = allocateForWrite(7 + length)
		target[position++] = 0xc9
		targetView.setUint32(position, length + 1) // plus one for the type byte
		position += 4
	}
	target[position++] = 0x74 // "t" for typed array
	target[position++] = type
	if (!typedArray.buffer) typedArray = new Uint8Array(typedArray)
	target.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position)
}
function writeBuffer(buffer, allocateForWrite) {
	let length = buffer.byteLength
	var target, position
	if (length < 0x100) {
		var { target, position } = allocateForWrite(length + 2)
		target[position++] = 0xc4
		target[position++] = length
	} else if (length < 0x10000) {
		var { target, position } = allocateForWrite(length + 3)
		target[position++] = 0xc5
		target[position++] = length >> 8
		target[position++] = length & 0xff
	} else {
		var { target, position, targetView } = allocateForWrite(length + 5)
		target[position++] = 0xc6
		targetView.setUint32(position, length)
		position += 4
	}
	target.set(buffer, position)
}

function writeExtensionData(result, target, position, type) {
	let length = result.length
	switch (length) {
		case 1:
			target[position++] = 0xd4
			break
		case 2:
			target[position++] = 0xd5
			break
		case 4:
			target[position++] = 0xd6
			break
		case 8:
			target[position++] = 0xd7
			break
		case 16:
			target[position++] = 0xd8
			break
		default:
			if (length < 0x100) {
				target[position++] = 0xc7
				target[position++] = length
			} else if (length < 0x10000) {
				target[position++] = 0xc8
				target[position++] = length >> 8
				target[position++] = length & 0xff
			} else {
				target[position++] = 0xc9
				target[position++] = length >> 24
				target[position++] = (length >> 16) & 0xff
				target[position++] = (length >> 8) & 0xff
				target[position++] = length & 0xff
			}
	}
	target[position++] = type
	target.set(result, position)
	position += length
	return position
}

function insertIds(serialized, idsToInsert) {
	// insert the ids that need to be referenced for structured clones
	let nextId
	let distanceToMove = idsToInsert.length * 6
	let lastEnd = serialized.length - distanceToMove
	while (nextId = idsToInsert.pop()) {
		let offset = nextId.offset
		let id = nextId.id
		serialized.copyWithin(offset + distanceToMove, offset, lastEnd)
		distanceToMove -= 6
		let position = offset + distanceToMove
		serialized[position++] = 0xd6
		serialized[position++] = 0x69 // 'i'
		serialized[position++] = id >> 24
		serialized[position++] = (id >> 16) & 0xff
		serialized[position++] = (id >> 8) & 0xff
		serialized[position++] = id & 0xff
		lastEnd = offset
	}
	return serialized
}

function writeBundles(start, pack, incrementPosition) {
	if (bundledStrings.length > 0) {
		targetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start)
		bundledStrings.stringsPosition = position - start;
		let writeStrings = bundledStrings
		bundledStrings = null
		pack(writeStrings[0])
		pack(writeStrings[1])
	}
}

function addExtension(extension) {
	if (extension.Class) {
		if (!extension.pack && !extension.write)
			throw new Error('Extension has no pack or write function')
		if (extension.pack && !extension.type)
			throw new Error('Extension has no type (numeric code to identify the extension)')
		extensionClasses.unshift(extension.Class)
		extensions.unshift(extension)
	}
	(0,_unpack_js__rspack_import_0.addExtension)(extension)
}
function prepareStructures(structures, packr) {
	structures.isCompatible = (existingStructures) => {
		let compatible = !existingStructures || ((packr.lastNamedStructuresLength || 0) === existingStructures.length)
		if (!compatible) // we want to merge these existing structures immediately since we already have it and we are in the right transaction
			packr._mergeStructures(existingStructures);
		return compatible;
	}
	return structures
}
function setWriteStructSlots(writeSlots, makeStructures) {
	writeStructSlots = writeSlots;
	prepareStructures = makeStructures;
}

let defaultPackr = new Packr({ useRecords: false })
const pack = defaultPackr.pack
const encode = defaultPackr.pack
const Encoder = Packr

;
const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = _unpack_js__rspack_import_0.FLOAT32_OPTIONS
const REUSE_BUFFER_MODE = 512
const RESET_BUFFER_MODE = 1024
const RESERVE_START_SPACE = 2048


},
"./node_modules/@colyseus/msgpackr/unpack.js"(__unused_rspack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  C1: () => (C1),
  C1Type: () => (C1Type),
  Decoder: () => (Decoder),
  FLOAT32_OPTIONS: () => (FLOAT32_OPTIONS),
  Unpackr: () => (Unpackr),
  addExtension: () => (addExtension),
  checkedRead: () => (checkedRead),
  clearSource: () => (clearSource),
  decode: () => (decode),
  getPosition: () => (getPosition),
  isNativeAccelerationEnabled: () => (isNativeAccelerationEnabled),
  loadStructures: () => (loadStructures),
  mult10: () => (mult10),
  read: () => (read),
  readString: () => (readString),
  roundFloat32: () => (roundFloat32),
  setExtractor: () => (setExtractor),
  setReadStruct: () => (setReadStruct),
  typedArrays: () => (typedArrays),
  unpack: () => (unpack),
  unpackMultiple: () => (unpackMultiple)
});
/* provided dependency */ var Buffer = __webpack_require__("./node_modules/buffer/index.js")["Buffer"];
var decoder
try {
	decoder = new TextDecoder()
} catch(error) {}
var src
var srcEnd
var position = 0
var alreadySet
const EMPTY_ARRAY = []
var strings = EMPTY_ARRAY
var stringPosition = 0
var currentUnpackr = {}
var currentStructures
var srcString
var srcStringStart = 0
var srcStringEnd = 0
var bundledStrings
var referenceMap
var currentExtensions = []
var dataView
var defaultOptions = {
	useRecords: false,
	mapsAsObjects: true
}
class C1Type {}
const C1 = new C1Type()
C1.name = 'MessagePack 0xC1'
var sequentialMode = false
var inlineObjectReadThreshold = 2
var readStruct, onLoadedStructures, onSaveState
var BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for
// no-eval build
try {
	new Function('')
} catch(error) {
	// if eval variants are not supported, do not create inline object readers ever
	inlineObjectReadThreshold = Infinity
}

class Unpackr {
	constructor(options) {
		if (options) {
			if (options.useRecords === false && options.mapsAsObjects === undefined)
				options.mapsAsObjects = true
			if (options.sequential && options.trusted !== false) {
				options.trusted = true;
				if (!options.structures && options.useRecords != false) {
					options.structures = []
					if (!options.maxSharedStructures)
						options.maxSharedStructures = 0
				}
			}
			if (options.structures)
				options.structures.sharedLength = options.structures.length
			else if (options.getStructures) {
				(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures
				options.structures.sharedLength = 0
			}
			if (options.int64AsNumber) {
				options.int64AsType = 'number'
			}
		}
		Object.assign(this, options)
	}
	unpack(source, options) {
		if (src) {
			// re-entrant execution, save the state and restore it after we do this unpack
			return saveState(() => {
				clearSource()
				return this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options)
			})
		}
		if (!source.buffer && source.constructor === ArrayBuffer)
			source = typeof Buffer !== 'undefined' ? Buffer.from(source) : new Uint8Array(source);
		if (typeof options === 'object') {
			srcEnd = options.end || source.length
			position = options.start || 0
		} else {
			position = 0
			srcEnd = options > -1 ? options : source.length
		}
		stringPosition = 0
		srcStringEnd = 0
		srcString = null
		strings = EMPTY_ARRAY
		bundledStrings = null
		src = source
		// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend
		// technique for getting data from a database where it can be copied into an existing buffer instead of creating
		// new ones
		try {
			dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))
		} catch(error) {
			// if it doesn't have a buffer, maybe it is the wrong type of object
			src = null
			if (source instanceof Uint8Array)
				throw error
			throw new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))
		}
		if (this instanceof Unpackr) {
			currentUnpackr = this
			if (this.structures) {
				currentStructures = this.structures
				return checkedRead(options)
			} else if (!currentStructures || currentStructures.length > 0) {
				currentStructures = []
			}
		} else {
			currentUnpackr = defaultOptions
			if (!currentStructures || currentStructures.length > 0)
				currentStructures = []
		}
		return checkedRead(options)
	}
	unpackMultiple(source, forEach) {
		let values, lastPosition = 0
		try {
			sequentialMode = true
			let size = source.length
			let value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size)
			if (forEach) {
				if (forEach(value, lastPosition, position) === false) return;
				while(position < size) {
					lastPosition = position
					if (forEach(checkedRead(), lastPosition, position) === false) {
						return
					}
				}
			}
			else {
				values = [ value ]
				while(position < size) {
					lastPosition = position
					values.push(checkedRead())
				}
				return values
			}
		} catch(error) {
			error.lastPosition = lastPosition
			error.values = values
			throw error
		} finally {
			sequentialMode = false
			clearSource()
		}
	}
	_mergeStructures(loadedStructures, existingStructures) {
		if (onLoadedStructures)
			loadedStructures = onLoadedStructures.call(this, loadedStructures);
		loadedStructures = loadedStructures || []
		if (Object.isFrozen(loadedStructures))
			loadedStructures = loadedStructures.map(structure => structure.slice(0))
		for (let i = 0, l = loadedStructures.length; i < l; i++) {
			let structure = loadedStructures[i]
			if (structure) {
				structure.isShared = true
				if (i >= 32)
					structure.highByte = (i - 32) >> 5
			}
		}
		loadedStructures.sharedLength = loadedStructures.length
		for (let id in existingStructures || []) {
			if (id >= 0) {
				let structure = loadedStructures[id]
				let existing = existingStructures[id]
				if (existing) {
					if (structure)
						(loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure
					loadedStructures[id] = existing
				}
			}
		}
		return this.structures = loadedStructures
	}
	decode(source, options) {
		return this.unpack(source, options)
	}
}
function getPosition() {
	return position
}
function checkedRead(options) {
	try {
		if (!currentUnpackr.trusted && !sequentialMode) {
			let sharedLength = currentStructures.sharedLength || 0
			if (sharedLength < currentStructures.length)
				currentStructures.length = sharedLength
		}
		let result
		if (currentUnpackr.randomAccessStructure && src[position] < 0x40 && src[position] >= 0x20 && readStruct) {
			result = readStruct(src, position, srcEnd, currentUnpackr)
			src = null // dispose of this so that recursive unpack calls don't save state
			if (!(options && options.lazy) && result)
				result = result.toJSON()
			position = srcEnd
		} else
			result = read()
		if (bundledStrings) { // bundled strings to skip past
			position = bundledStrings.postBundlePosition
			bundledStrings = null
		}
		if (sequentialMode)
			// we only need to restore the structures if there was an error, but if we completed a read,
			// we can clear this out and keep the structures we read
			currentStructures.restoreStructures = null

		if (position == srcEnd) {
			// finished reading this source, cleanup references
			if (currentStructures && currentStructures.restoreStructures)
				restoreStructures()
			currentStructures = null
			src = null
			if (referenceMap)
				referenceMap = null
		} else if (position > srcEnd) {
			// over read
			throw new Error('Unexpected end of MessagePack data')
		} else if (!sequentialMode) {
			let jsonView;
			try {
				jsonView = JSON.stringify(result, (_, value) => typeof value === "bigint" ? `${value}n` : value).slice(0, 100)
			} catch(error) {
				jsonView = '(JSON view not available ' + error + ')'
			}
			throw new Error('Data read, but end of buffer not reached ' + jsonView)
		}
		// else more to read, but we are reading sequentially, so don't clear source yet
		return result
	} catch(error) {
		if (currentStructures && currentStructures.restoreStructures)
			restoreStructures()
		clearSource()
		if (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer') || position > srcEnd) {
			error.incomplete = true
		}
		throw error
	}
}

function restoreStructures() {
	for (let id in currentStructures.restoreStructures) {
		currentStructures[id] = currentStructures.restoreStructures[id]
	}
	currentStructures.restoreStructures = null
}

function read() {
	let token = src[position++]
	if (token < 0xa0) {
		if (token < 0x80) {
			if (token < 0x40)
				return token
			else {
				let structure = currentStructures[token & 0x3f] ||
					currentUnpackr.getStructures && loadStructures()[token & 0x3f]
				if (structure) {
					if (!structure.read) {
						structure.read = createStructureReader(structure, token & 0x3f)
					}
					return structure.read()
				} else
					return token
			}
		} else if (token < 0x90) {
			// map
			token -= 0x80
			if (currentUnpackr.mapsAsObjects) {
				let object = {}
				for (let i = 0; i < token; i++) {
					let key = readKey()
					if (key === '__proto__')
						key = '__proto_'
					object[key] = read()
				}
				return object
			} else {
				let map = new Map()
				for (let i = 0; i < token; i++) {
					map.set(read(), read())
				}
				return map
			}
		} else {
			token -= 0x90
			let array = new Array(token)
			for (let i = 0; i < token; i++) {
				array[i] = read()
			}
			if (currentUnpackr.freezeData)
				return Object.freeze(array)
			return array
		}
	} else if (token < 0xc0) {
		// fixstr
		let length = token - 0xa0
		if (srcStringEnd >= position) {
			return srcString.slice(position - srcStringStart, (position += length) - srcStringStart)
		}
		if (srcStringEnd == 0 && srcEnd < 140) {
			// for small blocks, avoiding the overhead of the extract call is helpful
			let string = length < 16 ? shortStringInJS(length) : longStringInJS(length)
			if (string != null)
				return string
		}
		return readFixedString(length)
	} else {
		let value
		switch (token) {
			case 0xc0: return null
			case 0xc1:
				if (bundledStrings) {
					value = read() // followed by the length of the string in characters (not bytes!)
					if (value > 0)
						return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)
					else
						return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 -= value)
				}
				return C1; // "never-used", return special object to denote that
			case 0xc2: return false
			case 0xc3: return true
			case 0xc4:
				// bin 8
				value = src[position++]
				if (value === undefined)
					throw new Error('Unexpected end of buffer')
				return readBin(value)
			case 0xc5:
				// bin 16
				value = dataView.getUint16(position)
				position += 2
				return readBin(value)
			case 0xc6:
				// bin 32
				value = dataView.getUint32(position)
				position += 4
				return readBin(value)
			case 0xc7:
				// ext 8
				return readExt(src[position++])
			case 0xc8:
				// ext 16
				value = dataView.getUint16(position)
				position += 2
				return readExt(value)
			case 0xc9:
				// ext 32
				value = dataView.getUint32(position)
				position += 4
				return readExt(value)
			case 0xca:
				value = dataView.getFloat32(position)
				if (currentUnpackr.useFloat32 > 2) {
					// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
					let multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]
					position += 4
					return ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier
				}
				position += 4
				return value
			case 0xcb:
				value = dataView.getFloat64(position)
				position += 8
				return value
			// uint handlers
			case 0xcc:
				return src[position++]
			case 0xcd:
				value = dataView.getUint16(position)
				position += 2
				return value
			case 0xce:
				value = dataView.getUint32(position)
				position += 4
				return value
			case 0xcf:
				if (currentUnpackr.int64AsType === 'number') {
					value = dataView.getUint32(position) * 0x100000000
					value += dataView.getUint32(position + 4)
				} else if (currentUnpackr.int64AsType === 'string') {
					value = dataView.getBigUint64(position).toString()
				} else if (currentUnpackr.int64AsType === 'auto') {
					value = dataView.getBigUint64(position)
					if (value<=BigInt(2)<<BigInt(52)) value=Number(value)
				} else
					value = dataView.getBigUint64(position)
				position += 8
				return value

			// int handlers
			case 0xd0:
				return dataView.getInt8(position++)
			case 0xd1:
				value = dataView.getInt16(position)
				position += 2
				return value
			case 0xd2:
				value = dataView.getInt32(position)
				position += 4
				return value
			case 0xd3:
				if (currentUnpackr.int64AsType === 'number') {
					value = dataView.getInt32(position) * 0x100000000
					value += dataView.getUint32(position + 4)
				} else if (currentUnpackr.int64AsType === 'string') {
					value = dataView.getBigInt64(position).toString()
				} else if (currentUnpackr.int64AsType === 'auto') {
					value = dataView.getBigInt64(position)
					if (value>=BigInt(-2)<<BigInt(52)&&value<=BigInt(2)<<BigInt(52)) value=Number(value)
				} else
					value = dataView.getBigInt64(position)
				position += 8
				return value

			case 0xd4:
				// fixext 1
				value = src[position++]
				if (value == 0x72) {
					return recordDefinition(src[position++] & 0x3f)
				} else {
					let extension = currentExtensions[value]
					if (extension) {
						if (extension.read) {
							position++ // skip filler byte
							return extension.read(read())
						} else if (extension.noBuffer) {
							position++ // skip filler byte
							return extension()
						} else
							return extension(src.subarray(position, ++position))
					} else
						throw new Error('Unknown extension ' + value)
				}
			case 0xd5:
				// fixext 2
				value = src[position]
				if (value == 0x72) {
					position++
					return recordDefinition(src[position++] & 0x3f, src[position++])
				} else
					return readExt(2)
			case 0xd6:
				// fixext 4
				return readExt(4)
			case 0xd7:
				// fixext 8
				return readExt(8)
			case 0xd8:
				// fixext 16
				return readExt(16)
			case 0xd9:
			// str 8
				value = src[position++]
				if (srcStringEnd >= position) {
					return srcString.slice(position - srcStringStart, (position += value) - srcStringStart)
				}
				return readString8(value)
			case 0xda:
			// str 16
				value = dataView.getUint16(position)
				position += 2
				if (srcStringEnd >= position) {
					return srcString.slice(position - srcStringStart, (position += value) - srcStringStart)
				}
				return readString16(value)
			case 0xdb:
			// str 32
				value = dataView.getUint32(position)
				position += 4
				if (srcStringEnd >= position) {
					return srcString.slice(position - srcStringStart, (position += value) - srcStringStart)
				}
				return readString32(value)
			case 0xdc:
			// array 16
				value = dataView.getUint16(position)
				position += 2
				return readArray(value)
			case 0xdd:
			// array 32
				value = dataView.getUint32(position)
				position += 4
				return readArray(value)
			case 0xde:
			// map 16
				value = dataView.getUint16(position)
				position += 2
				return readMap(value)
			case 0xdf:
			// map 32
				value = dataView.getUint32(position)
				position += 4
				return readMap(value)
			default: // negative int
				if (token >= 0xe0)
					return token - 0x100
				if (token === undefined) {
					let error = new Error('Unexpected end of MessagePack data')
					error.incomplete = true
					throw error
				}
				throw new Error('Unknown MessagePack token ' + token)

		}
	}
}
const validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/
function createStructureReader(structure, firstId) {
	function readObject() {
		// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function
		if (readObject.count++ > inlineObjectReadThreshold) {
			let readObject = structure.read = (new Function('r', 'return function(){return ' + (currentUnpackr.freezeData ? 'Object.freeze' : '') +
				'({' + structure.map(key => key === '__proto__' ? '__proto_:r()' : validName.test(key) ? key + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '})}'))(read)
			if (structure.highByte === 0)
				structure.read = createSecondByteReader(firstId, structure.read)
			return readObject() // second byte is already read, if there is one so immediately read object
		}
		let object = {}
		for (let i = 0, l = structure.length; i < l; i++) {
			let key = structure[i]
			if (key === '__proto__')
				key = '__proto_'
			object[key] = read()
		}
		if (currentUnpackr.freezeData)
			return Object.freeze(object);
		return object
	}
	readObject.count = 0
	if (structure.highByte === 0) {
		return createSecondByteReader(firstId, readObject)
	}
	return readObject
}

const createSecondByteReader = (firstId, read0) => {
	return function() {
		let highByte = src[position++]
		if (highByte === 0)
			return read0()
		let id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5)
		let structure = currentStructures[id] || loadStructures()[id]
		if (!structure) {
			throw new Error('Record id is not defined for ' + id)
		}
		if (!structure.read)
			structure.read = createStructureReader(structure, firstId)
		return structure.read()
	}
}

function loadStructures() {
	let loadedStructures = saveState(() => {
		// save the state in case getStructures modifies our buffer
		src = null
		return currentUnpackr.getStructures()
	})
	return currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures)
}

var readFixedString = readStringJS
var readString8 = readStringJS
var readString16 = readStringJS
var readString32 = readStringJS
let isNativeAccelerationEnabled = false

function setExtractor(extractStrings) {
	isNativeAccelerationEnabled = true
	readFixedString = readString(1)
	readString8 = readString(2)
	readString16 = readString(3)
	readString32 = readString(5)
	function readString(headerLength) {
		return function readString(length) {
			let string = strings[stringPosition++]
			if (string == null) {
				if (bundledStrings)
					return readStringJS(length)
				let byteOffset = src.byteOffset
				let extraction = extractStrings(position - headerLength + byteOffset, srcEnd + byteOffset, src.buffer)
				if (typeof extraction == 'string') {
					string = extraction
					strings = EMPTY_ARRAY
				} else {
					strings = extraction
					stringPosition = 1
					srcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings
					string = strings[0]
					if (string === undefined)
						throw new Error('Unexpected end of buffer')
				}
			}
			let srcStringLength = string.length
			if (srcStringLength <= length) {
				position += length
				return string
			}
			srcString = string
			srcStringStart = position
			srcStringEnd = position + srcStringLength
			position += length
			return string.slice(0, length) // we know we just want the beginning
		}
	}
}
function readStringJS(length) {
	let result
	if (length < 16) {
		if (result = shortStringInJS(length))
			return result
	}
	if (length > 64 && decoder)
		return decoder.decode(src.subarray(position, position += length))
	const end = position + length
	const units = []
	result = ''
	while (position < end) {
		const byte1 = src[position++]
		if ((byte1 & 0x80) === 0) {
			// 1 byte
			units.push(byte1)
		} else if ((byte1 & 0xe0) === 0xc0) {
			// 2 bytes
			const byte2 = src[position++] & 0x3f
			units.push(((byte1 & 0x1f) << 6) | byte2)
		} else if ((byte1 & 0xf0) === 0xe0) {
			// 3 bytes
			const byte2 = src[position++] & 0x3f
			const byte3 = src[position++] & 0x3f
			units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)
		} else if ((byte1 & 0xf8) === 0xf0) {
			// 4 bytes
			const byte2 = src[position++] & 0x3f
			const byte3 = src[position++] & 0x3f
			const byte4 = src[position++] & 0x3f
			let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4
			if (unit > 0xffff) {
				unit -= 0x10000
				units.push(((unit >>> 10) & 0x3ff) | 0xd800)
				unit = 0xdc00 | (unit & 0x3ff)
			}
			units.push(unit)
		} else {
			units.push(byte1)
		}

		if (units.length >= 0x1000) {
			result += fromCharCode.apply(String, units)
			units.length = 0
		}
	}

	if (units.length > 0) {
		result += fromCharCode.apply(String, units)
	}

	return result
}
function readString(source, start, length) {
	let existingSrc = src;
	src = source;
	position = start;
	try {
		return readStringJS(length);
	} finally {
		src = existingSrc;
	}
}

function readArray(length) {
	let array = new Array(length)
	for (let i = 0; i < length; i++) {
		array[i] = read()
	}
	if (currentUnpackr.freezeData)
		return Object.freeze(array)
	return array
}

function readMap(length) {
	if (currentUnpackr.mapsAsObjects) {
		let object = {}
		for (let i = 0; i < length; i++) {
			let key = readKey()
			if (key === '__proto__')
				key = '__proto_';
			object[key] = read()
		}
		return object
	} else {
		let map = new Map()
		for (let i = 0; i < length; i++) {
			map.set(read(), read())
		}
		return map
	}
}

var fromCharCode = String.fromCharCode
function longStringInJS(length) {
	let start = position
	let bytes = new Array(length)
	for (let i = 0; i < length; i++) {
		const byte = src[position++];
		if ((byte & 0x80) > 0) {
				position = start
				return
			}
			bytes[i] = byte
		}
		return fromCharCode.apply(String, bytes)
}
function shortStringInJS(length) {
	if (length < 4) {
		if (length < 2) {
			if (length === 0)
				return ''
			else {
				let a = src[position++]
				if ((a & 0x80) > 1) {
					position -= 1
					return
				}
				return fromCharCode(a)
			}
		} else {
			let a = src[position++]
			let b = src[position++]
			if ((a & 0x80) > 0 || (b & 0x80) > 0) {
				position -= 2
				return
			}
			if (length < 3)
				return fromCharCode(a, b)
			let c = src[position++]
			if ((c & 0x80) > 0) {
				position -= 3
				return
			}
			return fromCharCode(a, b, c)
		}
	} else {
		let a = src[position++]
		let b = src[position++]
		let c = src[position++]
		let d = src[position++]
		if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {
			position -= 4
			return
		}
		if (length < 6) {
			if (length === 4)
				return fromCharCode(a, b, c, d)
			else {
				let e = src[position++]
				if ((e & 0x80) > 0) {
					position -= 5
					return
				}
				return fromCharCode(a, b, c, d, e)
			}
		} else if (length < 8) {
			let e = src[position++]
			let f = src[position++]
			if ((e & 0x80) > 0 || (f & 0x80) > 0) {
				position -= 6
				return
			}
			if (length < 7)
				return fromCharCode(a, b, c, d, e, f)
			let g = src[position++]
			if ((g & 0x80) > 0) {
				position -= 7
				return
			}
			return fromCharCode(a, b, c, d, e, f, g)
		} else {
			let e = src[position++]
			let f = src[position++]
			let g = src[position++]
			let h = src[position++]
			if ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {
				position -= 8
				return
			}
			if (length < 10) {
				if (length === 8)
					return fromCharCode(a, b, c, d, e, f, g, h)
				else {
					let i = src[position++]
					if ((i & 0x80) > 0) {
						position -= 9
						return
					}
					return fromCharCode(a, b, c, d, e, f, g, h, i)
				}
			} else if (length < 12) {
				let i = src[position++]
				let j = src[position++]
				if ((i & 0x80) > 0 || (j & 0x80) > 0) {
					position -= 10
					return
				}
				if (length < 11)
					return fromCharCode(a, b, c, d, e, f, g, h, i, j)
				let k = src[position++]
				if ((k & 0x80) > 0) {
					position -= 11
					return
				}
				return fromCharCode(a, b, c, d, e, f, g, h, i, j, k)
			} else {
				let i = src[position++]
				let j = src[position++]
				let k = src[position++]
				let l = src[position++]
				if ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {
					position -= 12
					return
				}
				if (length < 14) {
					if (length === 12)
						return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)
					else {
						let m = src[position++]
						if ((m & 0x80) > 0) {
							position -= 13
							return
						}
						return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)
					}
				} else {
					let m = src[position++]
					let n = src[position++]
					if ((m & 0x80) > 0 || (n & 0x80) > 0) {
						position -= 14
						return
					}
					if (length < 15)
						return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)
					let o = src[position++]
					if ((o & 0x80) > 0) {
						position -= 15
						return
					}
					return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
				}
			}
		}
	}
}

function readOnlyJSString() {
	let token = src[position++]
	let length
	if (token < 0xc0) {
		// fixstr
		length = token - 0xa0
	} else {
		switch(token) {
			case 0xd9:
			// str 8
				length = src[position++]
				break
			case 0xda:
			// str 16
				length = dataView.getUint16(position)
				position += 2
				break
			case 0xdb:
			// str 32
				length = dataView.getUint32(position)
				position += 4
				break
			default:
				throw new Error('Expected string')
		}
	}
	return readStringJS(length)
}


function readBin(length) {
	return currentUnpackr.copyBuffers ?
		// specifically use the copying slice (not the node one)
		Uint8Array.prototype.slice.call(src, position, position += length) :
		src.subarray(position, position += length)
}
function readExt(length) {
	let type = src[position++]
	if (currentExtensions[type]) {
		let end
		return currentExtensions[type](src.subarray(position, end = (position += length)), (readPosition) => {
			position = readPosition;
			try {
				return read();
			} finally {
				position = end;
			}
		})
	}
	else
		throw new Error('Unknown extension type ' + type)
}

var keyCache = new Array(4096)
function readKey() {
	let length = src[position++]
	if (length >= 0xa0 && length < 0xc0) {
		// fixstr, potentially use key cache
		length = length - 0xa0
		if (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)
			return srcString.slice(position - srcStringStart, (position += length) - srcStringStart)
		else if (!(srcStringEnd == 0 && srcEnd < 180))
			return readFixedString(length)
	} else { // not cacheable, go back and do a standard read
		position--
		return asSafeString(read())
	}
	let key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff
	let entry = keyCache[key]
	let checkPosition = position
	let end = position + length - 3
	let chunk
	let i = 0
	if (entry && entry.bytes == length) {
		while (checkPosition < end) {
			chunk = dataView.getUint32(checkPosition)
			if (chunk != entry[i++]) {
				checkPosition = 0x70000000
				break
			}
			checkPosition += 4
		}
		end += 3
		while (checkPosition < end) {
			chunk = src[checkPosition++]
			if (chunk != entry[i++]) {
				checkPosition = 0x70000000
				break
			}
		}
		if (checkPosition === end) {
			position = checkPosition
			return entry.string
		}
		end -= 3
		checkPosition = position
	}
	entry = []
	keyCache[key] = entry
	entry.bytes = length
	while (checkPosition < end) {
		chunk = dataView.getUint32(checkPosition)
		entry.push(chunk)
		checkPosition += 4
	}
	end += 3
	while (checkPosition < end) {
		chunk = src[checkPosition++]
		entry.push(chunk)
	}
	// for small blocks, avoiding the overhead of the extract call is helpful
	let string = length < 16 ? shortStringInJS(length) : longStringInJS(length)
	if (string != null)
		return entry.string = string
	return entry.string = readFixedString(length)
}

function asSafeString(property) {
	// protect against expensive (DoS) string conversions
	if (typeof property === 'string') return property;
	if (typeof property === 'number' || typeof property === 'boolean' || typeof property === 'bigint') return property.toString();
	if (property == null) return property + '';
	if (currentUnpackr.allowArraysInMapKeys && Array.isArray(property) && property.flat().every(item => ['string', 'number', 'boolean', 'bigint'].includes(typeof item))) {
		return property.flat().toString();
	}
	throw new Error(`Invalid property type for record: ${typeof property}`);
}
// the registration of the record definition extension (as "r")
const recordDefinition = (id, highByte) => {
	let structure = read().map(asSafeString) // ensure that all keys are strings and
	// that the array is mutable
	let firstByte = id
	if (highByte !== undefined) {
		id = id < 32 ? -((highByte << 5) + id) : ((highByte << 5) + id)
		structure.highByte = highByte
	}
	let existingStructure = currentStructures[id]
	// If it is a shared structure, we need to restore any changes after reading.
	// Also in sequential mode, we may get incomplete reads and thus errors, and we need to restore
	// to the state prior to an incomplete read in order to properly resume.
	if (existingStructure && (existingStructure.isShared || sequentialMode)) {
		(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure
	}
	currentStructures[id] = structure
	structure.read = createStructureReader(structure, firstByte)
	return structure.read()
}
currentExtensions[0] = () => {} // notepack defines extension 0 to mean undefined, so use that as the default here
currentExtensions[0].noBuffer = true

currentExtensions[0x42] = (data) => {
	// decode bigint
	let length = data.length;
	let value = BigInt(data[0] & 0x80 ? data[0] - 0x100 : data[0]);
	for (let i = 1; i < length; i++) {
		value <<= BigInt(8);
		value += BigInt(data[i]);
	}
	return value;
}

let errors = { Error, TypeError, ReferenceError };
currentExtensions[0x65] = () => {
	let data = read()
	return (errors[data[0]] || Error)(data[1], { cause: data[2] })
}

currentExtensions[0x69] = (data) => {
	// id extension (for structured clones)
	if (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')
	let id = dataView.getUint32(position - 4)
	if (!referenceMap)
		referenceMap = new Map()
	let token = src[position]
	let target
	// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read
	// ahead past references to record structure definitions
	if (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd)
		target = []
	else
		target = {}

	let refEntry = { target } // a placeholder object
	referenceMap.set(id, refEntry)
	let targetProperties = read() // read the next value as the target object to id
	if (refEntry.used) // there is a cycle, so we have to assign properties to original target
		return Object.assign(target, targetProperties)
	refEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one
	return targetProperties // no cycle, can just use the returned read object
}

currentExtensions[0x70] = (data) => {
	// pointer extension (for structured clones)
	if (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')
	let id = dataView.getUint32(position - 4)
	let refEntry = referenceMap.get(id)
	refEntry.used = true
	return refEntry.target
}

currentExtensions[0x73] = () => new Set(read())

const typedArrays = ['Int8','Uint8','Uint8Clamped','Int16','Uint16','Int32','Uint32','Float32','Float64','BigInt64','BigUint64'].map(type => type + 'Array')

let glbl = typeof globalThis === 'object' ? globalThis : window;
currentExtensions[0x74] = (data) => {
	let typeCode = data[0]
	let typedArrayName = typedArrays[typeCode]
	if (!typedArrayName) {
		if (typeCode === 16) {
			let ab = new ArrayBuffer(data.length - 1)
			let u8 = new Uint8Array(ab)
			u8.set(data.subarray(1))
			return ab;
		}
		throw new Error('Could not find typed array for code ' + typeCode)
	}
	// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned
	return new glbl[typedArrayName](Uint8Array.prototype.slice.call(data, 1).buffer)
}
currentExtensions[0x78] = () => {
	let data = read()
	return new RegExp(data[0], data[1])
}
const TEMP_BUNDLE = []
currentExtensions[0x62] = (data) => {
	let dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]
	let dataPosition = position
	position += dataSize - data.length
	bundledStrings = TEMP_BUNDLE
	bundledStrings = [readOnlyJSString(), readOnlyJSString()]
	bundledStrings.position0 = 0
	bundledStrings.position1 = 0
	bundledStrings.postBundlePosition = position
	position = dataPosition
	return read()
}

currentExtensions[0xff] = (data) => {
	// 32-bit date extension
	if (data.length == 4)
		return new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000)
	else if (data.length == 8)
		return new Date(
			((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 +
			((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000)
	else if (data.length == 12)// TODO: Implement support for negative
		return new Date(
			((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 +
			(((data[4] & 0x80) ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000)
	else
		return new Date('invalid')
} // notepack defines extension 0 to mean undefined, so use that as the default here
// registration of bulk record definition?
// currentExtensions[0x52] = () =>

function saveState(callback) {
	if (onSaveState)
		onSaveState();
	let savedSrcEnd = srcEnd
	let savedPosition = position
	let savedStringPosition = stringPosition
	let savedSrcStringStart = srcStringStart
	let savedSrcStringEnd = srcStringEnd
	let savedSrcString = srcString
	let savedStrings = strings
	let savedReferenceMap = referenceMap
	let savedBundledStrings = bundledStrings

	// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)
	let savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed
	let savedStructures = currentStructures
	let savedStructuresContents = currentStructures.slice(0, currentStructures.length)
	let savedPackr = currentUnpackr
	let savedSequentialMode = sequentialMode
	let value = callback()
	srcEnd = savedSrcEnd
	position = savedPosition
	stringPosition = savedStringPosition
	srcStringStart = savedSrcStringStart
	srcStringEnd = savedSrcStringEnd
	srcString = savedSrcString
	strings = savedStrings
	referenceMap = savedReferenceMap
	bundledStrings = savedBundledStrings
	src = savedSrc
	sequentialMode = savedSequentialMode
	currentStructures = savedStructures
	currentStructures.splice(0, currentStructures.length, ...savedStructuresContents)
	currentUnpackr = savedPackr
	dataView = new DataView(src.buffer, src.byteOffset, src.byteLength)
	return value
}
function clearSource() {
	src = null
	referenceMap = null
	currentStructures = null
}

function addExtension(extension) {
	if (extension.unpack)
		currentExtensions[extension.type] = extension.unpack
	else
		currentExtensions[extension.type] = extension
}

const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding
for (let i = 0; i < 256; i++) {
	mult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))
}
const Decoder = Unpackr
var defaultUnpackr = new Unpackr({ useRecords: false })
const unpack = defaultUnpackr.unpack
const unpackMultiple = defaultUnpackr.unpackMultiple
const decode = defaultUnpackr.unpack
const FLOAT32_OPTIONS = {
	NEVER: 0,
	ALWAYS: 1,
	DECIMAL_ROUND: 3,
	DECIMAL_FIT: 4
}
let f32Array = new Float32Array(1)
let u8Array = new Uint8Array(f32Array.buffer, 0, 4)
function roundFloat32(float32Number) {
	f32Array[0] = float32Number
	let multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]
	return ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier
}
function setReadStruct(updatedReadStruct, loadedStructs, saveState) {
	readStruct = updatedReadStruct;
	onLoadedStructures = loadedStructs;
	onSaveState = saveState;
}


},

});
// The module cache
var __webpack_module_cache__ = {};

// The require function
function __webpack_require__(moduleId) {

// Check if module is in cache
var cachedModule = __webpack_module_cache__[moduleId];
if (cachedModule !== undefined) {
return cachedModule.exports;
}
// Create a new module (and put it into the cache)
var module = (__webpack_module_cache__[moduleId] = {
exports: {}
});
// Execute the module function
__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);

// Return the exports of the module
return module.exports;

}

// webpack/runtime/compat_get_default_export
(() => {
// getDefaultExport function for compatibility with non-ESM modules
__webpack_require__.n = (module) => {
	var getter = module && module.__esModule ?
		() => (module['default']) :
		() => (module);
	__webpack_require__.d(getter, { a: getter });
	return getter;
};

})();
// webpack/runtime/define_property_getters
(() => {
__webpack_require__.d = (exports, definition) => {
	for(var key in definition) {
        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
            Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
        }
    }
};
})();
// webpack/runtime/global
(() => {
__webpack_require__.g = (() => {
	if (typeof globalThis === 'object') return globalThis;
	try {
		return this || new Function('return this')();
	} catch (e) {
		if (typeof window === 'object') return window;
	}
})();
})();
// webpack/runtime/has_own_property
(() => {
__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
})();
// webpack/runtime/make_namespace_object
(() => {
// define __esModule on exports
__webpack_require__.r = (exports) => {
	if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
		Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
	}
	Object.defineProperty(exports, '__esModule', { value: true });
};
})();
// webpack/runtime/rspack_version
(() => {
__webpack_require__.rv = () => ("1.7.6")
})();
// webpack/runtime/rspack_unique_id
(() => {
__webpack_require__.ruid = "bundler=rspack@1.7.6";
})();
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
__webpack_require__.r(__webpack_exports__);
/* import */ var _colyseus_msgpackr__rspack_import_0 = __webpack_require__("./node_modules/@colyseus/msgpackr/index.js");
/* import */ var _colyseus_schema__rspack_import_1 = __webpack_require__("./node_modules/@colyseus/schema/build/umd/index.js");
/* import */ var _colyseus_schema__rspack_import_1_default = /*#__PURE__*/__webpack_require__.n(_colyseus_schema__rspack_import_1);
/* import */ var _schemas_ts__rspack_import_2 = __webpack_require__("./src/schemas.ts");
/* import */ var _enums_ts__rspack_import_3 = __webpack_require__("./src/enums.ts");
/* provided dependency */ var console = __webpack_require__("./node_modules/console-browserify/index.js");
function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes(arr) {
    if (Array.isArray(arr)) return arr;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _assert_this_initialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _call_super(_this, derived, args) {
    derived = _get_prototype_of(derived);
    return _possible_constructor_return(_this, _is_native_reflect_construct() ? Reflect.construct(derived, args || [], _get_prototype_of(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
    } else {
        _get = function get(target, property, receiver) {
            var base = _super_prop_base(target, property);
            if (!base) return;
            var desc = Object.getOwnPropertyDescriptor(base, property);
            if (desc.get) {
                return desc.get.call(receiver || target);
            }
            return desc.value;
        };
    }
    return _get(target, property, receiver || target);
}
function _get_prototype_of(o) {
    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of(o);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of(subClass, superClass);
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possible_constructor_return(self, call) {
    if (call && (_type_of(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized(self);
}
function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of(o, p);
}
function _sliced_to_array(arr, i) {
    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _super_prop_base(object, property) {
    while(!Object.prototype.hasOwnProperty.call(object, property)){
        object = _get_prototype_of(object);
        if (object === null) break;
    }
    return object;
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
function _is_native_reflect_construct() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct = function() {
        return !!result;
    })();
}
function _ts_generator(thisArg, body) {
    var f, y, t, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype), d = Object.defineProperty;
    return d(g, "next", {
        value: verb(0)
    }), d(g, "throw", {
        value: verb(1)
    }), d(g, "return", {
        value: verb(2)
    }), typeof Symbol === "function" && d(g, Symbol.iterator, {
        value: function() {
            return this;
        }
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}




var filteredMessages = [
    "Ping",
    "Pong",
    "PositionUpdate"
];
// @ts-ignore
var origWS = unsafeWindow.WebSocket;
var state = new _schemas_ts__rspack_import_2.MyRoomState();
var decoder = new _colyseus_schema__rspack_import_1.Decoder(state);
var localplayerid = null;
// @ts-ignore
unsafeWindow.state = state;
// @ts-ignore
unsafeWindow.decoder = decoder;
function processPacket(buffer, source) {
    var it = {
        offset: 1
    };
    var code = buffer[0];
    if (code === _enums_ts__rspack_import_3.Protocol.JOIN_ROOM) {
        return [
            code,
            "joining!"
        ];
    } else if (code === _enums_ts__rspack_import_3.Protocol.ROOM_DATA) {
        var type = _colyseus_schema__rspack_import_1.decode.stringCheck(buffer, it) ? _colyseus_schema__rspack_import_1.decode.string(buffer, it) : _colyseus_schema__rspack_import_1.decode.number(buffer, it);
        var message = buffer.byteLength > it.offset ? (0,_colyseus_msgpackr__rspack_import_0.unpack)(buffer, {
            start: it.offset
        }) : undefined;
        if (filteredMessages.indexOf(_enums_ts__rspack_import_3.CustomMessageType[type]) === -1) {
        //console.log(source === "r" ? "recv" : "send", CustomMessageType[type] ?? type, message ?? "empty");
        }
        return [
            code,
            _enums_ts__rspack_import_3.CustomMessageType[type],
            message
        ];
    } else if (code === _enums_ts__rspack_import_3.Protocol.ROOM_STATE) {
        try {
            return decoder.decode(buffer, it);
        } catch (e) {
            //console.error("@colyseus/schema decode error:", e, { buffer });
            return [
                code,
                "decode_error"
            ];
        }
    } else if (code === _enums_ts__rspack_import_3.Protocol.ROOM_STATE_PATCH) {
        return decoder.decode(buffer, it);
    } else if (code === _enums_ts__rspack_import_3.Protocol.LEAVE_ROOM) {
        return [
            code,
            "Leaving room!"
        ];
    } else {
        return [
            code,
            "?"
        ];
    }
}
function encodeRoomData(type, message) {
    var it = {
        offset: 1
    };
    var packr = new _colyseus_msgpackr__rspack_import_0.Packr();
    packr.encode(undefined);
    packr.buffer[0] = _enums_ts__rspack_import_3.Protocol.ROOM_DATA;
    if (typeof type === "string") {
        _colyseus_schema__rspack_import_1.encode.string(packr.buffer, type, it);
    } else {
        _colyseus_schema__rspack_import_1.encode.number(packr.buffer, type, it);
    }
    packr.position = 0;
    return message !== undefined ? packr.pack(message, 2048 + it.offset) // 2048 = RESERVE_START_SPACE
     : packr.buffer.subarray(0, it.offset);
}
// @ts-ignore
function sendCustom(type, message) {
    var // @ts-ignore
    _unsafeWindow_currentSocket;
    var buf = encodeRoomData(type, message);
    (_unsafeWindow_currentSocket = unsafeWindow.currentSocket) === null || _unsafeWindow_currentSocket === void 0 ? void 0 : _unsafeWindow_currentSocket.send(buf);
}
// @ts-ignore
unsafeWindow.sendCustom = sendCustom;
var HookedWS = /*#__PURE__*/ function(origWS) {
    "use strict";
    _inherits(HookedWS, origWS);
    function HookedWS() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _class_call_check(this, HookedWS);
        var _this;
        console.log("connecting to ".concat(args[0]));
        var match = /[?&]sessionId=([^&]+)/.exec(args[0]);
        if (match) {
            localplayerid = match[1];
            console.log("Got player id:", localplayerid);
        }
        _this = _call_super(this, HookedWS, _to_consumable_array(args));
        // @ts-ignore
        unsafeWindow.currentSocket = _this;
        // @ts-ignore
        _this.send = function(packet) {
            var buffer = new Uint8Array(packet);
            try {
                var resp = processPacket(buffer, "s");
            //console.log(resp[1], resp[2])
            } catch (e) {}
            return _get((_assert_this_initialized(_this), _get_prototype_of(HookedWS.prototype)), "send", _this).call(_this, packet);
        };
        // @ts-ignore
        _this.addEventListener("message", function(evt) {
            var buffer = new Uint8Array(evt.data);
            try {
                processPacket(buffer, "r");
            } catch (e) {}
        });
        return _this;
    }
    return HookedWS;
}(origWS);
// @ts-ignore
unsafeWindow.WebSocket = HookedWS;
//34 = wildcarrot
var pricemap = {
    0: 10,
    1: 50,
    2: 100,
    3: 800,
    4: 2250,
    5: 3750,
    8: 7500,
    9: 10500,
    10: 11250,
    11: 35000,
    17: 37500000,
    18: 200,
    19: 1500,
    20: 1950,
    21: 3750,
    22: 5250,
    23: 6000,
    24: 900,
    25: 6300,
    26: 6300,
    29: 6600,
    30: 1425,
    31: 10500,
    32: 1650,
    35: 3000000,
    36: 10000000,
    37: 500000000
};
var farming = false;
var farming2 = false;
document.addEventListener("keydown", function(event) {
    var key = event.key.toLowerCase();
    if (key === "p") {
        farming = !farming;
        farming2 = false;
        alert("Farming with buying: ".concat(farming, ", Farming without buying: ").concat(farming2));
        if (farming) startFarming();
    }
    if (key === "o") {
        farming2 = !farming2;
        farming = false;
        alert("Farming with buying: ".concat(farming, ", Farming without buying: ").concat(farming2));
        if (farming2) startFarming2();
    }
});
// @ts-ignore
function startFarming() {
    return _async_to_generator(function() {
        return _ts_generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    if (!farming) return [
                        3,
                        3
                    ];
                    return [
                        4,
                        farmonce()
                    ];
                case 1:
                    _state.sent();
                    return [
                        4,
                        sleep(10000)
                    ];
                case 2:
                    _state.sent();
                    return [
                        3,
                        0
                    ];
                case 3:
                    return [
                        2
                    ];
            }
        });
    })();
}
// @ts-ignore
function startFarming2() {
    return _async_to_generator(function() {
        return _ts_generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    if (!farming2) return [
                        3,
                        3
                    ];
                    return [
                        4,
                        farmoncewithoutbuying()
                    ];
                case 1:
                    _state.sent();
                    return [
                        4,
                        sleep(10000)
                    ];
                case 2:
                    _state.sent();
                    return [
                        3,
                        0
                    ];
                case 3:
                    return [
                        2
                    ];
            }
        });
    })();
}
// @ts-ignore
function farmoncewithoutbuying() {
    return _async_to_generator(function() {
        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, item, fruitid, _iteratorNormalCompletion1, _didIteratorError1, _iteratorError1, _iterator1, _step1, _step_value, key, value;
        return _ts_generator(this, function(_state) {
            _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(_iterator = getGarden().plants.items[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    item = _step.value;
                    if (item.isFruitTree) {
                        fruitid = item.plantId;
                        _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                        try {
                            for(_iterator1 = item.fruits.entries()[Symbol.iterator](); !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                _step_value = _sliced_to_array(_step1.value, 2), key = _step_value[0], value = _step_value[1];
                                CollectPlant(fruitid, value.plantId);
                            }
                        } catch (err) {
                            _didIteratorError1 = true;
                            _iteratorError1 = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                    _iterator1.return();
                                }
                            } finally{
                                if (_didIteratorError1) {
                                    throw _iteratorError1;
                                }
                            }
                        }
                    } else {
                        CollectPlant(item.plantId);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            sellItems();
            return [
                2
            ];
        });
    })();
}
function pressspace() {
    var canvas = document.querySelector("canvas");
    var down = new KeyboardEvent("keydown", {
        key: " ",
        code: "Space",
        keyCode: 32,
        which: 32,
        bubbles: true
    });
    var up = new KeyboardEvent("keyup", {
        key: " ",
        code: "Space",
        keyCode: 32,
        which: 32,
        bubbles: true
    });
    canvas.dispatchEvent(down);
    setTimeout(function() {
        return canvas.dispatchEvent(up);
    }, 50);
}
// @ts-ignore
function farmonce() {
    return _async_to_generator(function() {
        var collectedcount, max_collect, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, item, fruitid, _iteratorNormalCompletion1, _didIteratorError1, _iteratorError1, _iterator1, _step1, _step_value, key, value, err, err, result, i;
        return _ts_generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    collectedcount = 0;
                    max_collect = 100;
                    pressspace();
                    _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        15,
                        16,
                        17
                    ]);
                    _iterator = getGarden().plants.items[Symbol.iterator]();
                    _state.label = 2;
                case 2:
                    if (!!(_iteratorNormalCompletion = (_step = _iterator.next()).done)) return [
                        3,
                        14
                    ];
                    item = _step.value;
                    if (!item.isFruitTree) return [
                        3,
                        11
                    ];
                    fruitid = item.plantId;
                    _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                    _state.label = 3;
                case 3:
                    _state.trys.push([
                        3,
                        8,
                        9,
                        10
                    ]);
                    _iterator1 = item.fruits.entries()[Symbol.iterator]();
                    _state.label = 4;
                case 4:
                    if (!!(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done)) return [
                        3,
                        7
                    ];
                    _step_value = _sliced_to_array(_step1.value, 2), key = _step_value[0], value = _step_value[1];
                    CollectPlant(fruitid, value.plantId);
                    collectedcount++;
                    if (!(collectedcount >= max_collect)) return [
                        3,
                        6
                    ];
                    sellItems();
                    collectedcount = 0;
                    return [
                        4,
                        sleep(1000)
                    ];
                case 5:
                    _state.sent();
                    _state.label = 6;
                case 6:
                    _iteratorNormalCompletion1 = true;
                    return [
                        3,
                        4
                    ];
                case 7:
                    return [
                        3,
                        10
                    ];
                case 8:
                    err = _state.sent();
                    _didIteratorError1 = true;
                    _iteratorError1 = err;
                    return [
                        3,
                        10
                    ];
                case 9:
                    try {
                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                            _iterator1.return();
                        }
                    } finally{
                        if (_didIteratorError1) {
                            throw _iteratorError1;
                        }
                    }
                    return [
                        7
                    ];
                case 10:
                    return [
                        3,
                        13
                    ];
                case 11:
                    CollectPlant(item.plantId);
                    collectedcount++;
                    if (!(collectedcount >= max_collect)) return [
                        3,
                        13
                    ];
                    sellItems();
                    collectedcount = 0;
                    return [
                        4,
                        sleep(1000)
                    ];
                case 12:
                    _state.sent();
                    _state.label = 13;
                case 13:
                    _iteratorNormalCompletion = true;
                    return [
                        3,
                        2
                    ];
                case 14:
                    return [
                        3,
                        17
                    ];
                case 15:
                    err = _state.sent();
                    _didIteratorError = true;
                    _iteratorError = err;
                    return [
                        3,
                        17
                    ];
                case 16:
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                    return [
                        7
                    ];
                case 17:
                    if (collectedcount > 0) {
                        sellItems();
                    }
                    result = findClosestSeed(getPlayer().coins);
                    if (!result) return [
                        3,
                        23
                    ];
                    i = 0;
                    _state.label = 18;
                case 18:
                    if (!(i < result.maxAmount)) return [
                        3,
                        21
                    ];
                    buyseed(Number(result.id));
                    return [
                        4,
                        sleep(100)
                    ];
                case 19:
                    _state.sent();
                    _state.label = 20;
                case 20:
                    i++;
                    return [
                        3,
                        18
                    ];
                case 21:
                    return [
                        4,
                        plantallseeds()
                    ];
                case 22:
                    _state.sent();
                    _state.label = 23;
                case 23:
                    return [
                        2
                    ];
            }
        });
    })();
}
function sleep(ms) {
    // @ts-ignore
    return new Promise(function(resolve) {
        return setTimeout(resolve, ms);
    });
}
var lasty = Number(window.localStorage.getItem("Recte-lasty") || "0");
// @ts-ignore
function plantallseeds() {
    return _async_to_generator(function() {
        var hasSeeds, myinventory, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step_value, data, i, err;
        return _ts_generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    hasSeeds = true;
                    _state.label = 1;
                case 1:
                    if (!hasSeeds) return [
                        3,
                        12
                    ];
                    hasSeeds = false;
                    //@ts-ignore
                    myinventory = Array.from(getPlayer().inventory.entries());
                    _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    _state.label = 2;
                case 2:
                    _state.trys.push([
                        2,
                        9,
                        10,
                        11
                    ]);
                    _iterator = myinventory[Symbol.iterator]();
                    _state.label = 3;
                case 3:
                    if (!!(_iteratorNormalCompletion = (_step = _iterator.next()).done)) return [
                        3,
                        8
                    ];
                    _step_value = _sliced_to_array(_step.value, 2), data = _step_value[1];
                    if (!(data.type === "seed" && data.amount > 0)) return [
                        3,
                        7
                    ];
                    hasSeeds = true;
                    i = 0;
                    _state.label = 4;
                case 4:
                    if (!(i < data.amount)) return [
                        3,
                        7
                    ];
                    PlantSeed(data.id, lasty, lasty);
                    lasty += 0.00001;
                    if (lasty > 3) lasty = 0;
                    window.localStorage.setItem("Recte-lasty", lasty.toString());
                    return [
                        4,
                        sleep(1000)
                    ];
                case 5:
                    _state.sent();
                    _state.label = 6;
                case 6:
                    i++;
                    return [
                        3,
                        4
                    ];
                case 7:
                    _iteratorNormalCompletion = true;
                    return [
                        3,
                        3
                    ];
                case 8:
                    return [
                        3,
                        11
                    ];
                case 9:
                    err = _state.sent();
                    _didIteratorError = true;
                    _iteratorError = err;
                    return [
                        3,
                        11
                    ];
                case 10:
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                    return [
                        7
                    ];
                case 11:
                    return [
                        3,
                        1
                    ];
                case 12:
                    return [
                        2
                    ];
            }
        });
    })();
}
function findClosestSeed(coins) {
    var closestId = null;
    var closestPrice = -Infinity;
    var availableQuantity = 0;
    // @ts-ignore
    var currentStock = Array.from(getPlayer().stock.entries());
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = currentStock[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var _step_value = _sliced_to_array(_step.value, 2), key = _step_value[0], quantity = _step_value[1];
            if (pricemap.hasOwnProperty(key) && quantity > 0) {
                var price = pricemap[key];
                if (price <= coins && price > closestPrice) {
                    closestPrice = price;
                    closestId = key;
                    availableQuantity = quantity;
                }
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    if (closestId === null) return null;
    var maxAmount = Math.min(Math.floor(coins / closestPrice), availableQuantity);
    if (!maxAmount) maxAmount = 0;
    return {
        id: closestId,
        maxAmount: maxAmount
    };
}
function getPlayer() {
    var results = [];
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        // @ts-ignore
        for(var _iterator = (state.players.entries ? state.players.entries() : Object.entries(state.players))[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var _step_value = _sliced_to_array(_step.value, 2), key = _step_value[0], value = _step_value[1];
            if (value && value.playerId === localplayerid) {
                return value;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
}
function getGarden() {
    var results = [];
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        // @ts-ignore
        for(var _iterator = (state.gardens.entries ? state.gardens.entries() : Object.entries(state.gardens))[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var _step_value = _sliced_to_array(_step.value, 2), key = _step_value[0], value = _step_value[1];
            if (value && value.ownerId === localplayerid) {
                return value;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
}
function buyseed(seedId) {
    sendCustom(87, {
        "seedId": seedId,
        "quantity": 1,
        "payWithGems": false
    });
}
function CollectPlant(plantId) {
    var fruitId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (fruitId) {
        sendCustom(56, {
            "plantId": plantId,
            "fruitId": fruitId,
            "gardenId": localplayerid
        });
    } else {
        sendCustom(56, {
            "plantId": plantId,
            "gardenId": localplayerid
        });
    }
}
// @ts-ignore
function PlantSeed(seedId, posx, poxy) {
    sendCustom(59, {
        "seedId": seedId,
        "x": posx,
        "y": poxy
    });
}
function sellItems() {
    sendCustom(48, {
        "inventoryLookupId": -1
    });
}

})();

})()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy9AY29seXNldXMvc2NoZW1hL2J1aWxkL3VtZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2Fzc2VydC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2ludGVybmFsL2Fzc2VydC9hc3NlcnRpb25fZXJyb3IuanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9pbnRlcm5hbC9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9pbnRlcm5hbC91dGlsL2NvbXBhcmlzb25zLmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kLWFwcGx5LWhlbHBlcnMvYWN0dWFsQXBwbHkuanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC1hcHBseS1oZWxwZXJzL2FwcGx5QmluZC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kLWFwcGx5LWhlbHBlcnMvZnVuY3Rpb25BcHBseS5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kLWFwcGx5LWhlbHBlcnMvZnVuY3Rpb25DYWxsLmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQtYXBwbHktaGVscGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kLWFwcGx5LWhlbHBlcnMvcmVmbGVjdEFwcGx5LmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvY2FsbEJvdW5kLmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2NhbGwtYm91bmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvZGVmaW5lLWRhdGEtcHJvcGVydHkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2RlZmluZS1wcm9wZXJ0aWVzL2luZGV4LmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy9kdW5kZXItcHJvdG8vZ2V0LmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy9lcy1kZWZpbmUtcHJvcGVydHkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2VzLWVycm9ycy9ldmFsLmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy9lcy1lcnJvcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2VzLWVycm9ycy9yYW5nZS5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvZXMtZXJyb3JzL3JlZi5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvZXMtZXJyb3JzL3N5bnRheC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvZXMtZXJyb3JzL3R5cGUuanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2VzLWVycm9ycy91cmkuanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2VzLW9iamVjdC1hdG9tcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvZm9yLWVhY2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2dlbmVyYXRvci1mdW5jdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvZ2V0LWludHJpbnNpYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvZ2V0LXByb3RvL09iamVjdC5nZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvZ2V0LXByb3RvL1JlZmxlY3QuZ2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2dldC1wcm90by9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvZ29wZC9nT1BELmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy9nb3BkL2luZGV4LmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy9oYXMtcHJvcGVydHktZGVzY3JpcHRvcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL2luZGV4LmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9zaGFtcy5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvaGFzLXRvc3RyaW5ndGFnL3NoYW1zLmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy9oYXNvd24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2lzLWFyZ3VtZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvaXMtY2FsbGFibGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2lzLWdlbmVyYXRvci1mdW5jdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvaXMtbmFuL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy9pcy1uYW4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2lzLW5hbi9wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvaXMtbmFuL3NoaW0uanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2lzLXJlZ2V4L2luZGV4LmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy9pcy10eXBlZC1hcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvbWF0aC1pbnRyaW5zaWNzL2Ficy5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvbWF0aC1pbnRyaW5zaWNzL2Zsb29yLmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy9tYXRoLWludHJpbnNpY3MvaXNOYU4uanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL21hdGgtaW50cmluc2ljcy9tYXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL21hdGgtaW50cmluc2ljcy9taW4uanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL21hdGgtaW50cmluc2ljcy9wb3cuanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL21hdGgtaW50cmluc2ljcy9yb3VuZC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvbWF0aC1pbnRyaW5zaWNzL3NpZ24uanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL2luZGV4LmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9zaGltLmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy9vYmplY3QuYXNzaWduL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy9vYmplY3QuYXNzaWduL3BvbHlmaWxsLmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy9wb3NzaWJsZS10eXBlZC1hcnJheS1uYW1lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy9zYWZlLXJlZ2V4LXRlc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL3NldC1mdW5jdGlvbi1sZW5ndGgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC90eXBlcy5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy93aGljaC10eXBlZC1hcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9zcmMvZW51bXMudHMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vc3JjL3NjaGVtYXMudHMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL2F2YWlsYWJsZS10eXBlZC1hcnJheXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL0Bjb2x5c2V1cy9tc2dwYWNrci9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvQGNvbHlzZXVzL21zZ3BhY2tyL2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvQGNvbHlzZXVzL21zZ3BhY2tyL3BhY2suanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzL0Bjb2x5c2V1cy9tc2dwYWNrci91bnBhY2suanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sL3dlYnBhY2svcnVudGltZS9jb21wYXRfZ2V0X2RlZmF1bHRfZXhwb3J0Iiwid2VicGFjazovL3BveGVsdG9vbC93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lX3Byb3BlcnR5X2dldHRlcnMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sL3dlYnBhY2svcnVudGltZS9oYXNfb3duX3Byb3BlcnR5Iiwid2VicGFjazovL3BveGVsdG9vbC93ZWJwYWNrL3J1bnRpbWUvbWFrZV9uYW1lc3BhY2Vfb2JqZWN0Iiwid2VicGFjazovL3BveGVsdG9vbC93ZWJwYWNrL3J1bnRpbWUvcnNwYWNrX3ZlcnNpb24iLCJ3ZWJwYWNrOi8vcG94ZWx0b29sL3dlYnBhY2svcnVudGltZS9yc3BhY2tfdW5pcXVlX2lkIiwid2VicGFjazovL3BveGVsdG9vbC8uL3NyYy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLnNjaGVtYSA9IHt9KSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgU1dJVENIX1RPX1NUUlVDVFVSRSA9IDI1NTsgLy8gKGRlY29kaW5nIGNvbGxpZGVzIHdpdGggREVMRVRFX0FORF9BREQgKyBmaWVsZEluZGV4ID0gNjMpXG4gICAgY29uc3QgVFlQRV9JRCA9IDIxMztcbiAgICAvKipcbiAgICAgKiBFbmNvZGluZyBTY2hlbWEgZmllbGQgb3BlcmF0aW9ucy5cbiAgICAgKi9cbiAgICBleHBvcnRzLk9QRVJBVElPTiA9IHZvaWQgMDtcbiAgICAoZnVuY3Rpb24gKE9QRVJBVElPTikge1xuICAgICAgICBPUEVSQVRJT05bT1BFUkFUSU9OW1wiQUREXCJdID0gMTI4XSA9IFwiQUREXCI7XG4gICAgICAgIE9QRVJBVElPTltPUEVSQVRJT05bXCJSRVBMQUNFXCJdID0gMF0gPSBcIlJFUExBQ0VcIjtcbiAgICAgICAgT1BFUkFUSU9OW09QRVJBVElPTltcIkRFTEVURVwiXSA9IDY0XSA9IFwiREVMRVRFXCI7XG4gICAgICAgIE9QRVJBVElPTltPUEVSQVRJT05bXCJERUxFVEVfQU5EX01PVkVcIl0gPSA5Nl0gPSBcIkRFTEVURV9BTkRfTU9WRVwiO1xuICAgICAgICBPUEVSQVRJT05bT1BFUkFUSU9OW1wiTU9WRV9BTkRfQUREXCJdID0gMTYwXSA9IFwiTU9WRV9BTkRfQUREXCI7XG4gICAgICAgIE9QRVJBVElPTltPUEVSQVRJT05bXCJERUxFVEVfQU5EX0FERFwiXSA9IDE5Ml0gPSBcIkRFTEVURV9BTkRfQUREXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9wZXJhdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIE9QRVJBVElPTltPUEVSQVRJT05bXCJDTEVBUlwiXSA9IDEwXSA9IFwiQ0xFQVJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFycmF5U2NoZW1hIG9wZXJhdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIE9QRVJBVElPTltPUEVSQVRJT05bXCJSRVZFUlNFXCJdID0gMTVdID0gXCJSRVZFUlNFXCI7XG4gICAgICAgIE9QRVJBVElPTltPUEVSQVRJT05bXCJNT1ZFXCJdID0gMzJdID0gXCJNT1ZFXCI7XG4gICAgICAgIE9QRVJBVElPTltPUEVSQVRJT05bXCJERUxFVEVfQllfUkVGSURcIl0gPSAzM10gPSBcIkRFTEVURV9CWV9SRUZJRFwiO1xuICAgICAgICBPUEVSQVRJT05bT1BFUkFUSU9OW1wiQUREX0JZX1JFRklEXCJdID0gMTI5XSA9IFwiQUREX0JZX1JFRklEXCI7XG4gICAgfSkoZXhwb3J0cy5PUEVSQVRJT04gfHwgKGV4cG9ydHMuT1BFUkFUSU9OID0ge30pKTtcblxuICAgIFN5bWJvbC5tZXRhZGF0YSA/Pz0gU3ltYm9sLmZvcihcIlN5bWJvbC5tZXRhZGF0YVwiKTtcblxuICAgIGNvbnN0ICR0cmFjayA9IFwifnRyYWNrXCI7XG4gICAgY29uc3QgJGVuY29kZXIgPSBcIn5lbmNvZGVyXCI7XG4gICAgY29uc3QgJGRlY29kZXIgPSBcIn5kZWNvZGVyXCI7XG4gICAgY29uc3QgJGZpbHRlciA9IFwifmZpbHRlclwiO1xuICAgIGNvbnN0ICRnZXRCeUluZGV4ID0gXCJ+Z2V0QnlJbmRleFwiO1xuICAgIGNvbnN0ICRkZWxldGVCeUluZGV4ID0gXCJ+ZGVsZXRlQnlJbmRleFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gaG9sZCBDaGFuZ2VUcmVlIGluc3RhbmNlcyB3aGl0aW4gdGhlIHN0cnVjdHVyZXNcbiAgICAgKi9cbiAgICBjb25zdCAkY2hhbmdlcyA9ICd+Y2hhbmdlcyc7XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSB0eXBlIG9mIHRoZSBjaGlsZCBlbGVtZW50cyBvZiBhIGNvbGxlY3Rpb25cbiAgICAgKiAoTWFwU2NoZW1hLCBBcnJheVNjaGVtYSwgZXRjLilcbiAgICAgKi9cbiAgICBjb25zdCAkY2hpbGRUeXBlID0gJ35jaGlsZFR5cGUnO1xuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIFwiZGlzY2FyZFwiIG1ldGhvZCBmb3IgY3VzdG9tIHR5cGVzIChBcnJheVNjaGVtYSlcbiAgICAgKiAoRGlzY2FyZHMgY2hhbmdlcyBmb3IgbmV4dCBzZXJpYWxpemF0aW9uKVxuICAgICAqL1xuICAgIGNvbnN0ICRvbkVuY29kZUVuZCA9ICd+b25FbmNvZGVFbmQnO1xuICAgIC8qKlxuICAgICAqIFdoZW4gZGVjb2RpbmcsIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBhZnRlciB0aGUgaW5zdGFuY2UgaXMgZnVsbHkgZGVjb2RlZFxuICAgICAqL1xuICAgIGNvbnN0ICRvbkRlY29kZUVuZCA9IFwifm9uRGVjb2RlRW5kXCI7XG4gICAgLyoqXG4gICAgICogTWV0YWRhdGFcbiAgICAgKi9cbiAgICBjb25zdCAkZGVzY3JpcHRvcnMgPSBcIn5kZXNjcmlwdG9yc1wiO1xuICAgIGNvbnN0ICRudW1GaWVsZHMgPSBcIn5fX251bUZpZWxkc1wiO1xuICAgIGNvbnN0ICRyZWZUeXBlRmllbGRJbmRleGVzID0gXCJ+X19yZWZUeXBlRmllbGRJbmRleGVzXCI7XG4gICAgY29uc3QgJHZpZXdGaWVsZEluZGV4ZXMgPSBcIn5fX3ZpZXdGaWVsZEluZGV4ZXNcIjtcbiAgICBjb25zdCAkZmllbGRJbmRleGVzQnlWaWV3VGFnID0gXCIkX19maWVsZEluZGV4ZXNCeVZpZXdUYWdcIjtcblxuICAgIC8vIEB0cy1ub2NoZWNrXG4gICAgLyoqXG4gICAgICogbXNncGFjayBpbXBsZW1lbnRhdGlvbiBoaWdobHkgYmFzZWQgb24gbm90ZXBhY2suaW9cbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vZGFycmFjaGVxdWVzbmUvbm90ZXBhY2tcbiAgICAgKi9cbiAgICBsZXQgdGV4dEVuY29kZXI7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRyeSB7XG4gICAgICAgIHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICBjb25zdCBfY29udm9CdWZmZXIkMSA9IG5ldyBBcnJheUJ1ZmZlcig4KTtcbiAgICBjb25zdCBfaW50MzIkMSA9IG5ldyBJbnQzMkFycmF5KF9jb252b0J1ZmZlciQxKTtcbiAgICBjb25zdCBfZmxvYXQzMiQxID0gbmV3IEZsb2F0MzJBcnJheShfY29udm9CdWZmZXIkMSk7XG4gICAgY29uc3QgX2Zsb2F0NjQkMSA9IG5ldyBGbG9hdDY0QXJyYXkoX2NvbnZvQnVmZmVyJDEpO1xuICAgIGNvbnN0IF9pbnQ2NCQxID0gbmV3IEJpZ0ludDY0QXJyYXkoX2NvbnZvQnVmZmVyJDEpO1xuICAgIGNvbnN0IGhhc0J1ZmZlckJ5dGVMZW5ndGggPSAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgQnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgIGNvbnN0IHV0ZjhMZW5ndGggPSAoaGFzQnVmZmVyQnl0ZUxlbmd0aClcbiAgICAgICAgPyBCdWZmZXIuYnl0ZUxlbmd0aCAvLyBub2RlXG4gICAgICAgIDogZnVuY3Rpb24gKHN0ciwgXykge1xuICAgICAgICAgICAgdmFyIGMgPSAwLCBsZW5ndGggPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdHIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGggKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjIDwgMHhkODAwIHx8IGMgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGggKz0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9O1xuICAgIGZ1bmN0aW9uIHV0ZjhXcml0ZSh2aWV3LCBzdHIsIGl0KSB7XG4gICAgICAgIHZhciBjID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdHIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgICAgICB2aWV3W2l0Lm9mZnNldCsrXSA9IGM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgICAgICB2aWV3W2l0Lm9mZnNldF0gPSAweGMwIHwgKGMgPj4gNik7XG4gICAgICAgICAgICAgICAgdmlld1tpdC5vZmZzZXQgKyAxXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICAgICAgICAgIGl0Lm9mZnNldCArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA8IDB4ZDgwMCB8fCBjID49IDB4ZTAwMCkge1xuICAgICAgICAgICAgICAgIHZpZXdbaXQub2Zmc2V0XSA9IDB4ZTAgfCAoYyA+PiAxMik7XG4gICAgICAgICAgICAgICAgdmlld1tpdC5vZmZzZXQgKyAxXSA9IDB4ODAgfCAoYyA+PiA2ICYgMHgzZik7XG4gICAgICAgICAgICAgICAgdmlld1tpdC5vZmZzZXQgKyAyXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICAgICAgICAgIGl0Lm9mZnNldCArPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKCgoYyAmIDB4M2ZmKSA8PCAxMCkgfCAoc3RyLmNoYXJDb2RlQXQoaSkgJiAweDNmZikpO1xuICAgICAgICAgICAgICAgIHZpZXdbaXQub2Zmc2V0XSA9IDB4ZjAgfCAoYyA+PiAxOCk7XG4gICAgICAgICAgICAgICAgdmlld1tpdC5vZmZzZXQgKyAxXSA9IDB4ODAgfCAoYyA+PiAxMiAmIDB4M2YpO1xuICAgICAgICAgICAgICAgIHZpZXdbaXQub2Zmc2V0ICsgMl0gPSAweDgwIHwgKGMgPj4gNiAmIDB4M2YpO1xuICAgICAgICAgICAgICAgIHZpZXdbaXQub2Zmc2V0ICsgM10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICAgICAgICAgICAgICBpdC5vZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbnQ4JDEoYnl0ZXMsIHZhbHVlLCBpdCkge1xuICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSB2YWx1ZSAmIDI1NTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdWludDgkMShieXRlcywgdmFsdWUsIGl0KSB7XG4gICAgICAgIGJ5dGVzW2l0Lm9mZnNldCsrXSA9IHZhbHVlICYgMjU1O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnQxNiQxKGJ5dGVzLCB2YWx1ZSwgaXQpIHtcbiAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gdmFsdWUgJiAyNTU7XG4gICAgICAgIGJ5dGVzW2l0Lm9mZnNldCsrXSA9ICh2YWx1ZSA+PiA4KSAmIDI1NTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdWludDE2JDEoYnl0ZXMsIHZhbHVlLCBpdCkge1xuICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSB2YWx1ZSAmIDI1NTtcbiAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gKHZhbHVlID4+IDgpICYgMjU1O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnQzMiQxKGJ5dGVzLCB2YWx1ZSwgaXQpIHtcbiAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gdmFsdWUgJiAyNTU7XG4gICAgICAgIGJ5dGVzW2l0Lm9mZnNldCsrXSA9ICh2YWx1ZSA+PiA4KSAmIDI1NTtcbiAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gKHZhbHVlID4+IDE2KSAmIDI1NTtcbiAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gKHZhbHVlID4+IDI0KSAmIDI1NTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdWludDMyJDEoYnl0ZXMsIHZhbHVlLCBpdCkge1xuICAgICAgICBjb25zdCBiNCA9IHZhbHVlID4+IDI0O1xuICAgICAgICBjb25zdCBiMyA9IHZhbHVlID4+IDE2O1xuICAgICAgICBjb25zdCBiMiA9IHZhbHVlID4+IDg7XG4gICAgICAgIGNvbnN0IGIxID0gdmFsdWU7XG4gICAgICAgIGJ5dGVzW2l0Lm9mZnNldCsrXSA9IGIxICYgMjU1O1xuICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSBiMiAmIDI1NTtcbiAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gYjMgJiAyNTU7XG4gICAgICAgIGJ5dGVzW2l0Lm9mZnNldCsrXSA9IGI0ICYgMjU1O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnQ2NCQxKGJ5dGVzLCB2YWx1ZSwgaXQpIHtcbiAgICAgICAgY29uc3QgaGlnaCA9IE1hdGguZmxvb3IodmFsdWUgLyBNYXRoLnBvdygyLCAzMikpO1xuICAgICAgICBjb25zdCBsb3cgPSB2YWx1ZSA+Pj4gMDtcbiAgICAgICAgdWludDMyJDEoYnl0ZXMsIGxvdywgaXQpO1xuICAgICAgICB1aW50MzIkMShieXRlcywgaGlnaCwgaXQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1aW50NjQkMShieXRlcywgdmFsdWUsIGl0KSB7XG4gICAgICAgIGNvbnN0IGhpZ2ggPSAodmFsdWUgLyBNYXRoLnBvdygyLCAzMikpID4+IDA7XG4gICAgICAgIGNvbnN0IGxvdyA9IHZhbHVlID4+PiAwO1xuICAgICAgICB1aW50MzIkMShieXRlcywgbG93LCBpdCk7XG4gICAgICAgIHVpbnQzMiQxKGJ5dGVzLCBoaWdoLCBpdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJpZ2ludDY0JDEoYnl0ZXMsIHZhbHVlLCBpdCkge1xuICAgICAgICBfaW50NjQkMVswXSA9IEJpZ0ludC5hc0ludE4oNjQsIHZhbHVlKTtcbiAgICAgICAgaW50MzIkMShieXRlcywgX2ludDMyJDFbMF0sIGl0KTtcbiAgICAgICAgaW50MzIkMShieXRlcywgX2ludDMyJDFbMV0sIGl0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmlndWludDY0JDEoYnl0ZXMsIHZhbHVlLCBpdCkge1xuICAgICAgICBfaW50NjQkMVswXSA9IEJpZ0ludC5hc0ludE4oNjQsIHZhbHVlKTtcbiAgICAgICAgaW50MzIkMShieXRlcywgX2ludDMyJDFbMF0sIGl0KTtcbiAgICAgICAgaW50MzIkMShieXRlcywgX2ludDMyJDFbMV0sIGl0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmxvYXQzMiQxKGJ5dGVzLCB2YWx1ZSwgaXQpIHtcbiAgICAgICAgX2Zsb2F0MzIkMVswXSA9IHZhbHVlO1xuICAgICAgICBpbnQzMiQxKGJ5dGVzLCBfaW50MzIkMVswXSwgaXQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbG9hdDY0JDEoYnl0ZXMsIHZhbHVlLCBpdCkge1xuICAgICAgICBfZmxvYXQ2NCQxWzBdID0gdmFsdWU7XG4gICAgICAgIGludDMyJDEoYnl0ZXMsIF9pbnQzMiQxWzAgXSwgaXQpO1xuICAgICAgICBpbnQzMiQxKGJ5dGVzLCBfaW50MzIkMVsxIF0sIGl0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm9vbGVhbiQxKGJ5dGVzLCB2YWx1ZSwgaXQpIHtcbiAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gdmFsdWUgPyAxIDogMDsgLy8gdWludDhcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyaW5nJDEoYnl0ZXMsIHZhbHVlLCBpdCkge1xuICAgICAgICAvLyBlbmNvZGUgYG51bGxgIHN0cmluZ3MgYXMgZW1wdHkuXG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGVuZ3RoID0gdXRmOExlbmd0aCh2YWx1ZSwgXCJ1dGY4XCIpO1xuICAgICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICAgIC8vIGZpeHN0clxuICAgICAgICBpZiAobGVuZ3RoIDwgMHgyMCkge1xuICAgICAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gbGVuZ3RoIHwgMHhhMDtcbiAgICAgICAgICAgIHNpemUgPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0ciA4XG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwKSB7XG4gICAgICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSAweGQ5O1xuICAgICAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gbGVuZ3RoICUgMjU1O1xuICAgICAgICAgICAgc2l6ZSA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RyIDE2XG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIGJ5dGVzW2l0Lm9mZnNldCsrXSA9IDB4ZGE7XG4gICAgICAgICAgICB1aW50MTYkMShieXRlcywgbGVuZ3RoLCBpdCk7XG4gICAgICAgICAgICBzaXplID0gMztcbiAgICAgICAgfVxuICAgICAgICAvLyBzdHIgMzJcbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAgIGJ5dGVzW2l0Lm9mZnNldCsrXSA9IDB4ZGI7XG4gICAgICAgICAgICB1aW50MzIkMShieXRlcywgbGVuZ3RoLCBpdCk7XG4gICAgICAgICAgICBzaXplID0gNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3RyaW5nIHRvbyBsb25nJyk7XG4gICAgICAgIH1cbiAgICAgICAgdXRmOFdyaXRlKGJ5dGVzLCB2YWx1ZSwgaXQpO1xuICAgICAgICByZXR1cm4gc2l6ZSArIGxlbmd0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbnVtYmVyJDEoYnl0ZXMsIHZhbHVlLCBpdCkge1xuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyJDEoYnl0ZXMsIDAsIGl0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyJDEoYnl0ZXMsICh2YWx1ZSA+IDApID8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgOiAtTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIGl0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gKHZhbHVlIHwgMCkpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh2YWx1ZSkgPD0gMy40MDI4MjM1ZSszOCkgeyAvLyByYW5nZSBjaGVja1xuICAgICAgICAgICAgICAgIF9mbG9hdDMyJDFbMF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoTWF0aC5hYnMoX2Zsb2F0MzIkMVswXSkgLSBNYXRoLmFicyh2YWx1ZSkpIDwgMWUtNCkgeyAvLyBwcmVjaXNpb24gY2hlY2s7IGFkanVzdCAxZS1uIChuID0gcHJlY2lzaW9uKSB0byBpbi0vZGVjcmVhc2UgYWNjZXB0YWJsZSBwcmVjaXNpb24gbG9zc1xuICAgICAgICAgICAgICAgICAgICAvLyBub3cgd2Uga25vdyB2YWx1ZSBpcyBpbiByYW5nZSBmb3IgZjMyIGFuZCBoYXMgYWNjZXB0YWJsZSBwcmVjaXNpb24gZm9yIGYzMlxuICAgICAgICAgICAgICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSAweGNhO1xuICAgICAgICAgICAgICAgICAgICBmbG9hdDMyJDEoYnl0ZXMsIHZhbHVlLCBpdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ5dGVzW2l0Lm9mZnNldCsrXSA9IDB4Y2I7XG4gICAgICAgICAgICBmbG9hdDY0JDEoYnl0ZXMsIHZhbHVlLCBpdCk7XG4gICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgLy8gcG9zaXRpdmUgZml4bnVtXG4gICAgICAgICAgICBpZiAodmFsdWUgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gdmFsdWUgJiAyNTU7IC8vIHVpbnQ4XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1aW50IDhcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4MTAwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gMHhjYztcbiAgICAgICAgICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSB2YWx1ZSAmIDI1NTsgLy8gdWludDhcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVpbnQgMTZcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSAweGNkO1xuICAgICAgICAgICAgICAgIHVpbnQxNiQxKGJ5dGVzLCB2YWx1ZSwgaXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdWludCAzMlxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSAweGNlO1xuICAgICAgICAgICAgICAgIHVpbnQzMiQxKGJ5dGVzLCB2YWx1ZSwgaXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdWludCA2NFxuICAgICAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gMHhjZjtcbiAgICAgICAgICAgIHVpbnQ2NCQxKGJ5dGVzLCB2YWx1ZSwgaXQpO1xuICAgICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBuZWdhdGl2ZSBmaXhudW1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAtMzIpIHtcbiAgICAgICAgICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSAweGUwIHwgKHZhbHVlICsgMHgyMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbnQgOFxuICAgICAgICAgICAgaWYgKHZhbHVlID49IC0xMjgpIHtcbiAgICAgICAgICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSAweGQwO1xuICAgICAgICAgICAgICAgIGludDgkMShieXRlcywgdmFsdWUsIGl0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGludCAxNlxuICAgICAgICAgICAgaWYgKHZhbHVlID49IC0zMjc2OCkge1xuICAgICAgICAgICAgICAgIGJ5dGVzW2l0Lm9mZnNldCsrXSA9IDB4ZDE7XG4gICAgICAgICAgICAgICAgaW50MTYkMShieXRlcywgdmFsdWUsIGl0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGludCAzMlxuICAgICAgICAgICAgaWYgKHZhbHVlID49IC0yMTQ3NDgzNjQ4KSB7XG4gICAgICAgICAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gMHhkMjtcbiAgICAgICAgICAgICAgICBpbnQzMiQxKGJ5dGVzLCB2YWx1ZSwgaXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW50IDY0XG4gICAgICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSAweGQzO1xuICAgICAgICAgICAgaW50NjQkMShieXRlcywgdmFsdWUsIGl0KTtcbiAgICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVuY29kZSA9IHtcbiAgICAgICAgaW50ODogaW50OCQxLFxuICAgICAgICB1aW50ODogdWludDgkMSxcbiAgICAgICAgaW50MTY6IGludDE2JDEsXG4gICAgICAgIHVpbnQxNjogdWludDE2JDEsXG4gICAgICAgIGludDMyOiBpbnQzMiQxLFxuICAgICAgICB1aW50MzI6IHVpbnQzMiQxLFxuICAgICAgICBpbnQ2NDogaW50NjQkMSxcbiAgICAgICAgdWludDY0OiB1aW50NjQkMSxcbiAgICAgICAgYmlnaW50NjQ6IGJpZ2ludDY0JDEsXG4gICAgICAgIGJpZ3VpbnQ2NDogYmlndWludDY0JDEsXG4gICAgICAgIGZsb2F0MzI6IGZsb2F0MzIkMSxcbiAgICAgICAgZmxvYXQ2NDogZmxvYXQ2NCQxLFxuICAgICAgICBib29sZWFuOiBib29sZWFuJDEsXG4gICAgICAgIHN0cmluZzogc3RyaW5nJDEsXG4gICAgICAgIG51bWJlcjogbnVtYmVyJDEsXG4gICAgICAgIHV0ZjhXcml0ZSxcbiAgICAgICAgdXRmOExlbmd0aCxcbiAgICB9O1xuXG4gICAgLy8gQHRzLW5vY2hlY2tcbiAgICAvLyBmb3JjZSBsaXR0bGUgZW5kaWFuIHRvIGZhY2lsaXRhdGUgZGVjb2Rpbmcgb24gbXVsdGlwbGUgaW1wbGVtZW50YXRpb25zXG4gICAgY29uc3QgX2NvbnZvQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDgpO1xuICAgIGNvbnN0IF9pbnQzMiA9IG5ldyBJbnQzMkFycmF5KF9jb252b0J1ZmZlcik7XG4gICAgY29uc3QgX2Zsb2F0MzIgPSBuZXcgRmxvYXQzMkFycmF5KF9jb252b0J1ZmZlcik7XG4gICAgY29uc3QgX2Zsb2F0NjQgPSBuZXcgRmxvYXQ2NEFycmF5KF9jb252b0J1ZmZlcik7XG4gICAgY29uc3QgX3VpbnQ2NCA9IG5ldyBCaWdVaW50NjRBcnJheShfY29udm9CdWZmZXIpO1xuICAgIGNvbnN0IF9pbnQ2NCA9IG5ldyBCaWdJbnQ2NEFycmF5KF9jb252b0J1ZmZlcik7XG4gICAgZnVuY3Rpb24gdXRmOFJlYWQoYnl0ZXMsIGl0LCBsZW5ndGgpIHtcbiAgICAgICAgLy8gYm91bmRhcnkgY2hlY2tcbiAgICAgICAgaWYgKGxlbmd0aCA+IGJ5dGVzLmxlbmd0aCAtIGl0Lm9mZnNldCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoIC0gaXQub2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJpbmcgPSAnJywgY2hyID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IGl0Lm9mZnNldCwgZW5kID0gaXQub2Zmc2V0ICsgbGVuZ3RoOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBieXRlID0gYnl0ZXNbaV07XG4gICAgICAgICAgICBpZiAoKGJ5dGUgJiAweDgwKSA9PT0gMHgwMCkge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChieXRlICYgMHhlMCkgPT09IDB4YzApIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGJ5dGUgJiAweDFmKSA8PCA2KSB8XG4gICAgICAgICAgICAgICAgICAgIChieXRlc1srK2ldICYgMHgzZikpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChieXRlICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGJ5dGUgJiAweDBmKSA8PCAxMikgfFxuICAgICAgICAgICAgICAgICAgICAoKGJ5dGVzWysraV0gJiAweDNmKSA8PCA2KSB8XG4gICAgICAgICAgICAgICAgICAgICgoYnl0ZXNbKytpXSAmIDB4M2YpIDw8IDApKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoYnl0ZSAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAgICAgICAgICAgY2hyID0gKChieXRlICYgMHgwNykgPDwgMTgpIHxcbiAgICAgICAgICAgICAgICAgICAgKChieXRlc1srK2ldICYgMHgzZikgPDwgMTIpIHxcbiAgICAgICAgICAgICAgICAgICAgKChieXRlc1srK2ldICYgMHgzZikgPDwgNikgfFxuICAgICAgICAgICAgICAgICAgICAoKGJ5dGVzWysraV0gJiAweDNmKSA8PCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hyID49IDB4MDEwMDAwKSB7IC8vIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgICAgICAgICAgIGNociAtPSAweDAxMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGNociA+Pj4gMTApICsgMHhEODAwLCAoY2hyICYgMHgzRkYpICsgMHhEQzAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gKGRvIG5vdCB0aHJvdyBlcnJvciB0byBhdm9pZCBzZXJ2ZXIvY2xpZW50IGZyb20gY3Jhc2hpbmcgZHVlIHRvIGhhY2sgYXR0ZW1wcylcbiAgICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlICcgKyBieXRlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdkZWNvZGUudXRmOFJlYWQoKTogSW52YWxpZCBieXRlICcgKyBieXRlICsgJyBhdCBvZmZzZXQgJyArIGkgKyAnLiBTa2lwIHRvIGVuZCBvZiBzdHJpbmc6ICcgKyAoaXQub2Zmc2V0ICsgbGVuZ3RoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpdC5vZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnQ4KGJ5dGVzLCBpdCkge1xuICAgICAgICByZXR1cm4gdWludDgoYnl0ZXMsIGl0KSA8PCAyNCA+PiAyNDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdWludDgoYnl0ZXMsIGl0KSB7XG4gICAgICAgIHJldHVybiBieXRlc1tpdC5vZmZzZXQrK107XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludDE2KGJ5dGVzLCBpdCkge1xuICAgICAgICByZXR1cm4gdWludDE2KGJ5dGVzLCBpdCkgPDwgMTYgPj4gMTY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVpbnQxNihieXRlcywgaXQpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzW2l0Lm9mZnNldCsrXSB8IGJ5dGVzW2l0Lm9mZnNldCsrXSA8PCA4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnQzMihieXRlcywgaXQpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzW2l0Lm9mZnNldCsrXSB8IGJ5dGVzW2l0Lm9mZnNldCsrXSA8PCA4IHwgYnl0ZXNbaXQub2Zmc2V0KytdIDw8IDE2IHwgYnl0ZXNbaXQub2Zmc2V0KytdIDw8IDI0O1xuICAgIH1cbiAgICBmdW5jdGlvbiB1aW50MzIoYnl0ZXMsIGl0KSB7XG4gICAgICAgIHJldHVybiBpbnQzMihieXRlcywgaXQpID4+PiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbG9hdDMyKGJ5dGVzLCBpdCkge1xuICAgICAgICBfaW50MzJbMF0gPSBpbnQzMihieXRlcywgaXQpO1xuICAgICAgICByZXR1cm4gX2Zsb2F0MzJbMF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsb2F0NjQoYnl0ZXMsIGl0KSB7XG4gICAgICAgIF9pbnQzMlswIF0gPSBpbnQzMihieXRlcywgaXQpO1xuICAgICAgICBfaW50MzJbMSBdID0gaW50MzIoYnl0ZXMsIGl0KTtcbiAgICAgICAgcmV0dXJuIF9mbG9hdDY0WzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnQ2NChieXRlcywgaXQpIHtcbiAgICAgICAgY29uc3QgbG93ID0gdWludDMyKGJ5dGVzLCBpdCk7XG4gICAgICAgIGNvbnN0IGhpZ2ggPSBpbnQzMihieXRlcywgaXQpICogTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICByZXR1cm4gaGlnaCArIGxvdztcbiAgICB9XG4gICAgZnVuY3Rpb24gdWludDY0KGJ5dGVzLCBpdCkge1xuICAgICAgICBjb25zdCBsb3cgPSB1aW50MzIoYnl0ZXMsIGl0KTtcbiAgICAgICAgY29uc3QgaGlnaCA9IHVpbnQzMihieXRlcywgaXQpICogTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICByZXR1cm4gaGlnaCArIGxvdztcbiAgICB9XG4gICAgZnVuY3Rpb24gYmlnaW50NjQoYnl0ZXMsIGl0KSB7XG4gICAgICAgIF9pbnQzMlswXSA9IGludDMyKGJ5dGVzLCBpdCk7XG4gICAgICAgIF9pbnQzMlsxXSA9IGludDMyKGJ5dGVzLCBpdCk7XG4gICAgICAgIHJldHVybiBfaW50NjRbMF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJpZ3VpbnQ2NChieXRlcywgaXQpIHtcbiAgICAgICAgX2ludDMyWzBdID0gaW50MzIoYnl0ZXMsIGl0KTtcbiAgICAgICAgX2ludDMyWzFdID0gaW50MzIoYnl0ZXMsIGl0KTtcbiAgICAgICAgcmV0dXJuIF91aW50NjRbMF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJvb2xlYW4oYnl0ZXMsIGl0KSB7XG4gICAgICAgIHJldHVybiB1aW50OChieXRlcywgaXQpID4gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyaW5nKGJ5dGVzLCBpdCkge1xuICAgICAgICBjb25zdCBwcmVmaXggPSBieXRlc1tpdC5vZmZzZXQrK107XG4gICAgICAgIGxldCBsZW5ndGg7XG4gICAgICAgIGlmIChwcmVmaXggPCAweGMwKSB7XG4gICAgICAgICAgICAvLyBmaXhzdHJcbiAgICAgICAgICAgIGxlbmd0aCA9IHByZWZpeCAmIDB4MWY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJlZml4ID09PSAweGQ5KSB7XG4gICAgICAgICAgICBsZW5ndGggPSB1aW50OChieXRlcywgaXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZWZpeCA9PT0gMHhkYSkge1xuICAgICAgICAgICAgbGVuZ3RoID0gdWludDE2KGJ5dGVzLCBpdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJlZml4ID09PSAweGRiKSB7XG4gICAgICAgICAgICBsZW5ndGggPSB1aW50MzIoYnl0ZXMsIGl0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRmOFJlYWQoYnl0ZXMsIGl0LCBsZW5ndGgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBudW1iZXIoYnl0ZXMsIGl0KSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGJ5dGVzW2l0Lm9mZnNldCsrXTtcbiAgICAgICAgaWYgKHByZWZpeCA8IDB4ODApIHtcbiAgICAgICAgICAgIC8vIHBvc2l0aXZlIGZpeGludFxuICAgICAgICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmVmaXggPT09IDB4Y2EpIHtcbiAgICAgICAgICAgIC8vIGZsb2F0IDMyXG4gICAgICAgICAgICByZXR1cm4gZmxvYXQzMihieXRlcywgaXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZWZpeCA9PT0gMHhjYikge1xuICAgICAgICAgICAgLy8gZmxvYXQgNjRcbiAgICAgICAgICAgIHJldHVybiBmbG9hdDY0KGJ5dGVzLCBpdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJlZml4ID09PSAweGNjKSB7XG4gICAgICAgICAgICAvLyB1aW50IDhcbiAgICAgICAgICAgIHJldHVybiB1aW50OChieXRlcywgaXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZWZpeCA9PT0gMHhjZCkge1xuICAgICAgICAgICAgLy8gdWludCAxNlxuICAgICAgICAgICAgcmV0dXJuIHVpbnQxNihieXRlcywgaXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZWZpeCA9PT0gMHhjZSkge1xuICAgICAgICAgICAgLy8gdWludCAzMlxuICAgICAgICAgICAgcmV0dXJuIHVpbnQzMihieXRlcywgaXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZWZpeCA9PT0gMHhjZikge1xuICAgICAgICAgICAgLy8gdWludCA2NFxuICAgICAgICAgICAgcmV0dXJuIHVpbnQ2NChieXRlcywgaXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZWZpeCA9PT0gMHhkMCkge1xuICAgICAgICAgICAgLy8gaW50IDhcbiAgICAgICAgICAgIHJldHVybiBpbnQ4KGJ5dGVzLCBpdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJlZml4ID09PSAweGQxKSB7XG4gICAgICAgICAgICAvLyBpbnQgMTZcbiAgICAgICAgICAgIHJldHVybiBpbnQxNihieXRlcywgaXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZWZpeCA9PT0gMHhkMikge1xuICAgICAgICAgICAgLy8gaW50IDMyXG4gICAgICAgICAgICByZXR1cm4gaW50MzIoYnl0ZXMsIGl0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmVmaXggPT09IDB4ZDMpIHtcbiAgICAgICAgICAgIC8vIGludCA2NFxuICAgICAgICAgICAgcmV0dXJuIGludDY0KGJ5dGVzLCBpdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJlZml4ID4gMHhkZikge1xuICAgICAgICAgICAgLy8gbmVnYXRpdmUgZml4aW50XG4gICAgICAgICAgICByZXR1cm4gKDB4ZmYgLSBwcmVmaXggKyAxKSAqIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cmluZ0NoZWNrKGJ5dGVzLCBpdCkge1xuICAgICAgICBjb25zdCBwcmVmaXggPSBieXRlc1tpdC5vZmZzZXRdO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAvLyBmaXhzdHJcbiAgICAgICAgKHByZWZpeCA8IDB4YzAgJiYgcHJlZml4ID4gMHhhMCkgfHxcbiAgICAgICAgICAgIC8vIHN0ciA4XG4gICAgICAgICAgICBwcmVmaXggPT09IDB4ZDkgfHxcbiAgICAgICAgICAgIC8vIHN0ciAxNlxuICAgICAgICAgICAgcHJlZml4ID09PSAweGRhIHx8XG4gICAgICAgICAgICAvLyBzdHIgMzJcbiAgICAgICAgICAgIHByZWZpeCA9PT0gMHhkYik7XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZSA9IHtcbiAgICAgICAgdXRmOFJlYWQsXG4gICAgICAgIGludDgsXG4gICAgICAgIHVpbnQ4LFxuICAgICAgICBpbnQxNixcbiAgICAgICAgdWludDE2LFxuICAgICAgICBpbnQzMixcbiAgICAgICAgdWludDMyLFxuICAgICAgICBmbG9hdDMyLFxuICAgICAgICBmbG9hdDY0LFxuICAgICAgICBpbnQ2NCxcbiAgICAgICAgdWludDY0LFxuICAgICAgICBiaWdpbnQ2NCxcbiAgICAgICAgYmlndWludDY0LFxuICAgICAgICBib29sZWFuLFxuICAgICAgICBzdHJpbmcsXG4gICAgICAgIG51bWJlcixcbiAgICAgICAgc3RyaW5nQ2hlY2ssXG4gICAgfTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyZWRUeXBlcyA9IHt9O1xuICAgIGNvbnN0IGlkZW50aWZpZXJzID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyVHlwZShpZGVudGlmaWVyLCBkZWZpbml0aW9uKSB7XG4gICAgICAgIGlmIChkZWZpbml0aW9uLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBpZGVudGlmaWVycy5zZXQoZGVmaW5pdGlvbi5jb25zdHJ1Y3RvciwgaWRlbnRpZmllcik7XG4gICAgICAgICAgICByZWdpc3RlcmVkVHlwZXNbaWRlbnRpZmllcl0gPSBkZWZpbml0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZpbml0aW9uLmVuY29kZSkge1xuICAgICAgICAgICAgZW5jb2RlW2lkZW50aWZpZXJdID0gZGVmaW5pdGlvbi5lbmNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmluaXRpb24uZGVjb2RlKSB7XG4gICAgICAgICAgICBkZWNvZGVbaWRlbnRpZmllcl0gPSBkZWZpbml0aW9uLmRlY29kZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUeXBlKGlkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRUeXBlc1tpZGVudGlmaWVyXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmaW5lQ3VzdG9tVHlwZXModHlwZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZGVudGlmaWVyIGluIHR5cGVzKSB7XG4gICAgICAgICAgICByZWdpc3RlclR5cGUoaWRlbnRpZmllciwgdHlwZXNbaWRlbnRpZmllcl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodCkgPT4gdHlwZSh0KTtcbiAgICB9XG5cbiAgICBjbGFzcyBUeXBlQ29udGV4dCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3IgaW5oZXJpdGFuY2Ugc3VwcG9ydFxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB3aGljaCBjbGFzc2VzIGV4dGVuZHMgd2hpY2guIChwYXJlbnQgLT4gY2hpbGRyZW4pXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgeyB0aGlzLmluaGVyaXRlZFR5cGVzID0gbmV3IE1hcCgpOyB9XG4gICAgICAgIHN0YXRpYyB7IHRoaXMuY2FjaGVkQ29udGV4dHMgPSBuZXcgTWFwKCk7IH1cbiAgICAgICAgc3RhdGljIHJlZ2lzdGVyKHRhcmdldCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCk7XG4gICAgICAgICAgICBpZiAocGFyZW50ICE9PSBTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5oZXJpdHMgPSBUeXBlQ29udGV4dC5pbmhlcml0ZWRUeXBlcy5nZXQocGFyZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIWluaGVyaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaGVyaXRzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICBUeXBlQ29udGV4dC5pbmhlcml0ZWRUeXBlcy5zZXQocGFyZW50LCBpbmhlcml0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluaGVyaXRzLmFkZCh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjYWNoZShyb290Q2xhc3MpIHtcbiAgICAgICAgICAgIGxldCBjb250ZXh0ID0gVHlwZUNvbnRleHQuY2FjaGVkQ29udGV4dHMuZ2V0KHJvb3RDbGFzcyk7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gbmV3IFR5cGVDb250ZXh0KHJvb3RDbGFzcyk7XG4gICAgICAgICAgICAgICAgVHlwZUNvbnRleHQuY2FjaGVkQ29udGV4dHMuc2V0KHJvb3RDbGFzcywgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdHJ1Y3Rvcihyb290Q2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuaGFzRmlsdGVycyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRGaWx0ZXJlZCA9IHt9O1xuICAgICAgICAgICAgaWYgKHJvb3RDbGFzcykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzY292ZXJUeXBlcyhyb290Q2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhhcyhzY2hlbWEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjaGVtYXMuaGFzKHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0KHR5cGVpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZXNbdHlwZWlkXTtcbiAgICAgICAgfVxuICAgICAgICBhZGQoc2NoZW1hLCB0eXBlaWQgPSB0aGlzLnNjaGVtYXMuc2l6ZSkge1xuICAgICAgICAgICAgLy8gc2tpcCBpZiBhbHJlYWR5IHJlZ2lzdGVyZWRcbiAgICAgICAgICAgIGlmICh0aGlzLnNjaGVtYXMuaGFzKHNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnR5cGVzW3R5cGVpZF0gPSBzY2hlbWE7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCB0byBhbGxvdyB1c2luZyBhbiBlbXB0eSBTY2hlbWEgKHdpdGggbm8gYEB0eXBlKClgIGZpZWxkcylcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBpZiAoc2NoZW1hW1N5bWJvbC5tZXRhZGF0YV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIE1ldGFkYXRhLmluaXRpYWxpemUoc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2NoZW1hcy5zZXQoc2NoZW1hLCB0eXBlaWQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VHlwZUlkKGtsYXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWFzLmdldChrbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgZGlzY292ZXJUeXBlcyhrbGFzcywgcGFyZW50VHlwZSwgcGFyZW50SW5kZXgsIHBhcmVudEhhc1ZpZXdUYWcpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRIYXNWaWV3VGFnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlckZpbHRlcmVkQnlQYXJlbnQoa2xhc3MsIHBhcmVudFR5cGUsIHBhcmVudEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNraXAgaWYgYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWRkKGtsYXNzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCBjbGFzc2VzIGluaGVyaXRlZCBmcm9tIHRoaXMgYmFzZSBjbGFzc1xuICAgICAgICAgICAgVHlwZUNvbnRleHQuaW5oZXJpdGVkVHlwZXMuZ2V0KGtsYXNzKT8uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2NvdmVyVHlwZXMoY2hpbGQsIHBhcmVudFR5cGUsIHBhcmVudEluZGV4LCBwYXJlbnRIYXNWaWV3VGFnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gYWRkIHBhcmVudCBjbGFzc2VzXG4gICAgICAgICAgICBsZXQgcGFyZW50ID0ga2xhc3M7XG4gICAgICAgICAgICB3aGlsZSAoKHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwYXJlbnQpKSAmJlxuICAgICAgICAgICAgICAgIHBhcmVudCAhPT0gU2NoZW1hICYmIC8vIHN0b3AgYXQgcm9vdCAoU2NoZW1hKVxuICAgICAgICAgICAgICAgIHBhcmVudCAhPT0gRnVuY3Rpb24ucHJvdG90eXBlIC8vIHN0b3AgYXQgcm9vdCAobm9uLVNjaGVtYSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzY292ZXJUeXBlcyhwYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSAoa2xhc3NbU3ltYm9sLm1ldGFkYXRhXSA/Pz0ge30pO1xuICAgICAgICAgICAgLy8gaWYgYW55IHNjaGVtYS9maWVsZCBoYXMgZmlsdGVycywgbWFyayBcImNvbnRleHRcIiBhcyBoYXZpbmcgZmlsdGVycy5cbiAgICAgICAgICAgIGlmIChtZXRhZGF0YVskdmlld0ZpZWxkSW5kZXhlc10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0ZpbHRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZEluZGV4IGluIG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBmaWVsZEluZGV4O1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IG1ldGFkYXRhW2luZGV4XS50eXBlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkSGFzVmlld1RhZyA9IChtZXRhZGF0YVtpbmRleF0udGFnICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGZpZWxkVHlwZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGZpZWxkVHlwZSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2NvdmVyVHlwZXMoZmllbGRUeXBlLCBrbGFzcywgaW5kZXgsIHBhcmVudEhhc1ZpZXdUYWcgfHwgZmllbGRIYXNWaWV3VGFnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBPYmplY3QudmFsdWVzKGZpZWxkVHlwZSlbMF07XG4gICAgICAgICAgICAgICAgICAgIC8vIHNraXAgcHJpbWl0aXZlIHR5cGVzXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHR5cGUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2NvdmVyVHlwZXModHlwZSwga2xhc3MsIGluZGV4LCBwYXJlbnRIYXNWaWV3VGFnIHx8IGZpZWxkSGFzVmlld1RhZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZWVwIHRyYWNrIG9mIHdoaWNoIGNsYXNzZXMgaGF2ZSBmaWx0ZXJzIGFwcGxpZWQuXG4gICAgICAgICAqIEZvcm1hdDogYCR7dHlwZWlkfS0ke3BhcmVudFR5cGVpZH0tJHtwYXJlbnRJbmRleH1gXG4gICAgICAgICAqL1xuICAgICAgICByZWdpc3RlckZpbHRlcmVkQnlQYXJlbnQoc2NoZW1hLCBwYXJlbnRUeXBlLCBwYXJlbnRJbmRleCkge1xuICAgICAgICAgICAgY29uc3QgdHlwZWlkID0gdGhpcy5zY2hlbWFzLmdldChzY2hlbWEpID8/IHRoaXMuc2NoZW1hcy5zaXplO1xuICAgICAgICAgICAgbGV0IGtleSA9IGAke3R5cGVpZH1gO1xuICAgICAgICAgICAgaWYgKHBhcmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICBrZXkgKz0gYC0ke3RoaXMuc2NoZW1hcy5nZXQocGFyZW50VHlwZSl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSArPSBgLSR7cGFyZW50SW5kZXh9YDtcbiAgICAgICAgICAgIHRoaXMucGFyZW50RmlsdGVyZWRba2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50RmlsdGVyZWQgPSBcIlwiO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5wYXJlbnRGaWx0ZXJlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBrZXkuc3BsaXQoXCItXCIpLm1hcChOdW1iZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkSW5kZXggPSBrZXlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHBhcmVudEZpbHRlcmVkICs9IGBcXG5cXHRcXHRgO1xuICAgICAgICAgICAgICAgIHBhcmVudEZpbHRlcmVkICs9IGAke2tleX06ICR7a2V5cy5yZXZlcnNlKCkubWFwKChpZCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtsYXNzID0gdGhpcy50eXBlc1tpZF07XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBrbGFzc1tTeW1ib2wubWV0YWRhdGFdO1xuICAgICAgICAgICAgICAgIGxldCB0eHQgPSBrbGFzcy5uYW1lO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHR4dCArPSBgWyR7bWV0YWRhdGFbZmllbGRJbmRleF0ubmFtZX1dYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3R4dH1gO1xuICAgICAgICAgICAgfSkuam9pbihcIiAtPiBcIil9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgVHlwZUNvbnRleHQgLT5cXG5gICtcbiAgICAgICAgICAgICAgICBgXFx0U2NoZW1hIHR5cGVzOiAke3RoaXMuc2NoZW1hcy5zaXplfVxcbmAgK1xuICAgICAgICAgICAgICAgIGBcXHRoYXNGaWx0ZXJzOiAke3RoaXMuaGFzRmlsdGVyc31cXG5gICtcbiAgICAgICAgICAgICAgICBgXFx0cGFyZW50RmlsdGVyZWQ6JHtwYXJlbnRGaWx0ZXJlZH1gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZFR5cGUodHlwZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgYXJyYXk6IGdldE5vcm1hbGl6ZWRUeXBlKHR5cGVbMF0pIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mICh0eXBlWyd0eXBlJ10pICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZVsndHlwZSddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzVFNFbnVtKHR5cGUpKSB7XG4gICAgICAgICAgICAvLyBEZXRlY3QgVFMgRW51bSB0eXBlIChlaXRoZXIgc3RyaW5nIG9yIG51bWJlcilcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0eXBlKS5ldmVyeShrZXkgPT4gdHlwZW9mIHR5cGVba2V5XSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICA/IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA6IFwibnVtYmVyXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGNvbGxlY3Rpb24gdHlwZXNcbiAgICAgICAgICAgIGNvbnN0IGNvbGxlY3Rpb25UeXBlID0gT2JqZWN0LmtleXModHlwZSkuZmluZChrID0+IHJlZ2lzdGVyZWRUeXBlc1trXSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uVHlwZSkge1xuICAgICAgICAgICAgICAgIHR5cGVbY29sbGVjdGlvblR5cGVdID0gZ2V0Tm9ybWFsaXplZFR5cGUodHlwZVtjb2xsZWN0aW9uVHlwZV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1RTRW51bShfZW51bSkge1xuICAgICAgICBpZiAodHlwZW9mIF9lbnVtID09PSAnZnVuY3Rpb24nICYmIF9lbnVtW1N5bWJvbC5tZXRhZGF0YV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoX2VudW0pO1xuICAgICAgICBjb25zdCBudW1lcmljRmllbGRzID0ga2V5cy5maWx0ZXIoayA9PiAvXFxkKy8udGVzdChrKSk7XG4gICAgICAgIC8vIENoZWNrIGZvciBudW1iZXIgZW51bSAoaGFzIG51bWVyaWMga2V5cyBhbmQgcmV2ZXJzZSBtYXBwaW5nKVxuICAgICAgICBpZiAobnVtZXJpY0ZpZWxkcy5sZW5ndGggPiAwICYmIG51bWVyaWNGaWVsZHMubGVuZ3RoID09PSAoa2V5cy5sZW5ndGggLyAyKSAmJiBfZW51bVtfZW51bVtudW1lcmljRmllbGRzWzBdXV0gPT0gbnVtZXJpY0ZpZWxkc1swXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHN0cmluZyBlbnVtIChhbGwgdmFsdWVzIGFyZSBzdHJpbmdzIGFuZCBrZXlzIG1hdGNoIHZhbHVlcylcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoID4gMCAmJiBrZXlzLmV2ZXJ5KGtleSA9PiB0eXBlb2YgX2VudW1ba2V5XSA9PT0gJ3N0cmluZycgJiYgX2VudW1ba2V5XSA9PT0ga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBNZXRhZGF0YSA9IHtcbiAgICAgICAgYWRkRmllbGQobWV0YWRhdGEsIGluZGV4LCBuYW1lLCB0eXBlLCBkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiA2NCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgZGVmaW5lIGZpZWxkICcke25hbWV9Jy5cXG5TY2hlbWEgaW5zdGFuY2VzIG1heSBvbmx5IGhhdmUgdXAgdG8gNjQgZmllbGRzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YWRhdGFbaW5kZXhdID0gT2JqZWN0LmFzc2lnbihtZXRhZGF0YVtpbmRleF0gfHwge30sIC8vIGF2b2lkIG92ZXJ3cml0aW5nIHByZXZpb3VzIGZpZWxkIG1ldGFkYXRhIChAb3duZWQgLyBAZGVwcmVjYXRlZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXROb3JtYWxpemVkVHlwZSh0eXBlKSxcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgXCJkZXNjcmlwdG9yc1wiIG1hcFxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1ldGFkYXRhLCAkZGVzY3JpcHRvcnMsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWV0YWRhdGFbJGRlc2NyaXB0b3JzXSB8fCB7fSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGVuY29kZXJcbiAgICAgICAgICAgICAgICBtZXRhZGF0YVskZGVzY3JpcHRvcnNdW25hbWVdID0gZGVzY3JpcHRvcjtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YVskZGVzY3JpcHRvcnNdW2BfJHtuYW1lfWBdID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGRlY29kZXJcbiAgICAgICAgICAgICAgICBtZXRhZGF0YVskZGVzY3JpcHRvcnNdW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYXAgLTEgYXMgbGFzdCBmaWVsZCBpbmRleFxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1ldGFkYXRhLCAkbnVtRmllbGRzLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGluZGV4LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBtYXAgZmllbGQgbmFtZSA9PiBpbmRleCAobm9uIGVudW1lcmFibGUpXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0YWRhdGEsIG5hbWUsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogaW5kZXgsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBpZiBjaGlsZCBSZWYvY29tcGxleCB0eXBlLCBhZGQgdG8gLTRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG1ldGFkYXRhW2luZGV4XS50eXBlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YVskcmVmVHlwZUZpZWxkSW5kZXhlc10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0YWRhdGEsICRyZWZUeXBlRmllbGRJbmRleGVzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1ldGFkYXRhWyRyZWZUeXBlRmllbGRJbmRleGVzXS5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0VGFnKG1ldGFkYXRhLCBmaWVsZE5hbWUsIHRhZykge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBtZXRhZGF0YVtmaWVsZE5hbWVdO1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBtZXRhZGF0YVtpbmRleF07XG4gICAgICAgICAgICAvLyBhZGQgJ3RhZycgdG8gdGhlIGZpZWxkXG4gICAgICAgICAgICBmaWVsZC50YWcgPSB0YWc7XG4gICAgICAgICAgICBpZiAoIW1ldGFkYXRhWyR2aWV3RmllbGRJbmRleGVzXSkge1xuICAgICAgICAgICAgICAgIC8vIC0yOiBhbGwgZmllbGQgaW5kZXhlcyB3aXRoIFwidmlld1wiIHRhZ1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRhZGF0YSwgJHZpZXdGaWVsZEluZGV4ZXMsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFtdLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gLTM6IGZpZWxkIGluZGV4ZXMgYnkgXCJ2aWV3XCIgdGFnXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1ldGFkYXRhLCAkZmllbGRJbmRleGVzQnlWaWV3VGFnLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YWRhdGFbJHZpZXdGaWVsZEluZGV4ZXNdLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgaWYgKCFtZXRhZGF0YVskZmllbGRJbmRleGVzQnlWaWV3VGFnXVt0YWddKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGFbJGZpZWxkSW5kZXhlc0J5Vmlld1RhZ11bdGFnXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YWRhdGFbJGZpZWxkSW5kZXhlc0J5Vmlld1RhZ11bdGFnXS5wdXNoKGluZGV4KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0RmllbGRzKHRhcmdldCwgZmllbGRzKSB7XG4gICAgICAgICAgICAvLyBmb3IgaW5oZXJpdGFuY2Ugc3VwcG9ydFxuICAgICAgICAgICAgY29uc3QgY29uc3RydWN0b3IgPSB0YXJnZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgVHlwZUNvbnRleHQucmVnaXN0ZXIoY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50Q2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50TWV0YWRhdGEgPSBwYXJlbnRDbGFzcyAmJiBwYXJlbnRDbGFzc1tTeW1ib2wubWV0YWRhdGFdO1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBNZXRhZGF0YS5pbml0aWFsaXplKGNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIC8vIFVzZSBTY2hlbWEncyBtZXRob2RzIGlmIG5vdCBkZWZpbmVkIGluIHRoZSBjbGFzc1xuICAgICAgICAgICAgaWYgKCFjb25zdHJ1Y3RvclskdHJhY2tdKSB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3JbJHRyYWNrXSA9IFNjaGVtYVskdHJhY2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb25zdHJ1Y3RvclskZW5jb2Rlcl0pIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvclskZW5jb2Rlcl0gPSBTY2hlbWFbJGVuY29kZXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb25zdHJ1Y3RvclskZGVjb2Rlcl0pIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvclskZGVjb2Rlcl0gPSBTY2hlbWFbJGRlY29kZXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb25zdHJ1Y3Rvci5wcm90b3R5cGUudG9KU09OKSB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlLnRvSlNPTiA9IFNjaGVtYS5wcm90b3R5cGUudG9KU09OO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGRldGVjdCBpbmRleCBmb3IgdGhpcyBmaWVsZCwgY29uc2lkZXJpbmcgaW5oZXJpdGFuY2VcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBsZXQgZmllbGRJbmRleCA9IG1ldGFkYXRhWyRudW1GaWVsZHNdIC8vIGN1cnJlbnQgc3RydWN0dXJlIGFscmVhZHkgaGFzIGZpZWxkcyBkZWZpbmVkXG4gICAgICAgICAgICAgICAgPz8gKHBhcmVudE1ldGFkYXRhICYmIHBhcmVudE1ldGFkYXRhWyRudW1GaWVsZHNdKSAvLyBwYXJlbnQgc3RydWN0dXJlIGhhcyBmaWVsZHMgZGVmaW5lZFxuICAgICAgICAgICAgICAgID8/IC0xOyAvLyBubyBmaWVsZHMgZGVmaW5lZFxuICAgICAgICAgICAgZmllbGRJbmRleCsrO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gZ2V0Tm9ybWFsaXplZFR5cGUoZmllbGRzW2ZpZWxkXSk7XG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IHRoaXMgY29kZSBpcyBkdXBsaWNhdGVkIGZyb20gQHR5cGUoKSBhbm5vdGF0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGxleFR5cGVLbGFzcyA9IHR5cGVvZiAoT2JqZWN0LmtleXModHlwZSlbMF0pID09PSBcInN0cmluZ1wiICYmIGdldFR5cGUoT2JqZWN0LmtleXModHlwZSlbMF0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkVHlwZSA9IChjb21wbGV4VHlwZUtsYXNzKVxuICAgICAgICAgICAgICAgICAgICA/IE9iamVjdC52YWx1ZXModHlwZSlbMF1cbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlO1xuICAgICAgICAgICAgICAgIE1ldGFkYXRhLmFkZEZpZWxkKG1ldGFkYXRhLCBmaWVsZEluZGV4LCBmaWVsZCwgdHlwZSwgZ2V0UHJvcGVydHlEZXNjcmlwdG9yKGBfJHtmaWVsZH1gLCBmaWVsZEluZGV4LCBjaGlsZFR5cGUsIGNvbXBsZXhUeXBlS2xhc3MpKTtcbiAgICAgICAgICAgICAgICBmaWVsZEluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9LFxuICAgICAgICBpc0RlcHJlY2F0ZWQobWV0YWRhdGEsIGZpZWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0YWRhdGFbZmllbGRdLmRlcHJlY2F0ZWQgPT09IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXQoa2xhc3MpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBVc2VkIG9ubHkgdG8gaW5pdGlhbGl6ZSBhbiBlbXB0eSBTY2hlbWEgKEVuY29kZXIjY29uc3RydWN0b3IpXG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUvcmVmYWN0b3IgdGhpcy4uLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0ge307XG4gICAgICAgICAgICBrbGFzc1tTeW1ib2wubWV0YWRhdGFdID0gbWV0YWRhdGE7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0YWRhdGEsICRudW1GaWVsZHMsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbGl6ZShjb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50Q2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50TWV0YWRhdGEgPSBwYXJlbnRDbGFzc1tTeW1ib2wubWV0YWRhdGFdO1xuICAgICAgICAgICAgbGV0IG1ldGFkYXRhID0gY29uc3RydWN0b3JbU3ltYm9sLm1ldGFkYXRhXSA/PyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGluaGVyaXRlZCBjbGFzc2VzIGhhdmUgdGhlaXIgb3duIG1ldGFkYXRhIG9iamVjdC5cbiAgICAgICAgICAgIGlmIChwYXJlbnRDbGFzcyAhPT0gU2NoZW1hICYmIG1ldGFkYXRhID09PSBwYXJlbnRNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50TWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gYXNzaWduIHBhcmVudCBtZXRhZGF0YSB0byBjdXJyZW50XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihtZXRhZGF0YSwgcGFyZW50TWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAvLyAkbnVtRmllbGRzXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRhZGF0YSwgJG51bUZpZWxkcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcmVudE1ldGFkYXRhWyRudW1GaWVsZHNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vICR2aWV3RmllbGRJbmRleGVzIC8gJGZpZWxkSW5kZXhlc0J5Vmlld1RhZ1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50TWV0YWRhdGFbJHZpZXdGaWVsZEluZGV4ZXNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRhZGF0YSwgJHZpZXdGaWVsZEluZGV4ZXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogWy4uLnBhcmVudE1ldGFkYXRhWyR2aWV3RmllbGRJbmRleGVzXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0YWRhdGEsICRmaWVsZEluZGV4ZXNCeVZpZXdUYWcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogeyAuLi5wYXJlbnRNZXRhZGF0YVskZmllbGRJbmRleGVzQnlWaWV3VGFnXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICRyZWZUeXBlRmllbGRJbmRleGVzXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRNZXRhZGF0YVskcmVmVHlwZUZpZWxkSW5kZXhlc10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1ldGFkYXRhLCAkcmVmVHlwZUZpZWxkSW5kZXhlcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbLi4ucGFyZW50TWV0YWRhdGFbJHJlZlR5cGVGaWVsZEluZGV4ZXNdXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAkZGVzY3JpcHRvcnNcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1ldGFkYXRhLCAkZGVzY3JpcHRvcnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7IC4uLnBhcmVudE1ldGFkYXRhWyRkZXNjcmlwdG9yc10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25zdHJ1Y3RvciwgU3ltYm9sLm1ldGFkYXRhLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgICAgICB9LFxuICAgICAgICBpc1ZhbGlkSW5zdGFuY2Uoa2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybiAoa2xhc3MuY29uc3RydWN0b3JbU3ltYm9sLm1ldGFkYXRhXSAmJlxuICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChrbGFzcy5jb25zdHJ1Y3RvcltTeW1ib2wubWV0YWRhdGFdLCAkbnVtRmllbGRzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEZpZWxkcyhrbGFzcykge1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBrbGFzc1tTeW1ib2wubWV0YWRhdGFdO1xuICAgICAgICAgICAgY29uc3QgZmllbGRzID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBtZXRhZGF0YVskbnVtRmllbGRzXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZmllbGRzW21ldGFkYXRhW2ldLm5hbWVdID0gbWV0YWRhdGFbaV0udHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWVsZHM7XG4gICAgICAgIH0sXG4gICAgICAgIGhhc1ZpZXdUYWdBdEluZGV4KG1ldGFkYXRhLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhPy5bJHZpZXdGaWVsZEluZGV4ZXNdPy5pbmNsdWRlcyhpbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2hhbmdlU2V0KHF1ZXVlUm9vdE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHsgaW5kZXhlczoge30sIG9wZXJhdGlvbnM6IFtdLCBxdWV1ZVJvb3ROb2RlIH07XG4gICAgfVxuICAgIC8vIExpbmtlZCBsaXN0IGhlbHBlciBmdW5jdGlvbnNcbiAgICBmdW5jdGlvbiBjcmVhdGVDaGFuZ2VUcmVlTGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIHsgbmV4dDogdW5kZWZpbmVkLCB0YWlsOiB1bmRlZmluZWQgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0T3BlcmF0aW9uQXRJbmRleChjaGFuZ2VTZXQsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbnNJbmRleCA9IGNoYW5nZVNldC5pbmRleGVzW2luZGV4XTtcbiAgICAgICAgaWYgKG9wZXJhdGlvbnNJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGFuZ2VTZXQuaW5kZXhlc1tpbmRleF0gPSBjaGFuZ2VTZXQub3BlcmF0aW9ucy5wdXNoKGluZGV4KSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2VTZXQub3BlcmF0aW9uc1tvcGVyYXRpb25zSW5kZXhdID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVsZXRlT3BlcmF0aW9uQXRJbmRleChjaGFuZ2VTZXQsIGluZGV4KSB7XG4gICAgICAgIGxldCBvcGVyYXRpb25zSW5kZXggPSBjaGFuZ2VTZXQuaW5kZXhlc1tpbmRleF07XG4gICAgICAgIGlmIChvcGVyYXRpb25zSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGlmIGluZGV4IGlzIG5vdCBmb3VuZCwgd2UgbmVlZCB0byBmaW5kIHRoZSBsYXN0IG9wZXJhdGlvblxuICAgICAgICAgICAgLy8gRklYTUU6IHRoaXMgaXMgbm90IHZlcnkgZWZmaWNpZW50XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gPiBTZWUgXCJzaG91bGQgYWxsb3cgY29uc2VjdXRpdmUgc3BsaWNlcyAoc2FtZSBwbGFjZSlcIiB0ZXN0c1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIG9wZXJhdGlvbnNJbmRleCA9IE9iamVjdC52YWx1ZXMoY2hhbmdlU2V0LmluZGV4ZXMpLmF0KC0xKTtcbiAgICAgICAgICAgIGluZGV4ID0gT2JqZWN0LmVudHJpZXMoY2hhbmdlU2V0LmluZGV4ZXMpLmZpbmQoKFtfLCB2YWx1ZV0pID0+IHZhbHVlID09PSBvcGVyYXRpb25zSW5kZXgpPy5bMF07XG4gICAgICAgIH1cbiAgICAgICAgY2hhbmdlU2V0Lm9wZXJhdGlvbnNbb3BlcmF0aW9uc0luZGV4XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZGVsZXRlIGNoYW5nZVNldC5pbmRleGVzW2luZGV4XTtcbiAgICB9XG4gICAgY2xhc3MgQ2hhbmdlVHJlZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHJlZikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHRoaXMgc3RydWN0dXJlIGlzIHBhcmVudCBvZiBhIGZpbHRlcmVkIHN0cnVjdHVyZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc0ZpbHRlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmluZGV4ZWRPcGVyYXRpb25zID0ge307XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVE9ETzpcbiAgICAgICAgICAgIC8vICAgdHJ5IHN0b3JpbmcgdGhlIGluZGV4ICsgb3BlcmF0aW9uIHBlciBpdGVtLlxuICAgICAgICAgICAgLy8gICBleGFtcGxlOiAxMDI0ICYgMTAyNSA9PiBBREQsIDEwMjYgPT4gREVMRVRFXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gPT4gaHR0cHM6Ly9jaGF0Z3B0LmNvbS9zaGFyZS82NzEwN2QwYy1iYzIwLTgwMDQtODU4My04M2IxN2RkN2MxOTZcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB0aGlzLmNoYW5nZXMgPSB7IGluZGV4ZXM6IHt9LCBvcGVyYXRpb25zOiBbXSB9O1xuICAgICAgICAgICAgdGhpcy5hbGxDaGFuZ2VzID0geyBpbmRleGVzOiB7fSwgb3BlcmF0aW9uczogW10gfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSXMgdGhpcyBhIG5ldyBpbnN0YW5jZT8gVXNlZCBvbiBBcnJheVNjaGVtYSB0byBkZXRlcm1pbmUgT1BFUkFUSU9OLk1PVkVfQU5EX0FERCBvcGVyYXRpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNOZXcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yZWYgPSByZWY7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhID0gcmVmLmNvbnN0cnVjdG9yW1N5bWJvbC5tZXRhZGF0YV07XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRG9lcyB0aGlzIHN0cnVjdHVyZSBoYXZlIFwiZmlsdGVyc1wiIGRlY2xhcmVkP1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGlmICh0aGlzLm1ldGFkYXRhPy5bJHZpZXdGaWVsZEluZGV4ZXNdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxGaWx0ZXJlZENoYW5nZXMgPSB7IGluZGV4ZXM6IHt9LCBvcGVyYXRpb25zOiBbXSB9O1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRDaGFuZ2VzID0geyBpbmRleGVzOiB7fSwgb3BlcmF0aW9uczogW10gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRSb290KHJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgICAgICBjb25zdCBpc05ld0NoYW5nZVRyZWUgPSB0aGlzLnJvb3QuYWRkKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5jaGVja0lzRmlsdGVyZWQodGhpcy5wYXJlbnQsIHRoaXMucGFyZW50SW5kZXgsIGlzTmV3Q2hhbmdlVHJlZSk7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXQgcm9vdCBvbiBjaGlsZCBzdHJ1Y3R1cmVzXG4gICAgICAgICAgICBpZiAoaXNOZXdDaGFuZ2VUcmVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JFYWNoQ2hpbGQoKGNoaWxkLCBfKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5yb290ICE9PSByb290KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5zZXRSb290KHJvb3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC5hZGQoY2hpbGQpOyAvLyBpbmNyZW1lbnQgcmVmQ291bnRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldFBhcmVudChwYXJlbnQsIHJvb3QsIHBhcmVudEluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmFkZFBhcmVudChwYXJlbnQsIHBhcmVudEluZGV4KTtcbiAgICAgICAgICAgIC8vIGF2b2lkIHNldHRpbmcgcGFyZW50cyB3aXRoIGVtcHR5IGByb290YFxuICAgICAgICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNOZXdDaGFuZ2VUcmVlID0gcm9vdC5hZGQodGhpcyk7XG4gICAgICAgICAgICAvLyBza2lwIGlmIHBhcmVudCBpcyBhbHJlYWR5IHNldFxuICAgICAgICAgICAgaWYgKHJvb3QgIT09IHRoaXMucm9vdCkge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0lzRmlsdGVyZWQocGFyZW50LCBwYXJlbnRJbmRleCwgaXNOZXdDaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFzc2lnbiBzYW1lIHBhcmVudCBvbiBjaGlsZCBzdHJ1Y3R1cmVzXG4gICAgICAgICAgICBpZiAoaXNOZXdDaGFuZ2VUcmVlKSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBhc3NpZ24gc2FtZSBwYXJlbnQgb24gY2hpbGQgc3RydWN0dXJlc1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgdGhpcy5mb3JFYWNoQ2hpbGQoKGNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQucm9vdCA9PT0gcm9vdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlLWFzc2lnbmluZyBhIGNoaWxkIG9mIHRoZSBzYW1lIHJvb3QsIG1vdmUgaXQgbmV4dCB0byBwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIGVuY29kaW5nIG9yZGVyIGlzIHByZXNlcnZlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QuYWRkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QubW92ZU5leHRUb1BhcmVudChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuc2V0UGFyZW50KHRoaXMucmVmLCByb290LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yRWFjaENoaWxkKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gYXNzaWduIHNhbWUgcGFyZW50IG9uIGNoaWxkIHN0cnVjdHVyZXNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBpZiAodGhpcy5yZWZbJGNoaWxkVHlwZV0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh0aGlzLnJlZlskY2hpbGRUeXBlXSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFwU2NoZW1hIC8gQXJyYXlTY2hlbWEsIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5yZWYuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IC8vIHNwYXJzZSBhcnJheXMgY2FuIGhhdmUgdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodmFsdWVbJGNoYW5nZXNdLCB0aGlzLmluZGV4ZXM/LltrZXldID8/IGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHRoaXMubWV0YWRhdGE/LlskcmVmVHlwZUZpZWxkSW5kZXhlc10gPz8gW10pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLm1ldGFkYXRhW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnJlZltmaWVsZC5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodmFsdWVbJGNoYW5nZXNdLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9wZXJhdGlvbihvcCkge1xuICAgICAgICAgICAgLy8gb3BlcmF0aW9ucyB3aXRob3V0IGluZGV4IHVzZSBuZWdhdGl2ZSB2YWx1ZXMgdG8gcmVwcmVzZW50IHRoZW1cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgY2hlY2tlZCBkdXJpbmcgLmVuY29kZSgpIHRpbWUuXG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJlZENoYW5nZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRDaGFuZ2VzLm9wZXJhdGlvbnMucHVzaCgtb3ApO1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdD8uZW5xdWV1ZUNoYW5nZVRyZWUodGhpcywgJ2ZpbHRlcmVkQ2hhbmdlcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLm9wZXJhdGlvbnMucHVzaCgtb3ApO1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdD8uZW5xdWV1ZUNoYW5nZVRyZWUodGhpcywgJ2NoYW5nZXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGFuZ2UoaW5kZXgsIG9wZXJhdGlvbiA9IGV4cG9ydHMuT1BFUkFUSU9OLkFERCkge1xuICAgICAgICAgICAgY29uc3QgaXNGaWx0ZXJlZCA9IHRoaXMuaXNGaWx0ZXJlZCB8fCAodGhpcy5tZXRhZGF0YT8uW2luZGV4XT8udGFnICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlU2V0ID0gKGlzRmlsdGVyZWQpXG4gICAgICAgICAgICAgICAgPyB0aGlzLmZpbHRlcmVkQ2hhbmdlc1xuICAgICAgICAgICAgICAgIDogdGhpcy5jaGFuZ2VzO1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNPcGVyYXRpb24gPSB0aGlzLmluZGV4ZWRPcGVyYXRpb25zW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghcHJldmlvdXNPcGVyYXRpb24gfHwgcHJldmlvdXNPcGVyYXRpb24gPT09IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wID0gKCFwcmV2aW91c09wZXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgPyBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgOiAocHJldmlvdXNPcGVyYXRpb24gPT09IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFX0FORF9BRERcbiAgICAgICAgICAgICAgICAgICAgICAgIDogb3BlcmF0aW9uO1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogYXJlIERFTEVURSBvcGVyYXRpb25zIGJlaW5nIGVuY29kZWQgYXMgQUREIGhlcmUgPz9cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhlZE9wZXJhdGlvbnNbaW5kZXhdID0gb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRPcGVyYXRpb25BdEluZGV4KGNoYW5nZVNldCwgaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGlzRmlsdGVyZWQpIHtcbiAgICAgICAgICAgICAgICBzZXRPcGVyYXRpb25BdEluZGV4KHRoaXMuYWxsRmlsdGVyZWRDaGFuZ2VzLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QuZW5xdWV1ZUNoYW5nZVRyZWUodGhpcywgJ2ZpbHRlcmVkQ2hhbmdlcycpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QuZW5xdWV1ZUNoYW5nZVRyZWUodGhpcywgJ2FsbEZpbHRlcmVkQ2hhbmdlcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldE9wZXJhdGlvbkF0SW5kZXgodGhpcy5hbGxDaGFuZ2VzLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290Py5lbnF1ZXVlQ2hhbmdlVHJlZSh0aGlzLCAnY2hhbmdlcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNoaWZ0Q2hhbmdlSW5kZXhlcyhzaGlmdEluZGV4KSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVXNlZCBvbmx5IGR1cmluZzpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAtIEFycmF5U2NoZW1hI3Vuc2hpZnQoKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZVNldCA9ICh0aGlzLmlzRmlsdGVyZWQpXG4gICAgICAgICAgICAgICAgPyB0aGlzLmZpbHRlcmVkQ2hhbmdlc1xuICAgICAgICAgICAgICAgIDogdGhpcy5jaGFuZ2VzO1xuICAgICAgICAgICAgY29uc3QgbmV3SW5kZXhlZE9wZXJhdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4ZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggaW4gdGhpcy5pbmRleGVkT3BlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgIG5ld0luZGV4ZWRPcGVyYXRpb25zW051bWJlcihpbmRleCkgKyBzaGlmdEluZGV4XSA9IHRoaXMuaW5kZXhlZE9wZXJhdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIG5ld0luZGV4ZXNbTnVtYmVyKGluZGV4KSArIHNoaWZ0SW5kZXhdID0gY2hhbmdlU2V0LmluZGV4ZXNbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbmRleGVkT3BlcmF0aW9ucyA9IG5ld0luZGV4ZWRPcGVyYXRpb25zO1xuICAgICAgICAgICAgY2hhbmdlU2V0LmluZGV4ZXMgPSBuZXdJbmRleGVzO1xuICAgICAgICAgICAgY2hhbmdlU2V0Lm9wZXJhdGlvbnMgPSBjaGFuZ2VTZXQub3BlcmF0aW9ucy5tYXAoKGluZGV4KSA9PiBpbmRleCArIHNoaWZ0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHNoaWZ0QWxsQ2hhbmdlSW5kZXhlcyhzaGlmdEluZGV4LCBzdGFydEluZGV4ID0gMCkge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFVzZWQgb25seSBkdXJpbmc6XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gLSBBcnJheVNjaGVtYSNzcGxpY2UoKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcmVkQ2hhbmdlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hpZnRBbGxDaGFuZ2VJbmRleGVzKHNoaWZ0SW5kZXgsIHN0YXJ0SW5kZXgsIHRoaXMuYWxsRmlsdGVyZWRDaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGlmdEFsbENoYW5nZUluZGV4ZXMoc2hpZnRJbmRleCwgc3RhcnRJbmRleCwgdGhpcy5hbGxDaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NoaWZ0QWxsQ2hhbmdlSW5kZXhlcyhzaGlmdEluZGV4LCBzdGFydEluZGV4LCB0aGlzLmFsbENoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9zaGlmdEFsbENoYW5nZUluZGV4ZXMoc2hpZnRJbmRleCwgc3RhcnRJbmRleCA9IDAsIGNoYW5nZVNldCkge1xuICAgICAgICAgICAgY29uc3QgbmV3SW5kZXhlcyA9IHt9O1xuICAgICAgICAgICAgbGV0IG5ld0tleSA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGFuZ2VTZXQuaW5kZXhlcykge1xuICAgICAgICAgICAgICAgIG5ld0luZGV4ZXNbbmV3S2V5KytdID0gY2hhbmdlU2V0LmluZGV4ZXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYW5nZVNldC5pbmRleGVzID0gbmV3SW5kZXhlcztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbmdlU2V0Lm9wZXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGNoYW5nZVNldC5vcGVyYXRpb25zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlU2V0Lm9wZXJhdGlvbnNbaV0gPSBpbmRleCArIHNoaWZ0SW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluZGV4ZWRPcGVyYXRpb24oaW5kZXgsIG9wZXJhdGlvbiwgYWxsQ2hhbmdlc0luZGV4ID0gaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhlZE9wZXJhdGlvbnNbaW5kZXhdID0gb3BlcmF0aW9uO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyZWRDaGFuZ2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZXRPcGVyYXRpb25BdEluZGV4KHRoaXMuYWxsRmlsdGVyZWRDaGFuZ2VzLCBhbGxDaGFuZ2VzSW5kZXgpO1xuICAgICAgICAgICAgICAgIHNldE9wZXJhdGlvbkF0SW5kZXgodGhpcy5maWx0ZXJlZENoYW5nZXMsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3Q/LmVucXVldWVDaGFuZ2VUcmVlKHRoaXMsICdmaWx0ZXJlZENoYW5nZXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldE9wZXJhdGlvbkF0SW5kZXgodGhpcy5hbGxDaGFuZ2VzLCBhbGxDaGFuZ2VzSW5kZXgpO1xuICAgICAgICAgICAgICAgIHNldE9wZXJhdGlvbkF0SW5kZXgodGhpcy5jaGFuZ2VzLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290Py5lbnF1ZXVlQ2hhbmdlVHJlZSh0aGlzLCAnY2hhbmdlcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldFR5cGUoaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBjaGlsZCB0eXBlIGZyb20gcGFyZW50IHN0cnVjdHVyZS5cbiAgICAgICAgICAgIC8vIC0gW1wic3RyaW5nXCJdID0+IFwic3RyaW5nXCJcbiAgICAgICAgICAgIC8vIC0geyBtYXA6IFwic3RyaW5nXCIgfSA9PiBcInN0cmluZ1wiXG4gICAgICAgICAgICAvLyAtIHsgc2V0OiBcInN0cmluZ1wiIH0gPT4gXCJzdHJpbmdcIlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHRoaXMucmVmWyRjaGlsZFR5cGVdIHx8IC8vIEFycmF5U2NoZW1hIHwgTWFwU2NoZW1hIHwgU2V0U2NoZW1hIHwgQ29sbGVjdGlvblNjaGVtYVxuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGFbaW5kZXhdLnR5cGUgLy8gU2NoZW1hXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGdldENoYW5nZShpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhlZE9wZXJhdGlvbnNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHVzZWQgZHVyaW5nIGAuZW5jb2RlKClgXG4gICAgICAgIC8vXG4gICAgICAgIGdldFZhbHVlKGluZGV4LCBpc0VuY29kZUFsbCA9IGZhbHNlKSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gYGlzRW5jb2RlQWxsYCBwYXJhbSBpcyBvbmx5IHVzZWQgYnkgQXJyYXlTY2hlbWFcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZbJGdldEJ5SW5kZXhdKGluZGV4LCBpc0VuY29kZUFsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlKGluZGV4LCBvcGVyYXRpb24sIGFsbENoYW5nZXNJbmRleCA9IGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQGNvbHlzZXVzL3NjaGVtYSAke3RoaXMucmVmLmNvbnN0cnVjdG9yLm5hbWV9OiB0cnlpbmcgdG8gZGVsZXRlIG5vbi1leGlzdGluZyBpbmRleCAnJHtpbmRleH0nYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hhbmdlU2V0ID0gKHRoaXMuZmlsdGVyZWRDaGFuZ2VzICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgPyB0aGlzLmZpbHRlcmVkQ2hhbmdlc1xuICAgICAgICAgICAgICAgIDogdGhpcy5jaGFuZ2VzO1xuICAgICAgICAgICAgdGhpcy5pbmRleGVkT3BlcmF0aW9uc1tpbmRleF0gPSBvcGVyYXRpb24gPz8gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFO1xuICAgICAgICAgICAgc2V0T3BlcmF0aW9uQXRJbmRleChjaGFuZ2VTZXQsIGluZGV4KTtcbiAgICAgICAgICAgIGRlbGV0ZU9wZXJhdGlvbkF0SW5kZXgodGhpcy5hbGxDaGFuZ2VzLCBhbGxDaGFuZ2VzSW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUoaW5kZXgpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGByb290YCByZWZlcmVuY2VcbiAgICAgICAgICAgIGlmIChwcmV2aW91c1ZhbHVlICYmIHByZXZpb3VzVmFsdWVbJGNoYW5nZXNdKSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogdGhpcy5yb290IGlzIFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIGJlaW5nIGNhbGxlZCBhdCBkZWNvZGluZyB0aW1lIHdoZW4gYSBERUxFVEUgb3BlcmF0aW9uIGlzIGZvdW5kLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gLSBUaGlzIGlzIGR1ZSB0byB1c2luZyB0aGUgY29uY3JldGUgU2NoZW1hIGNsYXNzIGF0IGRlY29kaW5nIHRpbWUuXG4gICAgICAgICAgICAgICAgLy8gLSBcIlJlZmxlY3RlZFwiIHN0cnVjdHVyZXMgZG8gbm90IGhhdmUgdGhpcyBwcm9ibGVtLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gKFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9ycyBzaG91bGQgTk9UIGJlIHVzZWQgYXQgZGVjb2RpbmcgdGltZS4gb25seSBhdCBlbmNvZGluZyB0aW1lLilcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdD8ucmVtb3ZlKHByZXZpb3VzVmFsdWVbJGNoYW5nZXNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBGSVhNRTogdGhpcyBpcyBsb29raW5nIGEgdWdseSBhbmQgcmVwZWF0ZWRcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJlZENoYW5nZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZU9wZXJhdGlvbkF0SW5kZXgodGhpcy5hbGxGaWx0ZXJlZENoYW5nZXMsIGFsbENoYW5nZXNJbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290Py5lbnF1ZXVlQ2hhbmdlVHJlZSh0aGlzLCAnZmlsdGVyZWRDaGFuZ2VzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3Q/LmVucXVldWVDaGFuZ2VUcmVlKHRoaXMsICdjaGFuZ2VzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbmRFbmNvZGUoY2hhbmdlU2V0TmFtZSkge1xuICAgICAgICAgICAgdGhpcy5pbmRleGVkT3BlcmF0aW9ucyA9IHt9O1xuICAgICAgICAgICAgLy8gY2xlYXIgY2hhbmdlc2V0XG4gICAgICAgICAgICB0aGlzW2NoYW5nZVNldE5hbWVdID0gY3JlYXRlQ2hhbmdlU2V0KCk7XG4gICAgICAgICAgICAvLyBBcnJheVNjaGVtYSBhbmQgTWFwU2NoZW1hIGhhdmUgYSBjdXN0b20gXCJlbmNvZGUgZW5kXCIgbWV0aG9kXG4gICAgICAgICAgICB0aGlzLnJlZlskb25FbmNvZGVFbmRdPy4oKTtcbiAgICAgICAgICAgIC8vIE5vdCBhIG5ldyBpbnN0YW5jZSBhbnltb3JlXG4gICAgICAgICAgICB0aGlzLmlzTmV3ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZGlzY2FyZChkaXNjYXJkQWxsID0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyA+IE1hcFNjaGVtYTpcbiAgICAgICAgICAgIC8vICAgICAgUmVtb3ZlIGNhY2hlZCBrZXkgdG8gZW5zdXJlIEFERCBvcGVyYXRpb25zIGlzIHVuc2VkIGluc3RlYWQgb2ZcbiAgICAgICAgICAgIC8vICAgICAgUkVQTEFDRSBpbiBjYXNlIHNhbWUga2V5IGlzIHVzZWQgb24gbmV4dCBwYXRjaGVzLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHRoaXMucmVmWyRvbkVuY29kZUVuZF0/LigpO1xuICAgICAgICAgICAgdGhpcy5pbmRleGVkT3BlcmF0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzID0gY3JlYXRlQ2hhbmdlU2V0KHRoaXMuY2hhbmdlcy5xdWV1ZVJvb3ROb2RlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcmVkQ2hhbmdlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJlZENoYW5nZXMgPSBjcmVhdGVDaGFuZ2VTZXQodGhpcy5maWx0ZXJlZENoYW5nZXMucXVldWVSb290Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzY2FyZEFsbCkge1xuICAgICAgICAgICAgICAgIC8vIHByZXNlcnZlIHF1ZXVlUm9vdE5vZGUgcmVmZXJlbmNlc1xuICAgICAgICAgICAgICAgIHRoaXMuYWxsQ2hhbmdlcyA9IGNyZWF0ZUNoYW5nZVNldCh0aGlzLmFsbENoYW5nZXMucXVldWVSb290Tm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxsRmlsdGVyZWRDaGFuZ2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGxGaWx0ZXJlZENoYW5nZXMgPSBjcmVhdGVDaGFuZ2VTZXQodGhpcy5hbGxGaWx0ZXJlZENoYW5nZXMucXVldWVSb290Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWN1cnNpdmVseSBkaXNjYXJkIGFsbCBjaGFuZ2VzIGZyb20gdGhpcywgYW5kIGNoaWxkIHN0cnVjdHVyZXMuXG4gICAgICAgICAqIChVc2VkIGluIHRlc3RzIG9ubHkpXG4gICAgICAgICAqL1xuICAgICAgICBkaXNjYXJkQWxsKCkge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuaW5kZXhlZE9wZXJhdGlvbnMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoTnVtYmVyKGtleXNbaV0pKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWVbJGNoYW5nZXNdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlWyRjaGFuZ2VzXS5kaXNjYXJkQWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXNjYXJkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGNoYW5nZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gKE9iamVjdC5lbnRyaWVzKHRoaXMuaW5kZXhlZE9wZXJhdGlvbnMpLmxlbmd0aCA+IDApO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrSXNGaWx0ZXJlZChwYXJlbnQsIHBhcmVudEluZGV4LCBpc05ld0NoYW5nZVRyZWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3QudHlwZXMuaGFzRmlsdGVycykge1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gQXQgU2NoZW1hIGluaXRpYWxpemF0aW9uLCB0aGUgXCJyb290XCIgc3RydWN0dXJlIG1pZ2h0IG5vdCBiZSBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAvLyB5ZXQsIGFzIGl0IG9ubHkgZG9lcyBvbmNlIHRoZSBcIkVuY29kZXJcIiBoYXMgYmVlbiBzZXQgdXAuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBTbyB0aGUgXCJwYXJlbnRcIiBtYXkgYmUgYWxyZWFkeSBzZXQgd2l0aG91dCBhIFwicm9vdFwiLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tGaWx0ZXJlZEJ5UGFyZW50KHBhcmVudCwgcGFyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcmVkQ2hhbmdlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdD8uZW5xdWV1ZUNoYW5nZVRyZWUodGhpcywgJ2ZpbHRlcmVkQ2hhbmdlcycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOZXdDaGFuZ2VUcmVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3Q/LmVucXVldWVDaGFuZ2VUcmVlKHRoaXMsICdhbGxGaWx0ZXJlZENoYW5nZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5pc0ZpbHRlcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290Py5lbnF1ZXVlQ2hhbmdlVHJlZSh0aGlzLCAnY2hhbmdlcycpO1xuICAgICAgICAgICAgICAgIGlmIChpc05ld0NoYW5nZVRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290Py5lbnF1ZXVlQ2hhbmdlVHJlZSh0aGlzLCAnYWxsQ2hhbmdlcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfY2hlY2tGaWx0ZXJlZEJ5UGFyZW50KHBhcmVudCwgcGFyZW50SW5kZXgpIHtcbiAgICAgICAgICAgIC8vIHNraXAgaWYgcGFyZW50IGlzIG5vdCBzZXRcbiAgICAgICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEFycmF5U2NoZW1hIHwgTWFwU2NoZW1hIC0gZ2V0IHRoZSBjaGlsZCB0eXBlXG4gICAgICAgICAgICAvLyAoaWYgcmVmVHlwZSBpcyB0eXBlb2Ygc3RyaW5nLCB0aGUgcGFyZW50RmlsdGVyZWRba2V5XSBiZWxvdyB3aWxsIGFsd2F5cyBiZSBpbnZhbGlkKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGNvbnN0IHJlZlR5cGUgPSBNZXRhZGF0YS5pc1ZhbGlkSW5zdGFuY2UodGhpcy5yZWYpXG4gICAgICAgICAgICAgICAgPyB0aGlzLnJlZi5jb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIDogdGhpcy5yZWZbJGNoaWxkVHlwZV07XG4gICAgICAgICAgICBsZXQgcGFyZW50Q2hhbmdlVHJlZTtcbiAgICAgICAgICAgIGxldCBwYXJlbnRJc0NvbGxlY3Rpb24gPSAhTWV0YWRhdGEuaXNWYWxpZEluc3RhbmNlKHBhcmVudCk7XG4gICAgICAgICAgICBpZiAocGFyZW50SXNDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Q2hhbmdlVHJlZSA9IHBhcmVudFskY2hhbmdlc107XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Q2hhbmdlVHJlZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgcGFyZW50SW5kZXggPSBwYXJlbnRDaGFuZ2VUcmVlLnBhcmVudEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Q2hhbmdlVHJlZSA9IHBhcmVudFskY2hhbmdlc107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRDb25zdHJ1Y3RvciA9IHBhcmVudC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGxldCBrZXkgPSBgJHt0aGlzLnJvb3QudHlwZXMuZ2V0VHlwZUlkKHJlZlR5cGUpfWA7XG4gICAgICAgICAgICBpZiAocGFyZW50Q29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICBrZXkgKz0gYC0ke3RoaXMucm9vdC50eXBlcy5zY2hlbWFzLmdldChwYXJlbnRDb25zdHJ1Y3Rvcil9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSArPSBgLSR7cGFyZW50SW5kZXh9YDtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkSGFzVmlld1RhZyA9IE1ldGFkYXRhLmhhc1ZpZXdUYWdBdEluZGV4KHBhcmVudENvbnN0cnVjdG9yPy5bU3ltYm9sLm1ldGFkYXRhXSwgcGFyZW50SW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5pc0ZpbHRlcmVkID0gcGFyZW50WyRjaGFuZ2VzXS5pc0ZpbHRlcmVkIC8vIGluIGNhc2UgcGFyZW50IGlzIGFscmVhZHkgZmlsdGVyZWRcbiAgICAgICAgICAgICAgICB8fCB0aGlzLnJvb3QudHlwZXMucGFyZW50RmlsdGVyZWRba2V5XVxuICAgICAgICAgICAgICAgIHx8IGZpZWxkSGFzVmlld1RhZztcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBcImlzRmlsdGVyZWRcIiBtYXkgbm90IGJlIGltZWRpYWxlbHkgYXZhaWxhYmxlIGR1cmluZyBgY2hhbmdlKClgIGR1ZSB0byB0aGUgaW5zdGFuY2Ugbm90IGJlaW5nIGF0dGFjaGVkIHRvIHRoZSByb290IHlldC5cbiAgICAgICAgICAgIC8vIHdoZW4gaXQncyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gZW5xdWV1ZSB0aGUgXCJjaGFuZ2VzXCIgY2hhbmdlc2V0IGludG8gdGhlIFwiZmlsdGVyZWRDaGFuZ2VzXCIgY2hhbmdlc2V0LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGlmICh0aGlzLmlzRmlsdGVyZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzVmlzaWJpbGl0eVNoYXJlZFdpdGhQYXJlbnQgPSAocGFyZW50Q2hhbmdlVHJlZS5pc0ZpbHRlcmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiAocmVmVHlwZSkgIT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZpZWxkSGFzVmlld1RhZyAmJlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJc0NvbGxlY3Rpb24pO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5maWx0ZXJlZENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJlZENoYW5nZXMgPSBjcmVhdGVDaGFuZ2VTZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGxGaWx0ZXJlZENoYW5nZXMgPSBjcmVhdGVDaGFuZ2VTZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbmdlcy5vcGVyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLm9wZXJhdGlvbnMuZm9yRWFjaCgoaW5kZXgpID0+IHNldE9wZXJhdGlvbkF0SW5kZXgodGhpcy5maWx0ZXJlZENoYW5nZXMsIGluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxsQ2hhbmdlcy5vcGVyYXRpb25zLmZvckVhY2goKGluZGV4KSA9PiBzZXRPcGVyYXRpb25BdEluZGV4KHRoaXMuYWxsRmlsdGVyZWRDaGFuZ2VzLCBpbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZXMgPSBjcmVhdGVDaGFuZ2VTZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGxDaGFuZ2VzID0gY3JlYXRlQ2hhbmdlU2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGltbWVkaWF0ZSBwYXJlbnRcbiAgICAgICAgICovXG4gICAgICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRDaGFpbj8ucmVmO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGltbWVkaWF0ZSBwYXJlbnQgaW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIGdldCBwYXJlbnRJbmRleCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudENoYWluPy5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGEgcGFyZW50IHRvIHRoZSBjaGFpblxuICAgICAgICAgKi9cbiAgICAgICAgYWRkUGFyZW50KHBhcmVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgcGFyZW50IGFscmVhZHkgZXhpc3RzIGluIHRoZSBjaGFpblxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzUGFyZW50KChwLCBfKSA9PiBwWyRjaGFuZ2VzXSA9PT0gcGFyZW50WyRjaGFuZ2VzXSkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiAodGhpcy5oYXNQYXJlbnQoKHAsIGkpID0+IHBbJGNoYW5nZXNdID09PSBwYXJlbnRbJGNoYW5nZXNdICYmIGkgPT09IGluZGV4KSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Q2hhaW4uaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhcmVudENoYWluID0ge1xuICAgICAgICAgICAgICAgIHJlZjogcGFyZW50LFxuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIG5leHQ6IHRoaXMucGFyZW50Q2hhaW5cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhIHBhcmVudCBmcm9tIHRoZSBjaGFpblxuICAgICAgICAgKiBAcGFyYW0gcGFyZW50IC0gVGhlIHBhcmVudCB0byByZW1vdmVcbiAgICAgICAgICogQHJldHVybnMgdHJ1ZSBpZiBwYXJlbnQgd2FzIHJlbW92ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZVBhcmVudChwYXJlbnQgPSB0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLnBhcmVudENoYWluO1xuICAgICAgICAgICAgbGV0IHByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogaXQgaXMgcmVxdWlyZWQgdG8gY2hlY2sgYWdhaW5zdCBgJGNoYW5nZXNgIGhlcmUgYmVjYXVzZVxuICAgICAgICAgICAgICAgIC8vIEFycmF5U2NoZW1hIGlzIGluc3RhbmNlIG9mIFByb3h5XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5yZWZbJGNoYW5nZXNdID09PSBwYXJlbnRbJGNoYW5nZXNdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Q2hhaW4gPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Q2hhaW4gPT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmluZCBhIHNwZWNpZmljIHBhcmVudCBpbiB0aGUgY2hhaW5cbiAgICAgICAgICovXG4gICAgICAgIGZpbmRQYXJlbnQocHJlZGljYXRlKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMucGFyZW50Q2hhaW47XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoY3VycmVudC5yZWYsIGN1cnJlbnQuaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgdGhpcyBDaGFuZ2VUcmVlIGhhcyBhIHNwZWNpZmljIHBhcmVudFxuICAgICAgICAgKi9cbiAgICAgICAgaGFzUGFyZW50KHByZWRpY2F0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZFBhcmVudChwcmVkaWNhdGUpICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhbGwgcGFyZW50cyBhcyBhbiBhcnJheSAoZm9yIGRlYnVnZ2luZy90ZXN0aW5nKVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QWxsUGFyZW50cygpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5wYXJlbnRDaGFpbjtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKHsgcmVmOiBjdXJyZW50LnJlZiwgaW5kZXg6IGN1cnJlbnQuaW5kZXggfSk7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5jb2RlVmFsdWUoZW5jb2RlciwgYnl0ZXMsIHR5cGUsIHZhbHVlLCBvcGVyYXRpb24sIGl0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHR5cGUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBlbmNvZGVbdHlwZV0/LihieXRlcywgdmFsdWUsIGl0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlW1N5bWJvbC5tZXRhZGF0YV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEVuY29kZSByZWZJZCBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICAgIC8vIFRoZSBhY3R1YWwgaW5zdGFuY2UgaXMgZ29pbmcgdG8gYmUgZW5jb2RlZCBvbiBuZXh0IGBjaGFuZ2VUcmVlYCBpdGVyYXRpb24uXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgZW5jb2RlLm51bWJlcihieXRlcywgdmFsdWVbJGNoYW5nZXNdLnJlZklkLCBpdCk7XG4gICAgICAgICAgICAvLyBUcnkgdG8gZW5jb2RlIGluaGVyaXRlZCBUWVBFX0lEIGlmIGl0J3MgYW4gQUREIG9wZXJhdGlvbi5cbiAgICAgICAgICAgIGlmICgob3BlcmF0aW9uICYgZXhwb3J0cy5PUEVSQVRJT04uQUREKSA9PT0gZXhwb3J0cy5PUEVSQVRJT04uQUREKSB7XG4gICAgICAgICAgICAgICAgZW5jb2Rlci50cnlFbmNvZGVUeXBlSWQoYnl0ZXMsIHR5cGUsIHZhbHVlLmNvbnN0cnVjdG9yLCBpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRW5jb2RlIHJlZklkIGZvciB0aGlzIGluc3RhbmNlLlxuICAgICAgICAgICAgLy8gVGhlIGFjdHVhbCBpbnN0YW5jZSBpcyBnb2luZyB0byBiZSBlbmNvZGVkIG9uIG5leHQgYGNoYW5nZVRyZWVgIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBlbmNvZGUubnVtYmVyKGJ5dGVzLCB2YWx1ZVskY2hhbmdlc10ucmVmSWQsIGl0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBTY2hlbWEgaW5zdGFuY2VzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3QgZW5jb2RlU2NoZW1hT3BlcmF0aW9uID0gZnVuY3Rpb24gKGVuY29kZXIsIGJ5dGVzLCBjaGFuZ2VUcmVlLCBpbmRleCwgb3BlcmF0aW9uLCBpdCwgXywgX18sIG1ldGFkYXRhKSB7XG4gICAgICAgIC8vIFwiY29tcHJlc3NcIiBmaWVsZCBpbmRleCArIG9wZXJhdGlvblxuICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSAoaW5kZXggfCBvcGVyYXRpb24pICYgMjU1O1xuICAgICAgICAvLyBEbyBub3QgZW5jb2RlIHZhbHVlIGZvciBERUxFVEUgb3BlcmF0aW9uc1xuICAgICAgICBpZiAob3BlcmF0aW9uID09PSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWYgPSBjaGFuZ2VUcmVlLnJlZjtcbiAgICAgICAgY29uc3QgZmllbGQgPSBtZXRhZGF0YVtpbmRleF07XG4gICAgICAgIC8vIFRPRE86IGlubGluZSB0aGlzIGZ1bmN0aW9uIGNhbGwgc21hbGwgcGVyZm9ybWFuY2UgZ2FpblxuICAgICAgICBlbmNvZGVWYWx1ZShlbmNvZGVyLCBieXRlcywgbWV0YWRhdGFbaW5kZXhdLnR5cGUsIHJlZltmaWVsZC5uYW1lXSwgb3BlcmF0aW9uLCBpdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBjb2xsZWN0aW9ucyAoTWFwU2NoZW1hLCBDb2xsZWN0aW9uU2NoZW1hLCBTZXRTY2hlbWEpXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdCBlbmNvZGVLZXlWYWx1ZU9wZXJhdGlvbiA9IGZ1bmN0aW9uIChlbmNvZGVyLCBieXRlcywgY2hhbmdlVHJlZSwgaW5kZXgsIG9wZXJhdGlvbiwgaXQpIHtcbiAgICAgICAgLy8gZW5jb2RlIG9wZXJhdGlvblxuICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSBvcGVyYXRpb24gJiAyNTU7XG4gICAgICAgIC8vIGVuY29kZSBpbmRleFxuICAgICAgICBlbmNvZGUubnVtYmVyKGJ5dGVzLCBpbmRleCwgaXQpO1xuICAgICAgICAvLyBEbyBub3QgZW5jb2RlIHZhbHVlIGZvciBERUxFVEUgb3BlcmF0aW9uc1xuICAgICAgICBpZiAob3BlcmF0aW9uID09PSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWYgPSBjaGFuZ2VUcmVlLnJlZjtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gZW5jb2RlIFwiYWxpYXNcIiBmb3IgZHluYW1pYyBmaWVsZHMgKG1hcHMpXG4gICAgICAgIC8vXG4gICAgICAgIGlmICgob3BlcmF0aW9uICYgZXhwb3J0cy5PUEVSQVRJT04uQUREKSA9PT0gZXhwb3J0cy5PUEVSQVRJT04uQUREKSB7IC8vIEFERCBvciBERUxFVEVfQU5EX0FERFxuICAgICAgICAgICAgaWYgKHR5cGVvZiAocmVmWydzZXQnXSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gTWFwU2NoZW1hIGR5bmFtaWMga2V5XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBjb25zdCBkeW5hbWljSW5kZXggPSBjaGFuZ2VUcmVlLnJlZlsnJGluZGV4ZXMnXS5nZXQoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGVuY29kZS5zdHJpbmcoYnl0ZXMsIGR5bmFtaWNJbmRleCwgaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSByZWZbJGNoaWxkVHlwZV07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmVmWyRnZXRCeUluZGV4XShpbmRleCk7XG4gICAgICAgIC8vIHRyeSB7IHRocm93IG5ldyBFcnJvcigpOyB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vICAgICAvLyBvbmx5IHByaW50IGlmIG5vdCBjb21pbmcgZnJvbSBSZWZsZWN0aW9uLnRzXG4gICAgICAgIC8vICAgICBpZiAoIWUuc3RhY2suaW5jbHVkZXMoXCJzcmMvUmVmbGVjdGlvbi50c1wiKSkge1xuICAgICAgICAvLyAgICAgICAgIGNvbnNvbGUubG9nKFwiZW5jb2RlS2V5VmFsdWVPcGVyYXRpb24gLT4gXCIsIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgcmVmOiBjaGFuZ2VUcmVlLnJlZi5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICAvLyAgICAgICAgICAgICBmaWVsZCxcbiAgICAgICAgLy8gICAgICAgICAgICAgb3BlcmF0aW9uOiBPUEVSQVRJT05bb3BlcmF0aW9uXSxcbiAgICAgICAgLy8gICAgICAgICAgICAgdmFsdWU6IHZhbHVlPy50b0pTT04oKSxcbiAgICAgICAgLy8gICAgICAgICAgICAgaXRlbXM6IHJlZi50b0pTT04oKSxcbiAgICAgICAgLy8gICAgICAgICB9KTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBUT0RPOiBpbmxpbmUgdGhpcyBmdW5jdGlvbiBjYWxsIHNtYWxsIHBlcmZvcm1hbmNlIGdhaW5cbiAgICAgICAgZW5jb2RlVmFsdWUoZW5jb2RlciwgYnl0ZXMsIHR5cGUsIHZhbHVlLCBvcGVyYXRpb24sIGl0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGNvbGxlY3Rpb25zIChNYXBTY2hlbWEsIEFycmF5U2NoZW1hLCBldGMuKVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3QgZW5jb2RlQXJyYXkgPSBmdW5jdGlvbiAoZW5jb2RlciwgYnl0ZXMsIGNoYW5nZVRyZWUsIGZpZWxkLCBvcGVyYXRpb24sIGl0LCBpc0VuY29kZUFsbCwgaGFzVmlldykge1xuICAgICAgICBjb25zdCByZWYgPSBjaGFuZ2VUcmVlLnJlZjtcbiAgICAgICAgY29uc3QgdXNlT3BlcmF0aW9uQnlSZWZJZCA9IGhhc1ZpZXcgJiYgY2hhbmdlVHJlZS5pc0ZpbHRlcmVkICYmICh0eXBlb2YgKGNoYW5nZVRyZWUuZ2V0VHlwZShmaWVsZCkpICE9PSBcInN0cmluZ1wiKTtcbiAgICAgICAgbGV0IHJlZk9ySW5kZXg7XG4gICAgICAgIGlmICh1c2VPcGVyYXRpb25CeVJlZklkKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gcmVmWyd0bXBJdGVtcyddW2ZpZWxkXTtcbiAgICAgICAgICAgIC8vIFNraXAgZW5jb2RpbmcgaWYgaXRlbSBpcyB1bmRlZmluZWQgKGUuZy4gd2hlbiBjbGVhcigpIGlzIGNhbGxlZClcbiAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZk9ySW5kZXggPSBpdGVtWyRjaGFuZ2VzXS5yZWZJZDtcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24gPT09IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURSkge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURV9CWV9SRUZJRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gZXhwb3J0cy5PUEVSQVRJT04uQUREKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gZXhwb3J0cy5PUEVSQVRJT04uQUREX0JZX1JFRklEO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVmT3JJbmRleCA9IGZpZWxkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuY29kZSBvcGVyYXRpb25cbiAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gb3BlcmF0aW9uICYgMjU1O1xuICAgICAgICAvLyBlbmNvZGUgaW5kZXhcbiAgICAgICAgZW5jb2RlLm51bWJlcihieXRlcywgcmVmT3JJbmRleCwgaXQpO1xuICAgICAgICAvLyBEbyBub3QgZW5jb2RlIHZhbHVlIGZvciBERUxFVEUgb3BlcmF0aW9uc1xuICAgICAgICBpZiAob3BlcmF0aW9uID09PSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUgfHwgb3BlcmF0aW9uID09PSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEVfQllfUkVGSUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gY2hhbmdlVHJlZS5nZXRUeXBlKGZpZWxkKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjaGFuZ2VUcmVlLmdldFZhbHVlKGZpZWxkLCBpc0VuY29kZUFsbCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHsgdHlwZSwgZmllbGQsIHZhbHVlIH0pO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImVuY29kZUFycmF5IC0+IFwiLCB7XG4gICAgICAgIC8vICAgICByZWY6IGNoYW5nZVRyZWUucmVmLmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAgIC8vICAgICBmaWVsZCxcbiAgICAgICAgLy8gICAgIG9wZXJhdGlvbjogT1BFUkFUSU9OW29wZXJhdGlvbl0sXG4gICAgICAgIC8vICAgICB2YWx1ZTogdmFsdWU/LnRvSlNPTigpLFxuICAgICAgICAvLyAgICAgaXRlbXM6IHJlZi50b0pTT04oKSxcbiAgICAgICAgLy8gfSk7XG4gICAgICAgIC8vIFRPRE86IGlubGluZSB0aGlzIGZ1bmN0aW9uIGNhbGwgc21hbGwgcGVyZm9ybWFuY2UgZ2FpblxuICAgICAgICBlbmNvZGVWYWx1ZShlbmNvZGVyLCBieXRlcywgdHlwZSwgdmFsdWUsIG9wZXJhdGlvbiwgaXQpO1xuICAgIH07XG5cbiAgICBjb25zdCBERUZJTklUSU9OX01JU01BVENIID0gLTE7XG4gICAgZnVuY3Rpb24gZGVjb2RlVmFsdWUoZGVjb2Rlciwgb3BlcmF0aW9uLCByZWYsIGluZGV4LCB0eXBlLCBieXRlcywgaXQsIGFsbENoYW5nZXMpIHtcbiAgICAgICAgY29uc3QgJHJvb3QgPSBkZWNvZGVyLnJvb3Q7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSByZWZbJGdldEJ5SW5kZXhdKGluZGV4KTtcbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBpZiAoKG9wZXJhdGlvbiAmIGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURSkgPT09IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURSkge1xuICAgICAgICAgICAgLy8gRmxhZyBgcmVmSWRgIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1JlZklkID0gJHJvb3QucmVmSWRzLmdldChwcmV2aW91c1ZhbHVlKTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c1JlZklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAkcm9vdC5yZW1vdmVSZWYocHJldmlvdXNSZWZJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRGVsZXRlIG9wZXJhdGlvbnNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uICE9PSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEVfQU5EX0FERCkge1xuICAgICAgICAgICAgICAgIHJlZlskZGVsZXRlQnlJbmRleF0oaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKSA7XG4gICAgICAgIGVsc2UgaWYgKFNjaGVtYS5pcyh0eXBlKSkge1xuICAgICAgICAgICAgY29uc3QgcmVmSWQgPSBkZWNvZGUubnVtYmVyKGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICB2YWx1ZSA9ICRyb290LnJlZnMuZ2V0KHJlZklkKTtcbiAgICAgICAgICAgIGlmICgob3BlcmF0aW9uICYgZXhwb3J0cy5PUEVSQVRJT04uQUREKSA9PT0gZXhwb3J0cy5PUEVSQVRJT04uQUREKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRUeXBlID0gZGVjb2Rlci5nZXRJbnN0YW5jZVR5cGUoYnl0ZXMsIGl0LCB0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZGVjb2Rlci5jcmVhdGVJbnN0YW5jZU9mVHlwZShjaGlsZFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkcm9vdC5hZGRSZWYocmVmSWQsIHZhbHVlLCAodmFsdWUgIT09IHByZXZpb3VzVmFsdWUgfHwgLy8gaW5jcmVtZW50IHJlZiBjb3VudCBpZiB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICAob3BlcmF0aW9uID09PSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEVfQU5EX0FERCAmJiB2YWx1ZSA9PT0gcHJldmlvdXNWYWx1ZSkgLy8gaW5jcmVtZW50IHJlZiBjb3VudCBpZiB0aGUgc2FtZSBpbnN0YW5jZSBpcyBiZWluZyBhZGRlZCBhZ2FpblxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAodHlwZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBwcmltaXRpdmUgdmFsdWUgKG51bWJlciwgc3RyaW5nLCBib29sZWFuLCBldGMpXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdmFsdWUgPSBkZWNvZGVbdHlwZV0oYnl0ZXMsIGl0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVEZWYgPSBnZXRUeXBlKE9iamVjdC5rZXlzKHR5cGUpWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZklkID0gZGVjb2RlLm51bWJlcihieXRlcywgaXQpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVSZWYgPSAoJHJvb3QucmVmcy5oYXMocmVmSWQpKVxuICAgICAgICAgICAgICAgID8gcHJldmlvdXNWYWx1ZSB8fCAkcm9vdC5yZWZzLmdldChyZWZJZClcbiAgICAgICAgICAgICAgICA6IG5ldyB0eXBlRGVmLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlUmVmLmNsb25lKHRydWUpO1xuICAgICAgICAgICAgdmFsdWVbJGNoaWxkVHlwZV0gPSBPYmplY3QudmFsdWVzKHR5cGUpWzBdOyAvLyBjYWNoZSBjaGlsZFR5cGUgZm9yIEFycmF5U2NoZW1hIGFuZCBNYXBTY2hlbWFcbiAgICAgICAgICAgIGlmIChwcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZXZpb3VzUmVmSWQgPSAkcm9vdC5yZWZJZHMuZ2V0KHByZXZpb3VzVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1JlZklkICE9PSB1bmRlZmluZWQgJiYgcmVmSWQgIT09IHByZXZpb3VzUmVmSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gZW5xdWV1ZSBvblJlbW92ZSBpZiBzdHJ1Y3R1cmUgaGFzIGJlZW4gcmVwbGFjZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSBwcmV2aW91c1ZhbHVlLmVudHJpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZXI7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgoaXRlciA9IGVudHJpZXMubmV4dCgpKSAmJiAhaXRlci5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBpdGVyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdmFsdWUgaXMgYSBzY2hlbWEsIHJlbW92ZSBpdHMgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1JlZklkID0gJHJvb3QucmVmSWRzLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3QucmVtb3ZlUmVmKHByZXZpb3VzUmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsQ2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY6IHByZXZpb3VzVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmSWQ6IHByZXZpb3VzUmVmSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3A6IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDoga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRyb290LmFkZFJlZihyZWZJZCwgdmFsdWUsICh2YWx1ZVJlZiAhPT0gcHJldmlvdXNWYWx1ZSB8fFxuICAgICAgICAgICAgICAgIChvcGVyYXRpb24gPT09IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURV9BTkRfQUREICYmIHZhbHVlUmVmID09PSBwcmV2aW91c1ZhbHVlKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbHVlLCBwcmV2aW91c1ZhbHVlIH07XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZVNjaGVtYU9wZXJhdGlvbiA9IGZ1bmN0aW9uIChkZWNvZGVyLCBieXRlcywgaXQsIHJlZiwgYWxsQ2hhbmdlcykge1xuICAgICAgICBjb25zdCBmaXJzdF9ieXRlID0gYnl0ZXNbaXQub2Zmc2V0KytdO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHJlZi5jb25zdHJ1Y3RvcltTeW1ib2wubWV0YWRhdGFdO1xuICAgICAgICAvLyBcImNvbXByZXNzZWRcIiBpbmRleCArIG9wZXJhdGlvblxuICAgICAgICBjb25zdCBvcGVyYXRpb24gPSAoZmlyc3RfYnl0ZSA+PiA2KSA8PCA2O1xuICAgICAgICBjb25zdCBpbmRleCA9IGZpcnN0X2J5dGUgJSAob3BlcmF0aW9uIHx8IDI1NSk7XG4gICAgICAgIC8vIHNraXAgZWFybHkgaWYgZmllbGQgaXMgbm90IGRlZmluZWRcbiAgICAgICAgY29uc3QgZmllbGQgPSBtZXRhZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChmaWVsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJAY29seXNldXMvc2NoZW1hOiBmaWVsZCBub3QgZGVmaW5lZCBhdFwiLCB7IGluZGV4LCByZWY6IHJlZi5jb25zdHJ1Y3Rvci5uYW1lLCBtZXRhZGF0YSB9KTtcbiAgICAgICAgICAgIHJldHVybiBERUZJTklUSU9OX01JU01BVENIO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIHByZXZpb3VzVmFsdWUgfSA9IGRlY29kZVZhbHVlKGRlY29kZXIsIG9wZXJhdGlvbiwgcmVmLCBpbmRleCwgZmllbGQudHlwZSwgYnl0ZXMsIGl0LCBhbGxDaGFuZ2VzKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlZltmaWVsZC5uYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBjaGFuZ2VcbiAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBhbGxDaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgICAgICByZWZJZDogZGVjb2Rlci5jdXJyZW50UmVmSWQsXG4gICAgICAgICAgICAgICAgb3A6IG9wZXJhdGlvbixcbiAgICAgICAgICAgICAgICBmaWVsZDogZmllbGQubmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGRlY29kZUtleVZhbHVlT3BlcmF0aW9uID0gZnVuY3Rpb24gKGRlY29kZXIsIGJ5dGVzLCBpdCwgcmVmLCBhbGxDaGFuZ2VzKSB7XG4gICAgICAgIC8vIFwidW5jb21wcmVzc2VkXCIgaW5kZXggKyBvcGVyYXRpb24gKGFycmF5L21hcCBpdGVtcylcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gYnl0ZXNbaXQub2Zmc2V0KytdO1xuICAgICAgICBpZiAob3BlcmF0aW9uID09PSBleHBvcnRzLk9QRVJBVElPTi5DTEVBUikge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFdoZW4gZGVjb2Rpbmc6XG4gICAgICAgICAgICAvLyAtIGVucXVldWUgaXRlbXMgZm9yIERFTEVURSBjYWxsYmFjay5cbiAgICAgICAgICAgIC8vIC0gZmxhZyBjaGlsZCBpdGVtcyBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGRlY29kZXIucmVtb3ZlQ2hpbGRSZWZzKHJlZiwgYWxsQ2hhbmdlcyk7XG4gICAgICAgICAgICByZWYuY2xlYXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IGRlY29kZS5udW1iZXIoYnl0ZXMsIGl0KTtcbiAgICAgICAgY29uc3QgdHlwZSA9IHJlZlskY2hpbGRUeXBlXTtcbiAgICAgICAgbGV0IGR5bmFtaWNJbmRleDtcbiAgICAgICAgaWYgKChvcGVyYXRpb24gJiBleHBvcnRzLk9QRVJBVElPTi5BREQpID09PSBleHBvcnRzLk9QRVJBVElPTi5BREQpIHsgLy8gQUREIG9yIERFTEVURV9BTkRfQUREXG4gICAgICAgICAgICBpZiAodHlwZW9mIChyZWZbJ3NldCddKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgZHluYW1pY0luZGV4ID0gZGVjb2RlLnN0cmluZyhieXRlcywgaXQpOyAvLyBNYXBTY2hlbWFcbiAgICAgICAgICAgICAgICByZWZbJ3NldEluZGV4J10oaW5kZXgsIGR5bmFtaWNJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljSW5kZXggPSBpbmRleDsgLy8gQXJyYXlTY2hlbWFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGdldCBkeW5hbWljIGluZGV4IGZyb20gXCJyZWZcIlxuICAgICAgICAgICAgZHluYW1pY0luZGV4ID0gcmVmWydnZXRJbmRleCddKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHZhbHVlLCBwcmV2aW91c1ZhbHVlIH0gPSBkZWNvZGVWYWx1ZShkZWNvZGVyLCBvcGVyYXRpb24sIHJlZiwgaW5kZXgsIHR5cGUsIGJ5dGVzLCBpdCwgYWxsQ2hhbmdlcyk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChyZWZbJ3NldCddKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgLy8gTWFwU2NoZW1hXG4gICAgICAgICAgICAgICAgcmVmWyckaXRlbXMnXS5zZXQoZHluYW1pY0luZGV4LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgKHJlZlsnJHNldEF0J10pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBBcnJheVNjaGVtYVxuICAgICAgICAgICAgICAgIHJlZlsnJHNldEF0J10oaW5kZXgsIHZhbHVlLCBvcGVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIChyZWZbJ2FkZCddKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29sbGVjdGlvblNjaGVtYSAmJiBTZXRTY2hlbWFcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHJlZi5hZGQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGluZGV4KSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICByZWZbJ3NldEluZGV4J10oaW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGNoYW5nZVxuICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGFsbENoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgICAgIHJlZklkOiBkZWNvZGVyLmN1cnJlbnRSZWZJZCxcbiAgICAgICAgICAgICAgICBvcDogb3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgIGZpZWxkOiBcIlwiLCAvLyBGSVhNRTogcmVtb3ZlIHRoaXNcbiAgICAgICAgICAgICAgICBkeW5hbWljSW5kZXgsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBkZWNvZGVBcnJheSA9IGZ1bmN0aW9uIChkZWNvZGVyLCBieXRlcywgaXQsIHJlZiwgYWxsQ2hhbmdlcykge1xuICAgICAgICAvLyBcInVuY29tcHJlc3NlZFwiIGluZGV4ICsgb3BlcmF0aW9uIChhcnJheS9tYXAgaXRlbXMpXG4gICAgICAgIGxldCBvcGVyYXRpb24gPSBieXRlc1tpdC5vZmZzZXQrK107XG4gICAgICAgIGxldCBpbmRleDtcbiAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gZXhwb3J0cy5PUEVSQVRJT04uQ0xFQVIpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBXaGVuIGRlY29kaW5nOlxuICAgICAgICAgICAgLy8gLSBlbnF1ZXVlIGl0ZW1zIGZvciBERUxFVEUgY2FsbGJhY2suXG4gICAgICAgICAgICAvLyAtIGZsYWcgY2hpbGQgaXRlbXMgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBkZWNvZGVyLnJlbW92ZUNoaWxkUmVmcyhyZWYsIGFsbENoYW5nZXMpO1xuICAgICAgICAgICAgcmVmLmNsZWFyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uID09PSBleHBvcnRzLk9QRVJBVElPTi5SRVZFUlNFKSB7XG4gICAgICAgICAgICByZWYucmV2ZXJzZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFX0JZX1JFRklEKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZWZhY3RvciBoZXJlLCB0cnkgdG8gZm9sbG93IHNhbWUgZmxvdyBhcyBiZWxvd1xuICAgICAgICAgICAgY29uc3QgcmVmSWQgPSBkZWNvZGUubnVtYmVyKGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gZGVjb2Rlci5yb290LnJlZnMuZ2V0KHJlZklkKTtcbiAgICAgICAgICAgIGluZGV4ID0gcmVmLmZpbmRJbmRleCgodmFsdWUpID0+IHZhbHVlID09PSBwcmV2aW91c1ZhbHVlKTtcbiAgICAgICAgICAgIHJlZlskZGVsZXRlQnlJbmRleF0oaW5kZXgpO1xuICAgICAgICAgICAgYWxsQ2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICByZWYsXG4gICAgICAgICAgICAgICAgcmVmSWQ6IGRlY29kZXIuY3VycmVudFJlZklkLFxuICAgICAgICAgICAgICAgIG9wOiBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUsXG4gICAgICAgICAgICAgICAgZmllbGQ6IFwiXCIsIC8vIEZJWE1FOiByZW1vdmUgdGhpc1xuICAgICAgICAgICAgICAgIGR5bmFtaWNJbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uID09PSBleHBvcnRzLk9QRVJBVElPTi5BRERfQllfUkVGSUQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZklkID0gZGVjb2RlLm51bWJlcihieXRlcywgaXQpO1xuICAgICAgICAgICAgY29uc3QgaXRlbUJ5UmVmSWQgPSBkZWNvZGVyLnJvb3QucmVmcy5nZXQocmVmSWQpO1xuICAgICAgICAgICAgLy8gaWYgaXRlbSBhbHJlYWR5IGV4aXN0cywgdXNlIGV4aXN0aW5nIGluZGV4XG4gICAgICAgICAgICBpZiAoaXRlbUJ5UmVmSWQpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHJlZi5maW5kSW5kZXgoKHZhbHVlKSA9PiB2YWx1ZSA9PT0gaXRlbUJ5UmVmSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gdXNlIGxhc3QgaW5kZXhcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEgfHwgaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gcmVmLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ID0gZGVjb2RlLm51bWJlcihieXRlcywgaXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSByZWZbJGNoaWxkVHlwZV07XG4gICAgICAgIGxldCBkeW5hbWljSW5kZXggPSBpbmRleDtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgcHJldmlvdXNWYWx1ZSB9ID0gZGVjb2RlVmFsdWUoZGVjb2Rlciwgb3BlcmF0aW9uLCByZWYsIGluZGV4LCB0eXBlLCBieXRlcywgaXQsIGFsbENoYW5nZXMpO1xuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdmFsdWUgIT09IHByZXZpb3VzVmFsdWUgLy8gYXZvaWQgc2V0dGluZyBzYW1lIHZhbHVlIHR3aWNlIChpZiBpbmRleCA9PT0gMCBpdCB3aWxsIHJlc3VsdCBpbiBhIFwidW5zaGlmdFwiIGZvciBBcnJheVNjaGVtYSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBBcnJheVNjaGVtYVxuICAgICAgICAgICAgcmVmWyckc2V0QXQnXShpbmRleCwgdmFsdWUsIG9wZXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGNoYW5nZVxuICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGFsbENoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgICAgIHJlZklkOiBkZWNvZGVyLmN1cnJlbnRSZWZJZCxcbiAgICAgICAgICAgICAgICBvcDogb3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgIGZpZWxkOiBcIlwiLCAvLyBGSVhNRTogcmVtb3ZlIHRoaXNcbiAgICAgICAgICAgICAgICBkeW5hbWljSW5kZXgsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNsYXNzIEVuY29kZVNjaGVtYUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlLCBrbGFzcywgZmllbGQpIHtcbiAgICAgICAgbGV0IHR5cGVvZlRhcmdldDtcbiAgICAgICAgbGV0IGFsbG93TnVsbCA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJpbnQ4XCI6XG4gICAgICAgICAgICBjYXNlIFwidWludDhcIjpcbiAgICAgICAgICAgIGNhc2UgXCJpbnQxNlwiOlxuICAgICAgICAgICAgY2FzZSBcInVpbnQxNlwiOlxuICAgICAgICAgICAgY2FzZSBcImludDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwiaW50NjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50NjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmbG9hdDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwiZmxvYXQ2NFwiOlxuICAgICAgICAgICAgICAgIHR5cGVvZlRhcmdldCA9IFwibnVtYmVyXCI7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgdHJ5aW5nIHRvIGVuY29kZSBcIk5hTlwiIGluICR7a2xhc3MuY29uc3RydWN0b3IubmFtZX0jJHtmaWVsZH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYmlnaW50NjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJiaWd1aW50NjRcIjpcbiAgICAgICAgICAgICAgICB0eXBlb2ZUYXJnZXQgPSBcImJpZ2ludFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHR5cGVvZlRhcmdldCA9IFwic3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgYWxsb3dOdWxsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgLy8gYm9vbGVhbiBpcyBhbHdheXMgZW5jb2RlZCBhcyB0cnVlL2ZhbHNlIGJhc2VkIG9uIHRydXRoaW5lc3NcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIHNraXAgYXNzZXJ0aW9uIGZvciBjdXN0b20gdHlwZXNcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhbGxvdyBjdXN0b20gdHlwZXMgdG8gZGVmaW5lIHRoZWlyIG93biBhc3NlcnRpb25zXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gdHlwZW9mVGFyZ2V0ICYmICghYWxsb3dOdWxsIHx8IChhbGxvd051bGwgJiYgdmFsdWUgIT09IG51bGwpKSkge1xuICAgICAgICAgICAgbGV0IGZvdW5kVmFsdWUgPSBgJyR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSckeyh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiBgICgke3ZhbHVlLmNvbnN0cnVjdG9yLm5hbWV9KWApIHx8ICcnfWA7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRW5jb2RlU2NoZW1hRXJyb3IoYGEgJyR7dHlwZW9mVGFyZ2V0fScgd2FzIGV4cGVjdGVkLCBidXQgJHtmb3VuZFZhbHVlfSB3YXMgcHJvdmlkZWQgaW4gJHtrbGFzcy5jb25zdHJ1Y3Rvci5uYW1lfSMke2ZpZWxkfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydEluc3RhbmNlVHlwZSh2YWx1ZSwgdHlwZSwgaW5zdGFuY2UsIGZpZWxkKSB7XG4gICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgdHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFbmNvZGVTY2hlbWFFcnJvcihgYSAnJHt0eXBlLm5hbWV9JyB3YXMgZXhwZWN0ZWQsIGJ1dCAnJHt2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lfScgd2FzIHByb3ZpZGVkIGluICR7aW5zdGFuY2UuY29uc3RydWN0b3IubmFtZX0jJHtmaWVsZH1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfYSQ0LCBfYiQ0O1xuICAgIGNvbnN0IERFRkFVTFRfU09SVCA9IChhLCBiKSA9PiB7XG4gICAgICAgIGNvbnN0IEEgPSBhLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IEIgPSBiLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChBIDwgQilcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgZWxzZSBpZiAoQSA+IEIpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBjbGFzcyBBcnJheVNjaGVtYSB7XG4gICAgICAgIHN0YXRpYyB7IHRoaXNbX2EkNF0gPSBlbmNvZGVBcnJheTsgfVxuICAgICAgICBzdGF0aWMgeyB0aGlzW19iJDRdID0gZGVjb2RlQXJyYXk7IH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZSBpZiBhIHByb3BlcnR5IG11c3QgYmUgZmlsdGVyZWQuXG4gICAgICAgICAqIC0gSWYgcmV0dXJucyBmYWxzZSwgdGhlIHByb3BlcnR5IGlzIE5PVCBnb2luZyB0byBiZSBlbmNvZGVkLlxuICAgICAgICAgKiAtIElmIHJldHVybnMgdHJ1ZSwgdGhlIHByb3BlcnR5IGlzIGdvaW5nIHRvIGJlIGVuY29kZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEVuY29kaW5nIHdpdGggXCJmaWx0ZXJzXCIgaGFwcGVucyBpbiB0d28gc3RlcHM6XG4gICAgICAgICAqIC0gRmlyc3QsIHRoZSBlbmNvZGVyIGl0ZXJhdGVzIG92ZXIgYWxsIFwibm90IG93bmVkXCIgcHJvcGVydGllcyBhbmQgZW5jb2RlcyB0aGVtLlxuICAgICAgICAgKiAtIFRoZW4sIHRoZSBlbmNvZGVyIGl0ZXJhdGVzIG92ZXIgYWxsIFwib3duZWRcIiBwcm9wZXJ0aWVzIHBlciBpbnN0YW5jZSBhbmQgZW5jb2RlcyB0aGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIFsoX2EkNCA9ICRlbmNvZGVyLCBfYiQ0ID0gJGRlY29kZXIsICRmaWx0ZXIpXShyZWYsIGluZGV4LCB2aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gKCF2aWV3IHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIChyZWZbJGNoaWxkVHlwZV0pID09PSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICAgICAgdmlldy5pc0NoYW5nZVRyZWVWaXNpYmxlKHJlZlsndG1wSXRlbXMnXVtpbmRleF0/LlskY2hhbmdlc10pKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgaXModHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIC8vIHR5cGUgZm9ybWF0OiBbXCJzdHJpbmdcIl1cbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodHlwZSkgfHxcbiAgICAgICAgICAgICAgICAvLyB0eXBlIGZvcm1hdDogeyBhcnJheTogXCJzdHJpbmdcIiB9XG4gICAgICAgICAgICAgICAgKHR5cGVbJ2FycmF5J10gIT09IHVuZGVmaW5lZCkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tKGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5U2NoZW1hKC4uLkFycmF5LmZyb20oaXRlcmFibGUpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdHJ1Y3RvciguLi5pdGVtcykge1xuICAgICAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy50bXBJdGVtcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5kZWxldGVkSW5kZXhlcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5pc01vdmluZ0l0ZW1zID0gZmFsc2U7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJGNoaWxkVHlwZSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh0aGlzLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiAob2JqLCBwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApICE9PSBcInN5bWJvbFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogZDggYWNjdXNlcyB0aGlzIGFzIGxvdyBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgIWlzTmFOKHByb3ApIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzU3ODcvODkyNjk4XG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQob2JqLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiAob2JqLCBrZXksIHNldFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGtleSkgIT09IFwic3ltYm9sXCIgJiYgIWlzTmFOKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXRWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHNldFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLiRkZWxldGVBdChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldFZhbHVlWyRjaGFuZ2VzXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRJbnN0YW5jZVR5cGUoc2V0VmFsdWUsIG9ialskY2hpbGRUeXBlXSwgb2JqLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gb2JqLml0ZW1zW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2JqLmlzTW92aW5nSXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai4kY2hhbmdlQXQoTnVtYmVyKGtleSksIHNldFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0VmFsdWVbJGNoYW5nZXNdLmlzTmV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialskY2hhbmdlc10uaW5kZXhlZE9wZXJhdGlvbihOdW1iZXIoa2V5KSwgZXhwb3J0cy5PUEVSQVRJT04uTU9WRV9BTkRfQUREKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgob2JqWyRjaGFuZ2VzXS5nZXRDaGFuZ2UoTnVtYmVyKGtleSkpICYgZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKSA9PT0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpbJGNoYW5nZXNdLmluZGV4ZWRPcGVyYXRpb24oTnVtYmVyKGtleSksIGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURV9BTkRfTU9WRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpbJGNoYW5nZXNdLmluZGV4ZWRPcGVyYXRpb24oTnVtYmVyKGtleSksIGV4cG9ydHMuT1BFUkFUSU9OLk1PVkUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2V0VmFsdWVbJGNoYW5nZXNdLmlzTmV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqWyRjaGFuZ2VzXS5pbmRleGVkT3BlcmF0aW9uKE51bWJlcihrZXkpLCBleHBvcnRzLk9QRVJBVElPTi5BREQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWVbJGNoYW5nZXNdLnNldFBhcmVudCh0aGlzLCBvYmpbJGNoYW5nZXNdLnJvb3QsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHJvb3QgcmVmZXJlbmNlIGZyb20gcHJldmlvdXMgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWVbJGNoYW5nZXNdLnJvb3Q/LnJlbW92ZShwcmV2aW91c1ZhbHVlWyRjaGFuZ2VzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai4kY2hhbmdlQXQoTnVtYmVyKGtleSksIHNldFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLml0ZW1zW2tleV0gPSBzZXRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmoudG1wSXRlbXNba2V5XSA9IHNldFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQob2JqLCBrZXksIHNldFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHk6IChvYmosIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai4kZGVsZXRlQXQocHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGFzOiAob2JqLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoa2V5KSAhPT0gXCJzeW1ib2xcIiAmJiAhaXNOYU4oTnVtYmVyKGtleSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGhpcy5pdGVtcywga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXMob2JqLCBrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICRjaGFuZ2VzLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBDaGFuZ2VUcmVlKHByb3h5KSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2goLi4uaXRlbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb3h5O1xuICAgICAgICB9XG4gICAgICAgIHNldCBsZW5ndGgobmV3TGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobmV3TGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmV3TGVuZ3RoIDwgdGhpcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwbGljZShuZXdMZW5ndGgsIHRoaXMubGVuZ3RoIC0gbmV3TGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkFycmF5U2NoZW1hOiBjYW4ndCBzZXQgLmxlbmd0aCB0byBhIGhpZ2hlciB2YWx1ZSB0aGFuIGl0cyBsZW5ndGguXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaCguLi52YWx1ZXMpIHtcbiAgICAgICAgICAgIGxldCBsZW5ndGggPSB0aGlzLnRtcEl0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZVRyZWUgPSB0aGlzWyRjaGFuZ2VzXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdmFsdWVzLmxlbmd0aDsgaSA8IGw7IGkrKywgbGVuZ3RoKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIG51bGwgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIgJiYgdGhpc1skY2hpbGRUeXBlXSkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnRJbnN0YW5jZVR5cGUodmFsdWUsIHRoaXNbJGNoaWxkVHlwZV0sIHRoaXMsIGkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBtb3ZlIHZhbHVlWyRjaGFuZ2VzXT8uc2V0UGFyZW50KCkgdG8gdGhpcyBibG9jay5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhbmdlVHJlZS5pbmRleGVkT3BlcmF0aW9uKGxlbmd0aCwgZXhwb3J0cy5PUEVSQVRJT04uQURELCB0aGlzLml0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRtcEl0ZW1zLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gc2V0IHZhbHVlJ3MgcGFyZW50IGFmdGVyIHRoZSB2YWx1ZSBpcyBzZXRcbiAgICAgICAgICAgICAgICAvLyAodG8gYXZvaWQgZW5jb2RpbmcgXCJyZWZJZFwiIG9wZXJhdGlvbnMgYmVmb3JlIHBhcmVudCdzIFwiQUREXCIgb3BlcmF0aW9uKVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgdmFsdWVbJGNoYW5nZXNdPy5zZXRQYXJlbnQodGhpcywgY2hhbmdlVHJlZS5yb290LCBsZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyB0aGUgbGFzdCBlbGVtZW50IGZyb20gYW4gYXJyYXkgYW5kIHJldHVybnMgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBwb3AoKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIC8vIGZpbmQgbGFzdCBub24tdW5kZWZpbmVkIGluZGV4XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy50bXBJdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIC8vIGlmICh0aGlzLnRtcEl0ZW1zW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWxldGVkSW5kZXhlc1tpXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1skY2hhbmdlc10uZGVsZXRlKGluZGV4LCB1bmRlZmluZWQsIHRoaXMuaXRlbXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZWRJbmRleGVzW2luZGV4XSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBhdChpbmRleCkge1xuICAgICAgICAgICAgLy8gQWxsb3cgbmVnYXRpdmUgaW5kZXhpbmcgZnJvbSB0aGUgZW5kXG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwKVxuICAgICAgICAgICAgICAgIGluZGV4ICs9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuY29kaW5nIG9ubHlcbiAgICAgICAgJGNoYW5nZUF0KGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQXJyYXlTY2hlbWEgaXRlbXMgY2Fubm90IGJlIG51bGwgbm9yIHVuZGVmaW5lZDsgVXNlIGBkZWxldGVBdChpbmRleClgIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNraXAgaWYgdGhlIHZhbHVlIGlzIHRoZSBzYW1lIGFzIGNhY2hlZC5cbiAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zW2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRpb24gPSAodGhpcy5pdGVtc1tpbmRleF0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICA/IHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAgICAgICAgID8gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFX0FORF9BREQgLy8gc2NoZW1hIGNoaWxkXG4gICAgICAgICAgICAgICAgICAgIDogZXhwb3J0cy5PUEVSQVRJT04uUkVQTEFDRSAvLyBwcmltaXRpdmVcbiAgICAgICAgICAgICAgICA6IGV4cG9ydHMuT1BFUkFUSU9OLkFERDtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZVRyZWUgPSB0aGlzWyRjaGFuZ2VzXTtcbiAgICAgICAgICAgIGNoYW5nZVRyZWUuY2hhbmdlKGluZGV4LCBvcGVyYXRpb24pO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHNldCB2YWx1ZSdzIHBhcmVudCBhZnRlciB0aGUgdmFsdWUgaXMgc2V0XG4gICAgICAgICAgICAvLyAodG8gYXZvaWQgZW5jb2RpbmcgXCJyZWZJZFwiIG9wZXJhdGlvbnMgYmVmb3JlIHBhcmVudCdzIFwiQUREXCIgb3BlcmF0aW9uKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHZhbHVlWyRjaGFuZ2VzXT8uc2V0UGFyZW50KHRoaXMsIGNoYW5nZVRyZWUucm9vdCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuY29kaW5nIG9ubHlcbiAgICAgICAgJGRlbGV0ZUF0KGluZGV4LCBvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXNbJGNoYW5nZXNdLmRlbGV0ZShpbmRleCwgb3BlcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWNvZGluZyBvbmx5XG4gICAgICAgICRzZXRBdChpbmRleCwgdmFsdWUsIG9wZXJhdGlvbikge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwICYmXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uID09PSBleHBvcnRzLk9QRVJBVElPTi5BREQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zW2luZGV4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGRlY29kaW5nIHVuc2hpZnRcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnVuc2hpZnQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uID09PSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEVfQU5EX01PVkUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXIoKSB7XG4gICAgICAgICAgICAvLyBza2lwIGlmIGFscmVhZHkgY2xlYXJcbiAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRpc2NhcmQgcHJldmlvdXMgb3BlcmF0aW9ucy5cbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZVRyZWUgPSB0aGlzWyRjaGFuZ2VzXTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBjaGlsZHJlbiByZWZlcmVuY2VzXG4gICAgICAgICAgICBjaGFuZ2VUcmVlLmZvckVhY2hDaGlsZCgoY2hpbGRDaGFuZ2VUcmVlLCBfKSA9PiB7XG4gICAgICAgICAgICAgICAgY2hhbmdlVHJlZS5yb290Py5yZW1vdmUoY2hpbGRDaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2hhbmdlVHJlZS5kaXNjYXJkKHRydWUpO1xuICAgICAgICAgICAgY2hhbmdlVHJlZS5vcGVyYXRpb24oZXhwb3J0cy5PUEVSQVRJT04uQ0xFQVIpO1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy50bXBJdGVtcy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21iaW5lcyB0d28gb3IgbW9yZSBhcnJheXMuXG4gICAgICAgICAqIEBwYXJhbSBpdGVtcyBBZGRpdGlvbmFsIGl0ZW1zIHRvIGFkZCB0byB0aGUgZW5kIG9mIGFycmF5MS5cbiAgICAgICAgICovXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uY2F0KC4uLml0ZW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5U2NoZW1hKC4uLnRoaXMuaXRlbXMuY29uY2F0KC4uLml0ZW1zKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYWxsIHRoZSBlbGVtZW50cyBvZiBhbiBhcnJheSBzZXBhcmF0ZWQgYnkgdGhlIHNwZWNpZmllZCBzZXBhcmF0b3Igc3RyaW5nLlxuICAgICAgICAgKiBAcGFyYW0gc2VwYXJhdG9yIEEgc3RyaW5nIHVzZWQgdG8gc2VwYXJhdGUgb25lIGVsZW1lbnQgb2YgYW4gYXJyYXkgZnJvbSB0aGUgbmV4dCBpbiB0aGUgcmVzdWx0aW5nIFN0cmluZy4gSWYgb21pdHRlZCwgdGhlIGFycmF5IGVsZW1lbnRzIGFyZSBzZXBhcmF0ZWQgd2l0aCBhIGNvbW1hLlxuICAgICAgICAgKi9cbiAgICAgICAgam9pbihzZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV2ZXJzZXMgdGhlIGVsZW1lbnRzIGluIGFuIEFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXZlcnNlKCkge1xuICAgICAgICAgICAgdGhpc1skY2hhbmdlc10ub3BlcmF0aW9uKGV4cG9ydHMuT1BFUkFUSU9OLlJFVkVSU0UpO1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB0aGlzLnRtcEl0ZW1zLnJldmVyc2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIHRoZSBmaXJzdCBlbGVtZW50IGZyb20gYW4gYXJyYXkgYW5kIHJldHVybnMgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBzaGlmdCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VUcmVlID0gdGhpc1skY2hhbmdlc107XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMudG1wSXRlbXMuZmluZEluZGV4KGl0ZW0gPT4gaXRlbSA9PT0gdGhpcy5pdGVtc1swXSk7XG4gICAgICAgICAgICBjb25zdCBhbGxDaGFuZ2VzSW5kZXggPSB0aGlzLml0ZW1zLmZpbmRJbmRleChpdGVtID0+IGl0ZW0gPT09IHRoaXMuaXRlbXNbMF0pO1xuICAgICAgICAgICAgY2hhbmdlVHJlZS5kZWxldGUoaW5kZXgsIGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURSwgYWxsQ2hhbmdlc0luZGV4KTtcbiAgICAgICAgICAgIGNoYW5nZVRyZWUuc2hpZnRBbGxDaGFuZ2VJbmRleGVzKC0xLCBhbGxDaGFuZ2VzSW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5kZWxldGVkSW5kZXhlc1tpbmRleF0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHNlY3Rpb24gb2YgYW4gYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSBzdGFydCBUaGUgYmVnaW5uaW5nIG9mIHRoZSBzcGVjaWZpZWQgcG9ydGlvbiBvZiB0aGUgYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSBlbmQgVGhlIGVuZCBvZiB0aGUgc3BlY2lmaWVkIHBvcnRpb24gb2YgdGhlIGFycmF5LiBUaGlzIGlzIGV4Y2x1c2l2ZSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgaW5kZXggJ2VuZCcuXG4gICAgICAgICAqL1xuICAgICAgICBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCBzbGljZWQgPSBuZXcgQXJyYXlTY2hlbWEoKTtcbiAgICAgICAgICAgIHNsaWNlZC5wdXNoKC4uLnRoaXMuaXRlbXMuc2xpY2Uoc3RhcnQsIGVuZCkpO1xuICAgICAgICAgICAgcmV0dXJuIHNsaWNlZDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU29ydHMgYW4gYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSBjb21wYXJlRm4gRnVuY3Rpb24gdXNlZCB0byBkZXRlcm1pbmUgdGhlIG9yZGVyIG9mIHRoZSBlbGVtZW50cy4gSXQgaXMgZXhwZWN0ZWQgdG8gcmV0dXJuXG4gICAgICAgICAqIGEgbmVnYXRpdmUgdmFsdWUgaWYgZmlyc3QgYXJndW1lbnQgaXMgbGVzcyB0aGFuIHNlY29uZCBhcmd1bWVudCwgemVybyBpZiB0aGV5J3JlIGVxdWFsIGFuZCBhIHBvc2l0aXZlXG4gICAgICAgICAqIHZhbHVlIG90aGVyd2lzZS4gSWYgb21pdHRlZCwgdGhlIGVsZW1lbnRzIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nLCBBU0NJSSBjaGFyYWN0ZXIgb3JkZXIuXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIFsxMSwyLDIyLDFdLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHNvcnQoY29tcGFyZUZuID0gREVGQVVMVF9TT1JUKSB7XG4gICAgICAgICAgICB0aGlzLmlzTW92aW5nSXRlbXMgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IHRoaXNbJGNoYW5nZXNdO1xuICAgICAgICAgICAgY29uc3Qgc29ydGVkSXRlbXMgPSB0aGlzLml0ZW1zLnNvcnQoY29tcGFyZUZuKTtcbiAgICAgICAgICAgIC8vIHdvdWxkbid0IE9QRVJBVElPTi5NT1ZFIG1ha2UgbW9yZSBzZW5zZSBoZXJlP1xuICAgICAgICAgICAgc29ydGVkSXRlbXMuZm9yRWFjaCgoXywgaSkgPT4gY2hhbmdlVHJlZS5jaGFuZ2UoaSwgZXhwb3J0cy5PUEVSQVRJT04uUkVQTEFDRSkpO1xuICAgICAgICAgICAgdGhpcy50bXBJdGVtcy5zb3J0KGNvbXBhcmVGbik7XG4gICAgICAgICAgICB0aGlzLmlzTW92aW5nSXRlbXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYW5kLCBpZiBuZWNlc3NhcnksIGluc2VydHMgbmV3IGVsZW1lbnRzIGluIHRoZWlyIHBsYWNlLCByZXR1cm5pbmcgdGhlIGRlbGV0ZWQgZWxlbWVudHMuXG4gICAgICAgICAqIEBwYXJhbSBzdGFydCBUaGUgemVyby1iYXNlZCBsb2NhdGlvbiBpbiB0aGUgYXJyYXkgZnJvbSB3aGljaCB0byBzdGFydCByZW1vdmluZyBlbGVtZW50cy5cbiAgICAgICAgICogQHBhcmFtIGRlbGV0ZUNvdW50IFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgICAgICAgKiBAcGFyYW0gaW5zZXJ0SXRlbXMgRWxlbWVudHMgdG8gaW5zZXJ0IGludG8gdGhlIGFycmF5IGluIHBsYWNlIG9mIHRoZSBkZWxldGVkIGVsZW1lbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCwgLi4uaW5zZXJ0SXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZVRyZWUgPSB0aGlzWyRjaGFuZ2VzXTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zTGVuZ3RoID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCB0bXBJdGVtc0xlbmd0aCA9IHRoaXMudG1wSXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaW5zZXJ0Q291bnQgPSBpbnNlcnRJdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICAvLyBidWlsZCB1cC10by1kYXRlIGxpc3Qgb2YgaW5kZXhlcywgZXhjbHVkaW5nIHJlbW92ZWQgdmFsdWVzLlxuICAgICAgICAgICAgY29uc3QgaW5kZXhlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0bXBJdGVtc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsZXRlZEluZGV4ZXNbaV0gIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtc0xlbmd0aCA+IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgZGVsZXRlQ291bnQgaXMgbm90IHByb3ZpZGVkLCBkZWxldGUgYWxsIGl0ZW1zIGZyb20gc3RhcnQgdG8gZW5kXG4gICAgICAgICAgICAgICAgaWYgKGRlbGV0ZUNvdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlQ291bnQgPSBpdGVtc0xlbmd0aCAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBvcGVyYXRpb25zIGF0IGNvcnJlY3QgaW5kZXhcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgZGVsZXRlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGluZGV4ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVRyZWUuZGVsZXRlKGluZGV4LCBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZWRJbmRleGVzW2luZGV4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGVub3VnaCBpdGVtcyB0byBkZWxldGVcbiAgICAgICAgICAgICAgICBkZWxldGVDb3VudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbnNlcnQgb3BlcmF0aW9uc1xuICAgICAgICAgICAgaWYgKGluc2VydENvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnRDb3VudCA+IGRlbGV0ZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnNlcnRpbmcgbW9yZSBlbGVtZW50cyB0aGFuIGRlbGV0aW5nIGR1cmluZyBBcnJheVNjaGVtYSNzcGxpY2UoKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlTY2hlbWEjc3BsaWNlKCk6IGluc2VydENvdW50IG11c3QgYmUgZXF1YWwgb3IgbG93ZXIgdGhhbiBkZWxldGVDb3VudC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zZXJ0Q291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRJbmRleCA9IChpbmRleGVzW3N0YXJ0XSA/PyBpdGVtc0xlbmd0aCkgKyBpO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlLmluZGV4ZWRPcGVyYXRpb24oYWRkSW5kZXgsICh0aGlzLmRlbGV0ZWRJbmRleGVzW2FkZEluZGV4XSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFX0FORF9BRERcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZXhwb3J0cy5PUEVSQVRJT04uQUREKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHZhbHVlJ3MgcGFyZW50L3Jvb3RcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0SXRlbXNbaV1bJGNoYW5nZXNdPy5zZXRQYXJlbnQodGhpcywgY2hhbmdlVHJlZS5yb290LCBhZGRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGRlbGV0ZSBleGNlZWRpbmcgaW5kZXhlcyBmcm9tIFwiYWxsQ2hhbmdlc1wiXG4gICAgICAgICAgICAvLyAocHJldmVudCAuZW5jb2RlQWxsKCkgZnJvbSBlbmNvZGluZyBub24tZXhpc3RpbmcgaXRlbXMpXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaWYgKGRlbGV0ZUNvdW50ID4gaW5zZXJ0Q291bnQpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlLnNoaWZ0QWxsQ2hhbmdlSW5kZXhlcygtKGRlbGV0ZUNvdW50IC0gaW5zZXJ0Q291bnQpLCBpbmRleGVzW3N0YXJ0ICsgaW5zZXJ0Q291bnRdKTtcbiAgICAgICAgICAgICAgICAvLyBkZWJ1Z0NoYW5nZVNldChcIkFGVEVSIFNISUZUIGluZGV4ZXNcIiwgY2hhbmdlVHJlZS5hbGxDaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBGSVhNRTogdGhpcyBjb2RlIGJsb2NrIGlzIGR1cGxpY2F0ZWQgb24gQ2hhbmdlVHJlZVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGlmIChjaGFuZ2VUcmVlLmZpbHRlcmVkQ2hhbmdlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlVHJlZS5yb290Py5lbnF1ZXVlQ2hhbmdlVHJlZShjaGFuZ2VUcmVlLCAnZmlsdGVyZWRDaGFuZ2VzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlLnJvb3Q/LmVucXVldWVDaGFuZ2VUcmVlKGNoYW5nZVRyZWUsICdjaGFuZ2VzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5zcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50LCAuLi5pbnNlcnRJdGVtcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc2VydHMgbmV3IGVsZW1lbnRzIGF0IHRoZSBzdGFydCBvZiBhbiBhcnJheS5cbiAgICAgICAgICogQHBhcmFtIGl0ZW1zICBFbGVtZW50cyB0byBpbnNlcnQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBBcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIHVuc2hpZnQoLi4uaXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZVRyZWUgPSB0aGlzWyRjaGFuZ2VzXTtcbiAgICAgICAgICAgIC8vIHNoaWZ0IGluZGV4ZXNcbiAgICAgICAgICAgIGNoYW5nZVRyZWUuc2hpZnRDaGFuZ2VJbmRleGVzKGl0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICAvLyBuZXcgaW5kZXhcbiAgICAgICAgICAgIGlmIChjaGFuZ2VUcmVlLmlzRmlsdGVyZWQpIHtcbiAgICAgICAgICAgICAgICBzZXRPcGVyYXRpb25BdEluZGV4KGNoYW5nZVRyZWUuZmlsdGVyZWRDaGFuZ2VzLCB0aGlzLml0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlVHJlZS5maWx0ZXJlZENoYW5nZXNbdGhpcy5pdGVtcy5sZW5ndGhdID0gT1BFUkFUSU9OLkFERDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldE9wZXJhdGlvbkF0SW5kZXgoY2hhbmdlVHJlZS5hbGxDaGFuZ2VzLCB0aGlzLml0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlVHJlZS5hbGxDaGFuZ2VzW3RoaXMuaXRlbXMubGVuZ3RoXSA9IE9QRVJBVElPTi5BREQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGSVhNRTogc2hvdWxkIHdlIHVzZSBPUEVSQVRJT04uTU9WRSBoZXJlIGluc3RlYWQ/XG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKChfLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNoYW5nZVRyZWUuY2hhbmdlKGluZGV4LCBleHBvcnRzLk9QRVJBVElPTi5BREQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRtcEl0ZW1zLnVuc2hpZnQoLi4uaXRlbXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMudW5zaGlmdCguLi5pdGVtcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGEgdmFsdWUgaW4gYW4gYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IFRoZSB2YWx1ZSB0byBsb2NhdGUgaW4gdGhlIGFycmF5LlxuICAgICAgICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBhcnJheSBpbmRleCBhdCB3aGljaCB0byBiZWdpbiB0aGUgc2VhcmNoLiBJZiBmcm9tSW5kZXggaXMgb21pdHRlZCwgdGhlIHNlYXJjaCBzdGFydHMgYXQgaW5kZXggMC5cbiAgICAgICAgICovXG4gICAgICAgIGluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5pbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG9jY3VycmVuY2Ugb2YgYSBzcGVjaWZpZWQgdmFsdWUgaW4gYW4gYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IFRoZSB2YWx1ZSB0byBsb2NhdGUgaW4gdGhlIGFycmF5LlxuICAgICAgICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBhcnJheSBpbmRleCBhdCB3aGljaCB0byBiZWdpbiB0aGUgc2VhcmNoLiBJZiBmcm9tSW5kZXggaXMgb21pdHRlZCwgdGhlIHNlYXJjaCBzdGFydHMgYXQgdGhlIGxhc3QgaW5kZXggaW4gdGhlIGFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4ID0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5sYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZXJ5KGNhbGxiYWNrZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmV2ZXJ5KGNhbGxiYWNrZm4sIHRoaXNBcmcpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIHRydWUgZm9yIGFueSBlbGVtZW50IG9mIGFuIGFycmF5LlxuICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2tmbiBBIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB1cCB0byB0aHJlZSBhcmd1bWVudHMuIFRoZSBzb21lIG1ldGhvZCBjYWxsc1xuICAgICAgICAgKiB0aGUgY2FsbGJhY2tmbiBmdW5jdGlvbiBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheSB1bnRpbCB0aGUgY2FsbGJhY2tmbiByZXR1cm5zIGEgdmFsdWVcbiAgICAgICAgICogd2hpY2ggaXMgY29lcmNpYmxlIHRvIHRoZSBCb29sZWFuIHZhbHVlIHRydWUsIG9yIHVudGlsIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAgICAgKiBAcGFyYW0gdGhpc0FyZyBBbiBvYmplY3QgdG8gd2hpY2ggdGhlIHRoaXMga2V5d29yZCBjYW4gcmVmZXIgaW4gdGhlIGNhbGxiYWNrZm4gZnVuY3Rpb24uXG4gICAgICAgICAqIElmIHRoaXNBcmcgaXMgb21pdHRlZCwgdW5kZWZpbmVkIGlzIHVzZWQgYXMgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICBzb21lKGNhbGxiYWNrZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLnNvbWUoY2FsbGJhY2tmbiwgdGhpc0FyZyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm1zIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZvciBlYWNoIGVsZW1lbnQgaW4gYW4gYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFja2ZuICBBIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB1cCB0byB0aHJlZSBhcmd1bWVudHMuIGZvckVhY2ggY2FsbHMgdGhlIGNhbGxiYWNrZm4gZnVuY3Rpb24gb25lIHRpbWUgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSB0aGlzQXJnICBBbiBvYmplY3QgdG8gd2hpY2ggdGhlIHRoaXMga2V5d29yZCBjYW4gcmVmZXIgaW4gdGhlIGNhbGxiYWNrZm4gZnVuY3Rpb24uIElmIHRoaXNBcmcgaXMgb21pdHRlZCwgdW5kZWZpbmVkIGlzIHVzZWQgYXMgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICBmb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxzIGEgZGVmaW5lZCBjYWxsYmFjayBmdW5jdGlvbiBvbiBlYWNoIGVsZW1lbnQgb2YgYW4gYXJyYXksIGFuZCByZXR1cm5zIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFja2ZuIEEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIHRocmVlIGFyZ3VtZW50cy4gVGhlIG1hcCBtZXRob2QgY2FsbHMgdGhlIGNhbGxiYWNrZm4gZnVuY3Rpb24gb25lIHRpbWUgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSB0aGlzQXJnIEFuIG9iamVjdCB0byB3aGljaCB0aGUgdGhpcyBrZXl3b3JkIGNhbiByZWZlciBpbiB0aGUgY2FsbGJhY2tmbiBmdW5jdGlvbi4gSWYgdGhpc0FyZyBpcyBvbWl0dGVkLCB1bmRlZmluZWQgaXMgdXNlZCBhcyB0aGUgdGhpcyB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIG1hcChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5tYXAoY2FsbGJhY2tmbiwgdGhpc0FyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZmlsdGVyKGNhbGxiYWNrZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmZpbHRlcihjYWxsYmFja2ZuLCB0aGlzQXJnKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbHMgdGhlIHNwZWNpZmllZCBjYWxsYmFjayBmdW5jdGlvbiBmb3IgYWxsIHRoZSBlbGVtZW50cyBpbiBhbiBhcnJheS4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCwgYW5kIGlzIHByb3ZpZGVkIGFzIGFuIGFyZ3VtZW50IGluIHRoZSBuZXh0IGNhbGwgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2tmbiBBIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB1cCB0byBmb3VyIGFyZ3VtZW50cy4gVGhlIHJlZHVjZSBtZXRob2QgY2FsbHMgdGhlIGNhbGxiYWNrZm4gZnVuY3Rpb24gb25lIHRpbWUgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSBpbml0aWFsVmFsdWUgSWYgaW5pdGlhbFZhbHVlIGlzIHNwZWNpZmllZCwgaXQgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbCB2YWx1ZSB0byBzdGFydCB0aGUgYWNjdW11bGF0aW9uLiBUaGUgZmlyc3QgY2FsbCB0byB0aGUgY2FsbGJhY2tmbiBmdW5jdGlvbiBwcm92aWRlcyB0aGlzIHZhbHVlIGFzIGFuIGFyZ3VtZW50IGluc3RlYWQgb2YgYW4gYXJyYXkgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICByZWR1Y2UoY2FsbGJhY2tmbiwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5yZWR1Y2UoY2FsbGJhY2tmbiwgaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbHMgdGhlIHNwZWNpZmllZCBjYWxsYmFjayBmdW5jdGlvbiBmb3IgYWxsIHRoZSBlbGVtZW50cyBpbiBhbiBhcnJheSwgaW4gZGVzY2VuZGluZyBvcmRlci4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCwgYW5kIGlzIHByb3ZpZGVkIGFzIGFuIGFyZ3VtZW50IGluIHRoZSBuZXh0IGNhbGwgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2tmbiBBIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB1cCB0byBmb3VyIGFyZ3VtZW50cy4gVGhlIHJlZHVjZVJpZ2h0IG1ldGhvZCBjYWxscyB0aGUgY2FsbGJhY2tmbiBmdW5jdGlvbiBvbmUgdGltZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheS5cbiAgICAgICAgICogQHBhcmFtIGluaXRpYWxWYWx1ZSBJZiBpbml0aWFsVmFsdWUgaXMgc3BlY2lmaWVkLCBpdCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsIHZhbHVlIHRvIHN0YXJ0IHRoZSBhY2N1bXVsYXRpb24uIFRoZSBmaXJzdCBjYWxsIHRvIHRoZSBjYWxsYmFja2ZuIGZ1bmN0aW9uIHByb3ZpZGVzIHRoaXMgdmFsdWUgYXMgYW4gYXJndW1lbnQgaW5zdGVhZCBvZiBhbiBhcnJheSB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4sIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMucmVkdWNlUmlnaHQoY2FsbGJhY2tmbiwgaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGFycmF5IHdoZXJlIHByZWRpY2F0ZSBpcyB0cnVlLCBhbmQgdW5kZWZpbmVkXG4gICAgICAgICAqIG90aGVyd2lzZS5cbiAgICAgICAgICogQHBhcmFtIHByZWRpY2F0ZSBmaW5kIGNhbGxzIHByZWRpY2F0ZSBvbmNlIGZvciBlYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5LCBpbiBhc2NlbmRpbmdcbiAgICAgICAgICogb3JkZXIsIHVudGlsIGl0IGZpbmRzIG9uZSB3aGVyZSBwcmVkaWNhdGUgcmV0dXJucyB0cnVlLiBJZiBzdWNoIGFuIGVsZW1lbnQgaXMgZm91bmQsIGZpbmRcbiAgICAgICAgICogaW1tZWRpYXRlbHkgcmV0dXJucyB0aGF0IGVsZW1lbnQgdmFsdWUuIE90aGVyd2lzZSwgZmluZCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICAgICAgICogQHBhcmFtIHRoaXNBcmcgSWYgcHJvdmlkZWQsIGl0IHdpbGwgYmUgdXNlZCBhcyB0aGUgdGhpcyB2YWx1ZSBmb3IgZWFjaCBpbnZvY2F0aW9uIG9mXG4gICAgICAgICAqIHByZWRpY2F0ZS4gSWYgaXQgaXMgbm90IHByb3ZpZGVkLCB1bmRlZmluZWQgaXMgdXNlZCBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgZmluZChwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmZpbmQocHJlZGljYXRlLCB0aGlzQXJnKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGFycmF5IHdoZXJlIHByZWRpY2F0ZSBpcyB0cnVlLCBhbmQgLTFcbiAgICAgICAgICogb3RoZXJ3aXNlLlxuICAgICAgICAgKiBAcGFyYW0gcHJlZGljYXRlIGZpbmQgY2FsbHMgcHJlZGljYXRlIG9uY2UgZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgYXJyYXksIGluIGFzY2VuZGluZ1xuICAgICAgICAgKiBvcmRlciwgdW50aWwgaXQgZmluZHMgb25lIHdoZXJlIHByZWRpY2F0ZSByZXR1cm5zIHRydWUuIElmIHN1Y2ggYW4gZWxlbWVudCBpcyBmb3VuZCxcbiAgICAgICAgICogZmluZEluZGV4IGltbWVkaWF0ZWx5IHJldHVybnMgdGhhdCBlbGVtZW50IGluZGV4LiBPdGhlcndpc2UsIGZpbmRJbmRleCByZXR1cm5zIC0xLlxuICAgICAgICAgKiBAcGFyYW0gdGhpc0FyZyBJZiBwcm92aWRlZCwgaXQgd2lsbCBiZSB1c2VkIGFzIHRoZSB0aGlzIHZhbHVlIGZvciBlYWNoIGludm9jYXRpb24gb2ZcbiAgICAgICAgICogcHJlZGljYXRlLiBJZiBpdCBpcyBub3QgcHJvdmlkZWQsIHVuZGVmaW5lZCBpcyB1c2VkIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICBmaW5kSW5kZXgocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5maW5kSW5kZXgocHJlZGljYXRlLCB0aGlzQXJnKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgdGhpcyBvYmplY3QgYWZ0ZXIgZmlsbGluZyB0aGUgc2VjdGlvbiBpZGVudGlmaWVkIGJ5IHN0YXJ0IGFuZCBlbmQgd2l0aCB2YWx1ZVxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgdmFsdWUgdG8gZmlsbCBhcnJheSBzZWN0aW9uIHdpdGhcbiAgICAgICAgICogQHBhcmFtIHN0YXJ0IGluZGV4IHRvIHN0YXJ0IGZpbGxpbmcgdGhlIGFycmF5IGF0LiBJZiBzdGFydCBpcyBuZWdhdGl2ZSwgaXQgaXMgdHJlYXRlZCBhc1xuICAgICAgICAgKiBsZW5ndGgrc3RhcnQgd2hlcmUgbGVuZ3RoIGlzIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgICAgICAgKiBAcGFyYW0gZW5kIGluZGV4IHRvIHN0b3AgZmlsbGluZyB0aGUgYXJyYXkgYXQuIElmIGVuZCBpcyBuZWdhdGl2ZSwgaXQgaXMgdHJlYXRlZCBhc1xuICAgICAgICAgKiBsZW5ndGgrZW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgZmlsbCh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheVNjaGVtYSNmaWxsKCkgbm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB0aGlzIG9iamVjdCBhZnRlciBjb3B5aW5nIGEgc2VjdGlvbiBvZiB0aGUgYXJyYXkgaWRlbnRpZmllZCBieSBzdGFydCBhbmQgZW5kXG4gICAgICAgICAqIHRvIHRoZSBzYW1lIGFycmF5IHN0YXJ0aW5nIGF0IHBvc2l0aW9uIHRhcmdldFxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IElmIHRhcmdldCBpcyBuZWdhdGl2ZSwgaXQgaXMgdHJlYXRlZCBhcyBsZW5ndGgrdGFyZ2V0IHdoZXJlIGxlbmd0aCBpcyB0aGVcbiAgICAgICAgICogbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAgICAgICAgICogQHBhcmFtIHN0YXJ0IElmIHN0YXJ0IGlzIG5lZ2F0aXZlLCBpdCBpcyB0cmVhdGVkIGFzIGxlbmd0aCtzdGFydC4gSWYgZW5kIGlzIG5lZ2F0aXZlLCBpdFxuICAgICAgICAgKiBpcyB0cmVhdGVkIGFzIGxlbmd0aCtlbmQuXG4gICAgICAgICAqIEBwYXJhbSBlbmQgSWYgbm90IHNwZWNpZmllZCwgbGVuZ3RoIG9mIHRoZSB0aGlzIG9iamVjdCBpcyB1c2VkIGFzIGl0cyBkZWZhdWx0IHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlTY2hlbWEjY29weVdpdGhpbigpIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBhcnJheS4gVGhlIGVsZW1lbnRzIGFyZSBjb252ZXJ0ZWQgdG8gc3RyaW5nIHVzaW5nIHRoZWlyIHRvTG9jYWxTdHJpbmcgbWV0aG9kcy5cbiAgICAgICAgICovXG4gICAgICAgIHRvTG9jYWxlU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIC8qKiBJdGVyYXRvciAqL1xuICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0IFtTeW1ib2wuc3BlY2llc10oKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXlTY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYW4gaXRlcmFibGUgb2Yga2V5LCB2YWx1ZSBwYWlycyBmb3IgZXZlcnkgZW50cnkgaW4gdGhlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBlbnRyaWVzKCkgeyByZXR1cm4gdGhpcy5pdGVtcy5lbnRyaWVzKCk7IH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYW4gaXRlcmFibGUgb2Yga2V5cyBpbiB0aGUgYXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIGtleXMoKSB7IHJldHVybiB0aGlzLml0ZW1zLmtleXMoKTsgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBpdGVyYWJsZSBvZiB2YWx1ZXMgaW4gdGhlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZXMoKSB7IHJldHVybiB0aGlzLml0ZW1zLnZhbHVlcygpOyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gYXJyYXkgaW5jbHVkZXMgYSBjZXJ0YWluIGVsZW1lbnQsIHJldHVybmluZyB0cnVlIG9yIGZhbHNlIGFzIGFwcHJvcHJpYXRlLlxuICAgICAgICAgKiBAcGFyYW0gc2VhcmNoRWxlbWVudCBUaGUgZWxlbWVudCB0byBzZWFyY2ggZm9yLlxuICAgICAgICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBwb3NpdGlvbiBpbiB0aGlzIGFycmF5IGF0IHdoaWNoIHRvIGJlZ2luIHNlYXJjaGluZyBmb3Igc2VhcmNoRWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIGluY2x1ZGVzKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuaW5jbHVkZXMoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICAvL1xuICAgICAgICAvLyBFUzIwMjJcbiAgICAgICAgLy9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxzIGEgZGVmaW5lZCBjYWxsYmFjayBmdW5jdGlvbiBvbiBlYWNoIGVsZW1lbnQgb2YgYW4gYXJyYXkuIFRoZW4sIGZsYXR0ZW5zIHRoZSByZXN1bHQgaW50b1xuICAgICAgICAgKiBhIG5ldyBhcnJheS5cbiAgICAgICAgICogVGhpcyBpcyBpZGVudGljYWwgdG8gYSBtYXAgZm9sbG93ZWQgYnkgZmxhdCB3aXRoIGRlcHRoIDEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB1cCB0byB0aHJlZSBhcmd1bWVudHMuIFRoZSBmbGF0TWFwIG1ldGhvZCBjYWxscyB0aGVcbiAgICAgICAgICogY2FsbGJhY2sgZnVuY3Rpb24gb25lIHRpbWUgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSB0aGlzQXJnIEFuIG9iamVjdCB0byB3aGljaCB0aGUgdGhpcyBrZXl3b3JkIGNhbiByZWZlciBpbiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uIElmXG4gICAgICAgICAqIHRoaXNBcmcgaXMgb21pdHRlZCwgdW5kZWZpbmVkIGlzIHVzZWQgYXMgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGZsYXRNYXAoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5U2NoZW1hI2ZsYXRNYXAoKSBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBhcnJheSB3aXRoIGFsbCBzdWItYXJyYXkgZWxlbWVudHMgY29uY2F0ZW5hdGVkIGludG8gaXQgcmVjdXJzaXZlbHkgdXAgdG8gdGhlXG4gICAgICAgICAqIHNwZWNpZmllZCBkZXB0aC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBmbGF0KGRlcHRoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheVNjaGVtYSNmbGF0KCkgaXMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZmluZExhc3QoKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5maW5kTGFzdC5hcHBseSh0aGlzLml0ZW1zLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmRMYXN0SW5kZXgoLi4uYXJncykge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZmluZExhc3RJbmRleC5hcHBseSh0aGlzLml0ZW1zLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEVTMjAyM1xuICAgICAgICAvL1xuICAgICAgICB3aXRoKGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgY29weSA9IHRoaXMuaXRlbXMuc2xpY2UoKTtcbiAgICAgICAgICAgIC8vIEFsbG93IG5lZ2F0aXZlIGluZGV4aW5nIGZyb20gdGhlIGVuZFxuICAgICAgICAgICAgaWYgKGluZGV4IDwgMClcbiAgICAgICAgICAgICAgICBpbmRleCArPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvcHlbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5U2NoZW1hKC4uLmNvcHkpO1xuICAgICAgICB9XG4gICAgICAgIHRvUmV2ZXJzZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5zbGljZSgpLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0b1NvcnRlZChjb21wYXJlRm4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLnNsaWNlKCkuc29ydChjb21wYXJlRm4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdG9TcGxpY2VkKHN0YXJ0LCBkZWxldGVDb3VudCwgLi4uaXRlbXMpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLnRvU3BsaWNlZC5hcHBseShjb3B5LCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHNodWZmbGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb3ZlKChfKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJyZW50SW5kZXggIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50SW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgW3RoaXNbY3VycmVudEluZGV4XSwgdGhpc1tyYW5kb21JbmRleF1dID0gW3RoaXNbcmFuZG9tSW5kZXhdLCB0aGlzW2N1cnJlbnRJbmRleF1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGxvd3MgdG8gbW92ZSBpdGVtcyBhcm91bmQgaW4gdGhlIGFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlOlxuICAgICAgICAgKiAgICAgc3RhdGUuY2FyZHMubW92ZSgoY2FyZHMpID0+IHtcbiAgICAgICAgICogICAgICAgICBbY2FyZHNbNF0sIGNhcmRzWzNdXSA9IFtjYXJkc1szXSwgY2FyZHNbNF1dO1xuICAgICAgICAgKiAgICAgICAgIFtjYXJkc1szXSwgY2FyZHNbMl1dID0gW2NhcmRzWzJdLCBjYXJkc1szXV07XG4gICAgICAgICAqICAgICAgICAgW2NhcmRzWzJdLCBjYXJkc1swXV0gPSBbY2FyZHNbMF0sIGNhcmRzWzJdXTtcbiAgICAgICAgICogICAgICAgICBbY2FyZHNbMV0sIGNhcmRzWzFdXSA9IFtjYXJkc1sxXSwgY2FyZHNbMV1dO1xuICAgICAgICAgKiAgICAgICAgIFtjYXJkc1swXSwgY2FyZHNbMF1dID0gW2NhcmRzWzBdLCBjYXJkc1swXV07XG4gICAgICAgICAqICAgICB9KVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY2JcbiAgICAgICAgICogQHJldHVybnNcbiAgICAgICAgICovXG4gICAgICAgIG1vdmUoY2IpIHtcbiAgICAgICAgICAgIHRoaXMuaXNNb3ZpbmdJdGVtcyA9IHRydWU7XG4gICAgICAgICAgICBjYih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuaXNNb3ZpbmdJdGVtcyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgWygkZ2V0QnlJbmRleCldKGluZGV4LCBpc0VuY29kZUFsbCA9IGZhbHNlKSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVE9ETzogYXZvaWQgdW5lY2Vzc2FyeSBgdGhpcy50bXBJdGVtc2AgY2hlY2sgZHVyaW5nIGRlY29kaW5nLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgIEVOQ09ESU5HIHVzZXMgYHRoaXMudG1wSXRlbXNgIChvciBgdGhpcy5pdGVtc2AgaWYgYGlzRW5jb2RlQWxsYCBpcyB0cnVlKVxuICAgICAgICAgICAgLy8gICAgREVDT0RJTkcgdXNlcyBgdGhpcy5pdGVtc2BcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICByZXR1cm4gKGlzRW5jb2RlQWxsKVxuICAgICAgICAgICAgICAgID8gdGhpcy5pdGVtc1tpbmRleF1cbiAgICAgICAgICAgICAgICA6IHRoaXMuZGVsZXRlZEluZGV4ZXNbaW5kZXhdXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5pdGVtc1tpbmRleF1cbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnRtcEl0ZW1zW2luZGV4XSB8fCB0aGlzLml0ZW1zW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBbJGRlbGV0ZUJ5SW5kZXhdKGluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zW2luZGV4XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMudG1wSXRlbXNbaW5kZXhdID0gdW5kZWZpbmVkOyAvLyBUT0RPOiBkbyBub3QgdHJ5IHRvIGdldCBcInRtcEl0ZW1zXCIgYXQgZGVjb2RpbmcgdGltZS5cbiAgICAgICAgfVxuICAgICAgICBbJG9uRW5jb2RlRW5kXSgpIHtcbiAgICAgICAgICAgIHRoaXMudG1wSXRlbXMgPSB0aGlzLml0ZW1zLnNsaWNlKCk7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZWRJbmRleGVzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgWyRvbkRlY29kZUVuZF0oKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zID0gdGhpcy5pdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0gIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB0aGlzLnRtcEl0ZW1zID0gdGhpcy5pdGVtcy5zbGljZSgpOyAvLyBUT0RPOiBkbyBubyB1c2UgXCJ0bXBJdGVtc1wiIGF0IGRlY29kaW5nIHRpbWUuXG4gICAgICAgIH1cbiAgICAgICAgdG9BcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLnNsaWNlKDApO1xuICAgICAgICB9XG4gICAgICAgIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgKHZhbHVlWyd0b0pTT04nXSkgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZVsndG9KU09OJ10oKVxuICAgICAgICAgICAgICAgICAgICA6IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRGVjb2RpbmcgdXRpbGl0aWVzXG4gICAgICAgIC8vXG4gICAgICAgIGNsb25lKGlzRGVjb2RpbmcpIHtcbiAgICAgICAgICAgIGxldCBjbG9uZWQ7XG4gICAgICAgICAgICBpZiAoaXNEZWNvZGluZykge1xuICAgICAgICAgICAgICAgIGNsb25lZCA9IG5ldyBBcnJheVNjaGVtYSgpO1xuICAgICAgICAgICAgICAgIGNsb25lZC5wdXNoKC4uLnRoaXMuaXRlbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xvbmVkID0gbmV3IEFycmF5U2NoZW1hKC4uLnRoaXMubWFwKGl0ZW0gPT4gKChpdGVtWyRjaGFuZ2VzXSlcbiAgICAgICAgICAgICAgICAgICAgPyBpdGVtLmNsb25lKClcbiAgICAgICAgICAgICAgICAgICAgOiBpdGVtKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgfVxuICAgIHJlZ2lzdGVyVHlwZShcImFycmF5XCIsIHsgY29uc3RydWN0b3I6IEFycmF5U2NoZW1hIH0pO1xuXG4gICAgdmFyIF9hJDMsIF9iJDM7XG4gICAgY2xhc3MgTWFwU2NoZW1hIHtcbiAgICAgICAgc3RhdGljIHsgdGhpc1tfYSQzXSA9IGVuY29kZUtleVZhbHVlT3BlcmF0aW9uOyB9XG4gICAgICAgIHN0YXRpYyB7IHRoaXNbX2IkM10gPSBkZWNvZGVLZXlWYWx1ZU9wZXJhdGlvbjsgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lIGlmIGEgcHJvcGVydHkgbXVzdCBiZSBmaWx0ZXJlZC5cbiAgICAgICAgICogLSBJZiByZXR1cm5zIGZhbHNlLCB0aGUgcHJvcGVydHkgaXMgTk9UIGdvaW5nIHRvIGJlIGVuY29kZWQuXG4gICAgICAgICAqIC0gSWYgcmV0dXJucyB0cnVlLCB0aGUgcHJvcGVydHkgaXMgZ29pbmcgdG8gYmUgZW5jb2RlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogRW5jb2Rpbmcgd2l0aCBcImZpbHRlcnNcIiBoYXBwZW5zIGluIHR3byBzdGVwczpcbiAgICAgICAgICogLSBGaXJzdCwgdGhlIGVuY29kZXIgaXRlcmF0ZXMgb3ZlciBhbGwgXCJub3Qgb3duZWRcIiBwcm9wZXJ0aWVzIGFuZCBlbmNvZGVzIHRoZW0uXG4gICAgICAgICAqIC0gVGhlbiwgdGhlIGVuY29kZXIgaXRlcmF0ZXMgb3ZlciBhbGwgXCJvd25lZFwiIHByb3BlcnRpZXMgcGVyIGluc3RhbmNlIGFuZCBlbmNvZGVzIHRoZW0uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgWyhfYSQzID0gJGVuY29kZXIsIF9iJDMgPSAkZGVjb2RlciwgJGZpbHRlcildKHJlZiwgaW5kZXgsIHZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiAoIXZpZXcgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgKHJlZlskY2hpbGRUeXBlXSkgPT09IFwic3RyaW5nXCIgfHxcbiAgICAgICAgICAgICAgICB2aWV3LmlzQ2hhbmdlVHJlZVZpc2libGUoKHJlZlskZ2V0QnlJbmRleF0oaW5kZXgpID8/IHJlZi5kZWxldGVkSXRlbXNbaW5kZXhdKVskY2hhbmdlc10pKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgaXModHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVbJ21hcCddICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3RydWN0b3IoaW5pdGlhbFZhbHVlcykge1xuICAgICAgICAgICAgdGhpcy4kaXRlbXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLiRpbmRleGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5kZWxldGVkSXRlbXMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZVRyZWUgPSBuZXcgQ2hhbmdlVHJlZSh0aGlzKTtcbiAgICAgICAgICAgIGNoYW5nZVRyZWUuaW5kZXhlcyA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICRjaGFuZ2VzLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGNoYW5nZVRyZWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpbml0aWFsVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxWYWx1ZXMgaW5zdGFuY2VvZiBNYXAgfHxcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlcyBpbnN0YW5jZW9mIE1hcFNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsVmFsdWVzLmZvckVhY2goKHYsIGspID0+IHRoaXMuc2V0KGssIHYpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBpbml0aWFsVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChrLCBpbml0aWFsVmFsdWVzW2tdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAkY2hpbGRUeXBlLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKiogSXRlcmF0b3IgKi9cbiAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7IHJldHVybiB0aGlzLiRpdGVtc1tTeW1ib2wuaXRlcmF0b3JdKCk7IH1cbiAgICAgICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkgeyByZXR1cm4gdGhpcy4kaXRlbXNbU3ltYm9sLnRvU3RyaW5nVGFnXTsgfVxuICAgICAgICBzdGF0aWMgZ2V0IFtTeW1ib2wuc3BlY2llc10oKSB7IHJldHVybiBNYXBTY2hlbWE7IH1cbiAgICAgICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYXBTY2hlbWEjc2V0KCcke2tleX0nLCAke3ZhbHVlfSk6IHRyeWluZyB0byBzZXQgJHt2YWx1ZX0gdmFsdWUgb24gJyR7a2V5fScuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiB0aGlzWyRjaGlsZFR5cGVdKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0SW5zdGFuY2VUeXBlKHZhbHVlLCB0aGlzWyRjaGlsZFR5cGVdLCB0aGlzLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm9yY2UgXCJrZXlcIiBhcyBzdHJpbmdcbiAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2NvbHlzZXVzL2NvbHlzZXVzL2lzc3Vlcy81NjEjaXNzdWVjb21tZW50LTE2NDY3MzM0NjhcbiAgICAgICAgICAgIGtleSA9IGtleS50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IHRoaXNbJGNoYW5nZXNdO1xuICAgICAgICAgICAgY29uc3QgaXNSZWYgPSAodmFsdWVbJGNoYW5nZXNdKSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICAgICAgbGV0IG9wZXJhdGlvbjtcbiAgICAgICAgICAgIC8vIElTIFJFUExBQ0U/XG4gICAgICAgICAgICBpZiAodHlwZW9mIChjaGFuZ2VUcmVlLmluZGV4ZXNba2V5XSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNoYW5nZVRyZWUuaW5kZXhlc1trZXldO1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IGV4cG9ydHMuT1BFUkFUSU9OLlJFUExBQ0U7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHRoaXMuJGl0ZW1zLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1ZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB2YWx1ZSBpcyB0aGUgc2FtZSwgYXZvaWQgcmUtZW5jb2RpbmcgaXQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXMgc2NoZW1hLCBmb3JjZSBBREQgb3BlcmF0aW9uIGlmIHZhbHVlIGRpZmZlciBmcm9tIHByZXZpb3VzIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFX0FORF9BREQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBwcmV2aW91cyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlWyRjaGFuZ2VzXS5yb290Py5yZW1vdmUocHJldmlvdXNWYWx1ZVskY2hhbmdlc10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlbGV0ZWRJdGVtc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGVsZXRlZEl0ZW1zW2luZGV4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNoYW5nZVRyZWUuaW5kZXhlc1skbnVtRmllbGRzXSA/PyAwO1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IGV4cG9ydHMuT1BFUkFUSU9OLkFERDtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbmRleGVzLnNldChpbmRleCwga2V5KTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlLmluZGV4ZXNba2V5XSA9IGluZGV4O1xuICAgICAgICAgICAgICAgIGNoYW5nZVRyZWUuaW5kZXhlc1skbnVtRmllbGRzXSA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJGl0ZW1zLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIGNoYW5nZVRyZWUuY2hhbmdlKGluZGV4LCBvcGVyYXRpb24pO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHNldCB2YWx1ZSdzIHBhcmVudCBhZnRlciB0aGUgdmFsdWUgaXMgc2V0XG4gICAgICAgICAgICAvLyAodG8gYXZvaWQgZW5jb2RpbmcgXCJyZWZJZFwiIG9wZXJhdGlvbnMgYmVmb3JlIHBhcmVudCdzIFwiQUREXCIgb3BlcmF0aW9uKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGlmIChpc1JlZikge1xuICAgICAgICAgICAgICAgIHZhbHVlWyRjaGFuZ2VzXS5zZXRQYXJlbnQodGhpcywgY2hhbmdlVHJlZS5yb290LCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBnZXQoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlKGtleSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLiRpdGVtcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpc1skY2hhbmdlc10uaW5kZXhlc1trZXldO1xuICAgICAgICAgICAgdGhpcy5kZWxldGVkSXRlbXNbaW5kZXhdID0gdGhpc1skY2hhbmdlc10uZGVsZXRlKGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhcigpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZVRyZWUgPSB0aGlzWyRjaGFuZ2VzXTtcbiAgICAgICAgICAgIC8vIGRpc2NhcmQgcHJldmlvdXMgb3BlcmF0aW9ucy5cbiAgICAgICAgICAgIGNoYW5nZVRyZWUuZGlzY2FyZCh0cnVlKTtcbiAgICAgICAgICAgIGNoYW5nZVRyZWUuaW5kZXhlcyA9IHt9O1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuIHJlZmVyZW5jZXNcbiAgICAgICAgICAgIGNoYW5nZVRyZWUuZm9yRWFjaENoaWxkKChjaGlsZENoYW5nZVRyZWUsIF8pID0+IHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlLnJvb3Q/LnJlbW92ZShjaGlsZENoYW5nZVRyZWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBjbGVhciBwcmV2aW91cyBpbmRleGVzXG4gICAgICAgICAgICB0aGlzLiRpbmRleGVzLmNsZWFyKCk7XG4gICAgICAgICAgICAvLyBjbGVhciBpdGVtc1xuICAgICAgICAgICAgdGhpcy4kaXRlbXMuY2xlYXIoKTtcbiAgICAgICAgICAgIGNoYW5nZVRyZWUub3BlcmF0aW9uKGV4cG9ydHMuT1BFUkFUSU9OLkNMRUFSKTtcbiAgICAgICAgfVxuICAgICAgICBoYXMoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuaGFzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yRWFjaChjYWxsYmFja2ZuKSB7XG4gICAgICAgICAgICB0aGlzLiRpdGVtcy5mb3JFYWNoKGNhbGxiYWNrZm4pO1xuICAgICAgICB9XG4gICAgICAgIGVudHJpZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuZW50cmllcygpO1xuICAgICAgICB9XG4gICAgICAgIGtleXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMua2V5cygpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy52YWx1ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy5zaXplO1xuICAgICAgICB9XG4gICAgICAgIHNldEluZGV4KGluZGV4LCBrZXkpIHtcbiAgICAgICAgICAgIHRoaXMuJGluZGV4ZXMuc2V0KGluZGV4LCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGdldEluZGV4KGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaW5kZXhlcy5nZXQoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIFskZ2V0QnlJbmRleF0oaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy5nZXQodGhpcy4kaW5kZXhlcy5nZXQoaW5kZXgpKTtcbiAgICAgICAgfVxuICAgICAgICBbJGRlbGV0ZUJ5SW5kZXhdKGluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLiRpbmRleGVzLmdldChpbmRleCk7XG4gICAgICAgICAgICB0aGlzLiRpdGVtcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIHRoaXMuJGluZGV4ZXMuZGVsZXRlKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBbJG9uRW5jb2RlRW5kXSgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZVRyZWUgPSB0aGlzWyRjaGFuZ2VzXTtcbiAgICAgICAgICAgIC8vIC0gY2xlYW51cCBjaGFuZ2VUcmVlLmluZGV4ZXNcbiAgICAgICAgICAgIC8vIC0gY2xlYW51cCAkaW5kZXhlc1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleFN0ciBpbiB0aGlzLmRlbGV0ZWRJdGVtcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoaW5kZXhTdHIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuJGluZGV4ZXMuZ2V0KGluZGV4KTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiByZWZhY3RvciB0aGlzLlxuICAgICAgICAgICAgICAgIC8vIGl0IHNob3VsZG4ndCBiZSBuZWNlc3NhcnkgdG8ga2VlcCB0cmFjayBvZiBpbmRleGVzIGJvdGggb24gY2hhbmdlVHJlZSBhbmQgb24gJGluZGV4ZXNcbiAgICAgICAgICAgICAgICBkZWxldGUgY2hhbmdlVHJlZS5pbmRleGVzW2tleV07XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5kZWxldGUoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZWxldGVkSXRlbXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0b0pTT04oKSB7XG4gICAgICAgICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIG1hcFtrZXldID0gKHR5cGVvZiAodmFsdWVbJ3RvSlNPTiddKSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICA/IHZhbHVlWyd0b0pTT04nXSgpXG4gICAgICAgICAgICAgICAgICAgIDogdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRGVjb2RpbmcgdXRpbGl0aWVzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY2xvbmUoaXNEZWNvZGluZykge1xuICAgICAgICAgICAgbGV0IGNsb25lZDtcbiAgICAgICAgICAgIGlmIChpc0RlY29kaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gY2xpZW50LXNpZGVcbiAgICAgICAgICAgICAgICBjbG9uZWQgPSBPYmplY3QuYXNzaWduKG5ldyBNYXBTY2hlbWEoKSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzZXJ2ZXItc2lkZVxuICAgICAgICAgICAgICAgIGNsb25lZCA9IG5ldyBNYXBTY2hlbWEoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlWyRjaGFuZ2VzXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVkLnNldChrZXksIHZhbHVlWydjbG9uZSddKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVkLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWdpc3RlclR5cGUoXCJtYXBcIiwgeyBjb25zdHJ1Y3RvcjogTWFwU2NoZW1hIH0pO1xuXG4gICAgdmFyIF9hJDIsIF9iJDI7XG4gICAgY2xhc3MgQ29sbGVjdGlvblNjaGVtYSB7XG4gICAgICAgIHN0YXRpYyB7IHRoaXNbX2EkMl0gPSBlbmNvZGVLZXlWYWx1ZU9wZXJhdGlvbjsgfVxuICAgICAgICBzdGF0aWMgeyB0aGlzW19iJDJdID0gZGVjb2RlS2V5VmFsdWVPcGVyYXRpb247IH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZSBpZiBhIHByb3BlcnR5IG11c3QgYmUgZmlsdGVyZWQuXG4gICAgICAgICAqIC0gSWYgcmV0dXJucyBmYWxzZSwgdGhlIHByb3BlcnR5IGlzIE5PVCBnb2luZyB0byBiZSBlbmNvZGVkLlxuICAgICAgICAgKiAtIElmIHJldHVybnMgdHJ1ZSwgdGhlIHByb3BlcnR5IGlzIGdvaW5nIHRvIGJlIGVuY29kZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEVuY29kaW5nIHdpdGggXCJmaWx0ZXJzXCIgaGFwcGVucyBpbiB0d28gc3RlcHM6XG4gICAgICAgICAqIC0gRmlyc3QsIHRoZSBlbmNvZGVyIGl0ZXJhdGVzIG92ZXIgYWxsIFwibm90IG93bmVkXCIgcHJvcGVydGllcyBhbmQgZW5jb2RlcyB0aGVtLlxuICAgICAgICAgKiAtIFRoZW4sIHRoZSBlbmNvZGVyIGl0ZXJhdGVzIG92ZXIgYWxsIFwib3duZWRcIiBwcm9wZXJ0aWVzIHBlciBpbnN0YW5jZSBhbmQgZW5jb2RlcyB0aGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIFsoX2EkMiA9ICRlbmNvZGVyLCBfYiQyID0gJGRlY29kZXIsICRmaWx0ZXIpXShyZWYsIGluZGV4LCB2aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gKCF2aWV3IHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIChyZWZbJGNoaWxkVHlwZV0pID09PSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICAgICAgdmlldy5pc0NoYW5nZVRyZWVWaXNpYmxlKChyZWZbJGdldEJ5SW5kZXhdKGluZGV4KSA/PyByZWYuZGVsZXRlZEl0ZW1zW2luZGV4XSlbJGNoYW5nZXNdKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGlzKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlWydjb2xsZWN0aW9uJ10gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdHJ1Y3Rvcihpbml0aWFsVmFsdWVzKSB7XG4gICAgICAgICAgICB0aGlzLiRpdGVtcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuJGluZGV4ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZWRJdGVtcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy4kcmVmSWQgPSAwO1xuICAgICAgICAgICAgdGhpc1skY2hhbmdlc10gPSBuZXcgQ2hhbmdlVHJlZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXNbJGNoYW5nZXNdLmluZGV4ZXMgPSB7fTtcbiAgICAgICAgICAgIGlmIChpbml0aWFsVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlcy5mb3JFYWNoKCh2KSA9PiB0aGlzLmFkZCh2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJGNoaWxkVHlwZSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBzZXQgXCJpbmRleFwiIGZvciByZWZlcmVuY2UuXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuJHJlZklkKys7XG4gICAgICAgICAgICBjb25zdCBpc1JlZiA9ICh2YWx1ZVskY2hhbmdlc10pICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoaXNSZWYpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVskY2hhbmdlc10uc2V0UGFyZW50KHRoaXMsIHRoaXNbJGNoYW5nZXNdLnJvb3QsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbJGNoYW5nZXNdLmluZGV4ZXNbaW5kZXhdID0gaW5kZXg7XG4gICAgICAgICAgICB0aGlzLiRpbmRleGVzLnNldChpbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy4kaXRlbXMuc2V0KGluZGV4LCB2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzWyRjaGFuZ2VzXS5jaGFuZ2UoaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGF0KGluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLmtleXMoKSlbaW5kZXhdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVudHJpZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuZW50cmllcygpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZShpdGVtKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gdGhpcy4kaXRlbXMuZW50cmllcygpO1xuICAgICAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICAgICAgbGV0IGVudHJ5O1xuICAgICAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cmllcy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gPT09IGVudHJ5LnZhbHVlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gZW50cnkudmFsdWVbMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZWxldGVkSXRlbXNbaW5kZXhdID0gdGhpc1skY2hhbmdlc10uZGVsZXRlKGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuJGluZGV4ZXMuZGVsZXRlKGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy5kZWxldGUoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyKCkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IHRoaXNbJGNoYW5nZXNdO1xuICAgICAgICAgICAgLy8gZGlzY2FyZCBwcmV2aW91cyBvcGVyYXRpb25zLlxuICAgICAgICAgICAgY2hhbmdlVHJlZS5kaXNjYXJkKHRydWUpO1xuICAgICAgICAgICAgY2hhbmdlVHJlZS5pbmRleGVzID0ge307XG4gICAgICAgICAgICAvLyByZW1vdmUgY2hpbGRyZW4gcmVmZXJlbmNlc1xuICAgICAgICAgICAgY2hhbmdlVHJlZS5mb3JFYWNoQ2hpbGQoKGNoaWxkQ2hhbmdlVHJlZSwgXykgPT4ge1xuICAgICAgICAgICAgICAgIGNoYW5nZVRyZWUucm9vdD8ucmVtb3ZlKGNoaWxkQ2hhbmdlVHJlZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGNsZWFyIHByZXZpb3VzIGluZGV4ZXNcbiAgICAgICAgICAgIHRoaXMuJGluZGV4ZXMuY2xlYXIoKTtcbiAgICAgICAgICAgIC8vIGNsZWFyIGl0ZW1zXG4gICAgICAgICAgICB0aGlzLiRpdGVtcy5jbGVhcigpO1xuICAgICAgICAgICAgY2hhbmdlVHJlZS5vcGVyYXRpb24oZXhwb3J0cy5PUEVSQVRJT04uQ0xFQVIpO1xuICAgICAgICB9XG4gICAgICAgIGhhcyh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4kaXRlbXMudmFsdWVzKCkpLnNvbWUoKHYpID0+IHYgPT09IHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3JFYWNoKGNhbGxiYWNrZm4pIHtcbiAgICAgICAgICAgIHRoaXMuJGl0ZW1zLmZvckVhY2goKHZhbHVlLCBrZXksIF8pID0+IGNhbGxiYWNrZm4odmFsdWUsIGtleSwgdGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy52YWx1ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy5zaXplO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBJdGVyYXRvciAqL1xuICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy52YWx1ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRJbmRleChpbmRleCwga2V5KSB7XG4gICAgICAgICAgICB0aGlzLiRpbmRleGVzLnNldChpbmRleCwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBnZXRJbmRleChpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGluZGV4ZXMuZ2V0KGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBbJGdldEJ5SW5kZXhdKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuZ2V0KHRoaXMuJGluZGV4ZXMuZ2V0KGluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgWyRkZWxldGVCeUluZGV4XShpbmRleCkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy4kaW5kZXhlcy5nZXQoaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy4kaXRlbXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB0aGlzLiRpbmRleGVzLmRlbGV0ZShpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgWyRvbkVuY29kZUVuZF0oKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZWRJdGVtcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRvQXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiRpdGVtcy52YWx1ZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9KU09OKCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgICAgICB0aGlzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCgodHlwZW9mICh2YWx1ZVsndG9KU09OJ10pID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgICAgID8gdmFsdWVbJ3RvSlNPTiddKClcbiAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRGVjb2RpbmcgdXRpbGl0aWVzXG4gICAgICAgIC8vXG4gICAgICAgIGNsb25lKGlzRGVjb2RpbmcpIHtcbiAgICAgICAgICAgIGxldCBjbG9uZWQ7XG4gICAgICAgICAgICBpZiAoaXNEZWNvZGluZykge1xuICAgICAgICAgICAgICAgIC8vIGNsaWVudC1zaWRlXG4gICAgICAgICAgICAgICAgY2xvbmVkID0gT2JqZWN0LmFzc2lnbihuZXcgQ29sbGVjdGlvblNjaGVtYSgpLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNlcnZlci1zaWRlXG4gICAgICAgICAgICAgICAgY2xvbmVkID0gbmV3IENvbGxlY3Rpb25TY2hlbWEoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVskY2hhbmdlc10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZC5hZGQodmFsdWVbJ2Nsb25lJ10oKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWQuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWdpc3RlclR5cGUoXCJjb2xsZWN0aW9uXCIsIHsgY29uc3RydWN0b3I6IENvbGxlY3Rpb25TY2hlbWEsIH0pO1xuXG4gICAgdmFyIF9hJDEsIF9iJDE7XG4gICAgY2xhc3MgU2V0U2NoZW1hIHtcbiAgICAgICAgc3RhdGljIHsgdGhpc1tfYSQxXSA9IGVuY29kZUtleVZhbHVlT3BlcmF0aW9uOyB9XG4gICAgICAgIHN0YXRpYyB7IHRoaXNbX2IkMV0gPSBkZWNvZGVLZXlWYWx1ZU9wZXJhdGlvbjsgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lIGlmIGEgcHJvcGVydHkgbXVzdCBiZSBmaWx0ZXJlZC5cbiAgICAgICAgICogLSBJZiByZXR1cm5zIGZhbHNlLCB0aGUgcHJvcGVydHkgaXMgTk9UIGdvaW5nIHRvIGJlIGVuY29kZWQuXG4gICAgICAgICAqIC0gSWYgcmV0dXJucyB0cnVlLCB0aGUgcHJvcGVydHkgaXMgZ29pbmcgdG8gYmUgZW5jb2RlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogRW5jb2Rpbmcgd2l0aCBcImZpbHRlcnNcIiBoYXBwZW5zIGluIHR3byBzdGVwczpcbiAgICAgICAgICogLSBGaXJzdCwgdGhlIGVuY29kZXIgaXRlcmF0ZXMgb3ZlciBhbGwgXCJub3Qgb3duZWRcIiBwcm9wZXJ0aWVzIGFuZCBlbmNvZGVzIHRoZW0uXG4gICAgICAgICAqIC0gVGhlbiwgdGhlIGVuY29kZXIgaXRlcmF0ZXMgb3ZlciBhbGwgXCJvd25lZFwiIHByb3BlcnRpZXMgcGVyIGluc3RhbmNlIGFuZCBlbmNvZGVzIHRoZW0uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgWyhfYSQxID0gJGVuY29kZXIsIF9iJDEgPSAkZGVjb2RlciwgJGZpbHRlcildKHJlZiwgaW5kZXgsIHZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiAoIXZpZXcgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgKHJlZlskY2hpbGRUeXBlXSkgPT09IFwic3RyaW5nXCIgfHxcbiAgICAgICAgICAgICAgICB2aWV3LnZpc2libGUuaGFzKChyZWZbJGdldEJ5SW5kZXhdKGluZGV4KSA/PyByZWYuZGVsZXRlZEl0ZW1zW2luZGV4XSlbJGNoYW5nZXNdKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGlzKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlWydzZXQnXSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0cnVjdG9yKGluaXRpYWxWYWx1ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuJGl0ZW1zID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy4kaW5kZXhlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlZEl0ZW1zID0ge307XG4gICAgICAgICAgICB0aGlzLiRyZWZJZCA9IDA7XG4gICAgICAgICAgICB0aGlzWyRjaGFuZ2VzXSA9IG5ldyBDaGFuZ2VUcmVlKHRoaXMpO1xuICAgICAgICAgICAgdGhpc1skY2hhbmdlc10uaW5kZXhlcyA9IHt9O1xuICAgICAgICAgICAgaWYgKGluaXRpYWxWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsVmFsdWVzLmZvckVhY2goKHYpID0+IHRoaXMuYWRkKHYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAkY2hpbGRUeXBlLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhZGQodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGltbWVkaWF0ZWxseSByZXR1cm4gZmFsc2UgaWYgdmFsdWUgYWxyZWFkeSBhZGRlZC5cbiAgICAgICAgICAgIGlmICh0aGlzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgXCJpbmRleFwiIGZvciByZWZlcmVuY2UuXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuJHJlZklkKys7XG4gICAgICAgICAgICBpZiAoKHZhbHVlWyRjaGFuZ2VzXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlWyRjaGFuZ2VzXS5zZXRQYXJlbnQodGhpcywgdGhpc1skY2hhbmdlc10ucm9vdCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpc1skY2hhbmdlc10uaW5kZXhlc1tpbmRleF0/Lm9wID8/IGV4cG9ydHMuT1BFUkFUSU9OLkFERDtcbiAgICAgICAgICAgIHRoaXNbJGNoYW5nZXNdLmluZGV4ZXNbaW5kZXhdID0gaW5kZXg7XG4gICAgICAgICAgICB0aGlzLiRpbmRleGVzLnNldChpbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy4kaXRlbXMuc2V0KGluZGV4LCB2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzWyRjaGFuZ2VzXS5jaGFuZ2UoaW5kZXgsIG9wZXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZW50cmllcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy5lbnRyaWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlKGl0ZW0pIHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSB0aGlzLiRpdGVtcy5lbnRyaWVzKCk7XG4gICAgICAgICAgICBsZXQgaW5kZXg7XG4gICAgICAgICAgICBsZXQgZW50cnk7XG4gICAgICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyaWVzLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXRlbSA9PT0gZW50cnkudmFsdWVbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBlbnRyeS52YWx1ZVswXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZWRJdGVtc1tpbmRleF0gPSB0aGlzWyRjaGFuZ2VzXS5kZWxldGUoaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5kZWxldGUoaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmRlbGV0ZShpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXIoKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VUcmVlID0gdGhpc1skY2hhbmdlc107XG4gICAgICAgICAgICAvLyBkaXNjYXJkIHByZXZpb3VzIG9wZXJhdGlvbnMuXG4gICAgICAgICAgICBjaGFuZ2VUcmVlLmRpc2NhcmQodHJ1ZSk7XG4gICAgICAgICAgICBjaGFuZ2VUcmVlLmluZGV4ZXMgPSB7fTtcbiAgICAgICAgICAgIC8vIGNsZWFyIHByZXZpb3VzIGluZGV4ZXNcbiAgICAgICAgICAgIHRoaXMuJGluZGV4ZXMuY2xlYXIoKTtcbiAgICAgICAgICAgIC8vIGNsZWFyIGl0ZW1zXG4gICAgICAgICAgICB0aGlzLiRpdGVtcy5jbGVhcigpO1xuICAgICAgICAgICAgY2hhbmdlVHJlZS5vcGVyYXRpb24oZXhwb3J0cy5PUEVSQVRJT04uQ0xFQVIpO1xuICAgICAgICB9XG4gICAgICAgIGhhcyh2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy4kaXRlbXMudmFsdWVzKCk7XG4gICAgICAgICAgICBsZXQgaGFzID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgZW50cnk7XG4gICAgICAgICAgICB3aGlsZSAoZW50cnkgPSB2YWx1ZXMubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZW50cnkudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhcztcbiAgICAgICAgfVxuICAgICAgICBmb3JFYWNoKGNhbGxiYWNrZm4pIHtcbiAgICAgICAgICAgIHRoaXMuJGl0ZW1zLmZvckVhY2goKHZhbHVlLCBrZXksIF8pID0+IGNhbGxiYWNrZm4odmFsdWUsIGtleSwgdGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy52YWx1ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy5zaXplO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBJdGVyYXRvciAqL1xuICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy52YWx1ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRJbmRleChpbmRleCwga2V5KSB7XG4gICAgICAgICAgICB0aGlzLiRpbmRleGVzLnNldChpbmRleCwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBnZXRJbmRleChpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGluZGV4ZXMuZ2V0KGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBbJGdldEJ5SW5kZXhdKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuZ2V0KHRoaXMuJGluZGV4ZXMuZ2V0KGluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgWyRkZWxldGVCeUluZGV4XShpbmRleCkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy4kaW5kZXhlcy5nZXQoaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy4kaXRlbXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB0aGlzLiRpbmRleGVzLmRlbGV0ZShpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgWyRvbkVuY29kZUVuZF0oKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZWRJdGVtcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRvQXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiRpdGVtcy52YWx1ZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9KU09OKCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgICAgICB0aGlzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCgodHlwZW9mICh2YWx1ZVsndG9KU09OJ10pID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgICAgID8gdmFsdWVbJ3RvSlNPTiddKClcbiAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRGVjb2RpbmcgdXRpbGl0aWVzXG4gICAgICAgIC8vXG4gICAgICAgIGNsb25lKGlzRGVjb2RpbmcpIHtcbiAgICAgICAgICAgIGxldCBjbG9uZWQ7XG4gICAgICAgICAgICBpZiAoaXNEZWNvZGluZykge1xuICAgICAgICAgICAgICAgIC8vIGNsaWVudC1zaWRlXG4gICAgICAgICAgICAgICAgY2xvbmVkID0gT2JqZWN0LmFzc2lnbihuZXcgU2V0U2NoZW1hKCksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc2VydmVyLXNpZGVcbiAgICAgICAgICAgICAgICBjbG9uZWQgPSBuZXcgU2V0U2NoZW1hKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVbJGNoYW5nZXNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWQuYWRkKHZhbHVlWydjbG9uZSddKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJUeXBlKFwic2V0XCIsIHsgY29uc3RydWN0b3I6IFNldFNjaGVtYSB9KTtcblxuICAgIGNvbnN0IERFRkFVTFRfVklFV19UQUcgPSAtMTtcbiAgICBmdW5jdGlvbiBlbnRpdHkoY29uc3RydWN0b3IpIHtcbiAgICAgICAgVHlwZUNvbnRleHQucmVnaXN0ZXIoY29uc3RydWN0b3IpO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFtTZWUgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLmNvbHlzZXVzLmlvL3N0YXRlL3NjaGVtYS8pXG4gICAgICpcbiAgICAgKiBBbm5vdGF0ZSBhIFNjaGVtYSBwcm9wZXJ0eSB0byBiZSBzZXJpYWxpemVhYmxlLlxuICAgICAqIFxcQHR5cGUoKSdkIGZpZWxkcyBhcmUgYXV0b21hdGljYWxseSBmbGFnZ2VkIGFzIFwiZGlydHlcIiBmb3IgdGhlIG5leHQgcGF0Y2guXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBTdGFuZGFyZCB1c2FnZSwgd2l0aCBhdXRvbWF0aWMgY2hhbmdlIHRyYWNraW5nLlxuICAgICAqIGBgYFxuICAgICAqIFxcQHR5cGUoXCJzdHJpbmdcIikgcHJvcGVydHlOYW1lOiBzdHJpbmc7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBZb3UgY2FuIHByb3ZpZGUgdGhlIFwibWFudWFsXCIgb3B0aW9uIGlmIHlvdSdkIGxpa2UgdG8gbWFudWFsbHkgY29udHJvbCB5b3VyIHBhdGNoZXMgdmlhIC5zZXREaXJ0eSgpLlxuICAgICAqIGBgYFxuICAgICAqIFxcQHR5cGUoXCJzdHJpbmdcIiwgeyBtYW51YWw6IHRydWUgfSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICAvLyBleHBvcnQgZnVuY3Rpb24gdHlwZSh0eXBlOiBEZWZpbml0aW9uVHlwZSwgb3B0aW9ucz86IFR5cGVPcHRpb25zKSB7XG4gICAgLy8gICAgIHJldHVybiBmdW5jdGlvbiAoeyBnZXQsIHNldCB9LCBjb250ZXh0OiBDbGFzc0FjY2Vzc29yRGVjb3JhdG9yQ29udGV4dCk6IENsYXNzQWNjZXNzb3JEZWNvcmF0b3JSZXN1bHQ8U2NoZW1hLCBhbnk+IHtcbiAgICAvLyAgICAgICAgIGlmIChjb250ZXh0LmtpbmQgIT09IFwiYWNjZXNzb3JcIikge1xuICAgIC8vICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkB0eXBlKCkgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzIGFjY2Vzc29yIHByb3BlcnRpZXNcIik7XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgICAgICBjb25zdCBmaWVsZCA9IGNvbnRleHQubmFtZS50b1N0cmluZygpO1xuICAgIC8vICAgICAgICAgLy9cbiAgICAvLyAgICAgICAgIC8vIGRldGVjdCBpbmRleCBmb3IgdGhpcyBmaWVsZCwgY29uc2lkZXJpbmcgaW5oZXJpdGFuY2VcbiAgICAvLyAgICAgICAgIC8vXG4gICAgLy8gICAgICAgICBjb25zdCBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29udGV4dC5tZXRhZGF0YSk7XG4gICAgLy8gICAgICAgICBsZXQgZmllbGRJbmRleDogbnVtYmVyID0gY29udGV4dC5tZXRhZGF0YVskbnVtRmllbGRzXSAvLyBjdXJyZW50IHN0cnVjdHVyZSBhbHJlYWR5IGhhcyBmaWVsZHMgZGVmaW5lZFxuICAgIC8vICAgICAgICAgICAgID8/IChwYXJlbnQgJiYgcGFyZW50WyRudW1GaWVsZHNdKSAvLyBwYXJlbnQgc3RydWN0dXJlIGhhcyBmaWVsZHMgZGVmaW5lZFxuICAgIC8vICAgICAgICAgICAgID8/IC0xOyAvLyBubyBmaWVsZHMgZGVmaW5lZFxuICAgIC8vICAgICAgICAgZmllbGRJbmRleCsrO1xuICAgIC8vICAgICAgICAgaWYgKFxuICAgIC8vICAgICAgICAgICAgICFwYXJlbnQgJiYgLy8gdGhlIHBhcmVudCBhbHJlYWR5IGluaXRpYWxpemVzIHRoZSBgJGNoYW5nZXNgIHByb3BlcnR5XG4gICAgLy8gICAgICAgICAgICAgIU1ldGFkYXRhLmhhc0ZpZWxkcyhjb250ZXh0Lm1ldGFkYXRhKVxuICAgIC8vICAgICAgICAgKSB7XG4gICAgLy8gICAgICAgICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplcihmdW5jdGlvbiAodGhpczogUmVmKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAkY2hhbmdlcywge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBDaGFuZ2VUcmVlKHRoaXMpLFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIC8vICAgICAgICAgICAgICAgICB9KTtcbiAgICAvLyAgICAgICAgICAgICB9KTtcbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgICAgIE1ldGFkYXRhLmFkZEZpZWxkKGNvbnRleHQubWV0YWRhdGEsIGZpZWxkSW5kZXgsIGZpZWxkLCB0eXBlKTtcbiAgICAvLyAgICAgICAgIGNvbnN0IGlzQXJyYXkgPSBBcnJheVNjaGVtYS5pcyh0eXBlKTtcbiAgICAvLyAgICAgICAgIGNvbnN0IGlzTWFwID0gIWlzQXJyYXkgJiYgTWFwU2NoZW1hLmlzKHR5cGUpO1xuICAgIC8vICAgICAgICAgLy8gaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5tYW51YWwpIHtcbiAgICAvLyAgICAgICAgIC8vICAgICAvLyBkbyBub3QgZGVjbGFyZSBnZXR0ZXIvc2V0dGVyIGRlc2NyaXB0b3JcbiAgICAvLyAgICAgICAgIC8vICAgICBkZWZpbml0aW9uLmRlc2NyaXB0b3JzW2ZpZWxkXSA9IHtcbiAgICAvLyAgICAgICAgIC8vICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAvLyAgICAgICAgIC8vICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIC8vICAgICAgICAgLy8gICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAvLyAgICAgICAgIC8vICAgICB9O1xuICAgIC8vICAgICAgICAgLy8gICAgIHJldHVybjtcbiAgICAvLyAgICAgICAgIC8vIH1cbiAgICAvLyAgICAgICAgIHJldHVybiB7XG4gICAgLy8gICAgICAgICAgICAgaW5pdCh2YWx1ZSkge1xuICAgIC8vICAgICAgICAgICAgICAgICAvLyBUT0RPOiBtYXkgbmVlZCB0byBjb252ZXJ0IEFycmF5U2NoZW1hL01hcFNjaGVtYSBoZXJlXG4gICAgLy8gICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBmbGFnIGNoYW5nZSBpZiB2YWx1ZSBpcyB1bmRlZmluZWQuXG4gICAgLy8gICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICB0aGlzWyRjaGFuZ2VzXS5jaGFuZ2UoZmllbGRJbmRleCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx0eSB0cmFuc2Zvcm0gQXJyYXkgaW50byBBcnJheVNjaGVtYVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5U2NoZW1hKSkge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBBcnJheVNjaGVtYSguLi52YWx1ZSk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlWyRjaGlsZFR5cGVdID0gT2JqZWN0LnZhbHVlcyh0eXBlKVswXTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHR5IHRyYW5zZm9ybSBNYXAgaW50byBNYXBTY2hlbWFcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGlmIChpc01hcCkge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgTWFwU2NoZW1hKSkge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBNYXBTY2hlbWEodmFsdWUpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVskY2hpbGRUeXBlXSA9IE9iamVjdC52YWx1ZXModHlwZSlbMF07XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdG8gdHVybiBwcm92aWRlZCBzdHJ1Y3R1cmUgaW50byBhIFByb3h5XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVbJyRwcm94eSddID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXApIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnZXRNYXBQcm94eSh2YWx1ZSk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAvLyAgICAgICAgICAgICB9LFxuICAgIC8vICAgICAgICAgICAgIGdldCgpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgcmV0dXJuIGdldC5jYWxsKHRoaXMpO1xuICAgIC8vICAgICAgICAgICAgIH0sXG4gICAgLy8gICAgICAgICAgICAgc2V0KHZhbHVlOiBhbnkpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgLyoqXG4gICAgLy8gICAgICAgICAgICAgICAgICAqIENyZWF0ZSBQcm94eSBmb3IgYXJyYXkgb3IgbWFwIGl0ZW1zXG4gICAgLy8gICAgICAgICAgICAgICAgICAqL1xuICAgIC8vICAgICAgICAgICAgICAgICAvLyBza2lwIGlmIHZhbHVlIGlzIHRoZSBzYW1lIGFzIGNhY2hlZC5cbiAgICAvLyAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBnZXQuY2FsbCh0aGlzKSkge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgIC8vICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgICAgIGlmIChcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIHZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIHZhbHVlICE9PSBudWxsXG4gICAgLy8gICAgICAgICAgICAgICAgICkge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxsdHkgdHJhbnNmb3JtIEFycmF5IGludG8gQXJyYXlTY2hlbWFcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBcnJheVNjaGVtYSkpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQXJyYXlTY2hlbWEoLi4udmFsdWUpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVskY2hpbGRUeXBlXSA9IE9iamVjdC52YWx1ZXModHlwZSlbMF07XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx0eSB0cmFuc2Zvcm0gTWFwIGludG8gTWFwU2NoZW1hXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXApIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIE1hcFNjaGVtYSkpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgTWFwU2NoZW1hKHZhbHVlKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbJGNoaWxkVHlwZV0gPSBPYmplY3QudmFsdWVzKHR5cGUpWzBdO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRvIHR1cm4gcHJvdmlkZWQgc3RydWN0dXJlIGludG8gYSBQcm94eVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlWyckcHJveHknXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWFwKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0TWFwUHJveHkodmFsdWUpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIC8vIGZsYWcgdGhlIGNoYW5nZSBmb3IgZW5jb2RpbmcuXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICB0aGlzWyRjaGFuZ2VzXS5jaGFuZ2UoZmllbGRJbmRleCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAvL1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCBzZXRQYXJlbnQoKSByZWN1cnNpdmVseSBmb3IgdGhpcyBhbmQgaXRzIGNoaWxkXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAvLyBzdHJ1Y3R1cmVzLlxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVskY2hhbmdlc10pIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVskY2hhbmdlc10uc2V0UGFyZW50KFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzWyRjaGFuZ2VzXS5yb290LFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXRhZGF0YS5nZXRJbmRleChjb250ZXh0Lm1ldGFkYXRhLCBmaWVsZCksXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChnZXQuY2FsbCh0aGlzKSkge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIC8vIFNldHRpbmcgYSBmaWVsZCB0byBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgd2lsbCBkZWxldGUgaXQuXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAvL1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgdGhpc1skY2hhbmdlc10uZGVsZXRlKGZpZWxkKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICBzZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgLy8gICAgICAgICAgICAgfSxcbiAgICAvLyAgICAgICAgIH07XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG4gICAgZnVuY3Rpb24gdmlldyh0YWcgPSBERUZBVUxUX1ZJRVdfVEFHKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50Q2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50TWV0YWRhdGEgPSBwYXJlbnRDbGFzc1tTeW1ib2wubWV0YWRhdGFdO1xuICAgICAgICAgICAgLy8gVE9ETzogdXNlIE1ldGFkYXRhLmluaXRpYWxpemUoKVxuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSAoY29uc3RydWN0b3JbU3ltYm9sLm1ldGFkYXRhXSA/Pz0gT2JqZWN0LmFzc2lnbih7fSwgY29uc3RydWN0b3JbU3ltYm9sLm1ldGFkYXRhXSwgcGFyZW50TWV0YWRhdGEgPz8gT2JqZWN0LmNyZWF0ZShudWxsKSkpO1xuICAgICAgICAgICAgLy8gY29uc3QgZmllbGRJbmRleCA9IG1ldGFkYXRhW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICAvLyBpZiAoIW1ldGFkYXRhW2ZpZWxkSW5kZXhdKSB7XG4gICAgICAgICAgICAvLyAgICAgLy9cbiAgICAgICAgICAgIC8vICAgICAvLyBkZXRlY3QgaW5kZXggZm9yIHRoaXMgZmllbGQsIGNvbnNpZGVyaW5nIGluaGVyaXRhbmNlXG4gICAgICAgICAgICAvLyAgICAgLy9cbiAgICAgICAgICAgIC8vICAgICBtZXRhZGF0YVtmaWVsZEluZGV4XSA9IHtcbiAgICAgICAgICAgIC8vICAgICAgICAgdHlwZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gICAgICAgICBpbmRleDogKG1ldGFkYXRhWyRudW1GaWVsZHNdIC8vIGN1cnJlbnQgc3RydWN0dXJlIGFscmVhZHkgaGFzIGZpZWxkcyBkZWZpbmVkXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICA/PyAocGFyZW50TWV0YWRhdGEgJiYgcGFyZW50TWV0YWRhdGFbJG51bUZpZWxkc10pIC8vIHBhcmVudCBzdHJ1Y3R1cmUgaGFzIGZpZWxkcyBkZWZpbmVkXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICA/PyAtMSkgKyAxIC8vIG5vIGZpZWxkcyBkZWZpbmVkXG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgTWV0YWRhdGEuc2V0VGFnKG1ldGFkYXRhLCBmaWVsZE5hbWUsIHRhZyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHR5cGUodHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgZmllbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnN0cnVjdG9yLm5hbWV9OiBAdHlwZSgpIHJlZmVyZW5jZSBwcm92aWRlZCBmb3IgXCIke2ZpZWxkfVwiIGlzIHVuZGVmaW5lZC4gTWFrZSBzdXJlIHlvdSBkb24ndCBoYXZlIGFueSBjaXJjdWxhciBkZXBlbmRlbmNpZXMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdHlwZSAoZW51bS9jb2xsZWN0aW9uL2V0YylcbiAgICAgICAgICAgIHR5cGUgPSBnZXROb3JtYWxpemVkVHlwZSh0eXBlKTtcbiAgICAgICAgICAgIC8vIGZvciBpbmhlcml0YW5jZSBzdXBwb3J0XG4gICAgICAgICAgICBUeXBlQ29udGV4dC5yZWdpc3Rlcihjb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRDbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRNZXRhZGF0YSA9IHBhcmVudENsYXNzW1N5bWJvbC5tZXRhZGF0YV07XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IE1ldGFkYXRhLmluaXRpYWxpemUoY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgbGV0IGZpZWxkSW5kZXggPSBtZXRhZGF0YVtmaWVsZF07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHNraXAgaWYgZGVzY3JpcHRvciBhbHJlYWR5IGV4aXN0cyBmb3IgdGhpcyBmaWVsZCAoYEBkZXByZWNhdGVkKClgKVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAobWV0YWRhdGFbZmllbGRJbmRleF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YVtmaWVsZEluZGV4XS5kZXByZWNhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBjcmVhdGUgYWNjZXNzb3JzIGZvciBkZXByZWNhdGVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWV0YWRhdGFbZmllbGRJbmRleF0udHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeWluZyB0byBkZWZpbmUgc2FtZSBwcm9wZXJ0eSBtdWx0aXBsZSB0aW1lcyBhY3Jvc3MgaW5oZXJpdGFuY2UuXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2x5c2V1cy9jb2x5c2V1cy11bml0eTNkL2lzc3Vlcy8xMzEjaXNzdWVjb21tZW50LTgxNDMwODU3MlxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAY29seXNldXMvc2NoZW1hOiBEdXBsaWNhdGUgJyR7ZmllbGR9JyBkZWZpbml0aW9uIG9uICcke2NvbnN0cnVjdG9yLm5hbWV9Jy5cXG5DaGVjayBAdHlwZSgpIGFubm90YXRpb25gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmaW5pdGlvbkF0TGluZSA9IGUuc3RhY2suc3BsaXQoXCJcXG5cIilbNF0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2UubWVzc2FnZX0gJHtkZWZpbml0aW9uQXRMaW5lfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBkZXRlY3QgaW5kZXggZm9yIHRoaXMgZmllbGQsIGNvbnNpZGVyaW5nIGluaGVyaXRhbmNlXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBmaWVsZEluZGV4ID0gbWV0YWRhdGFbJG51bUZpZWxkc10gLy8gY3VycmVudCBzdHJ1Y3R1cmUgYWxyZWFkeSBoYXMgZmllbGRzIGRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPz8gKHBhcmVudE1ldGFkYXRhICYmIHBhcmVudE1ldGFkYXRhWyRudW1GaWVsZHNdKSAvLyBwYXJlbnQgc3RydWN0dXJlIGhhcyBmaWVsZHMgZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/PyAtMTsgLy8gbm8gZmllbGRzIGRlZmluZWRcbiAgICAgICAgICAgICAgICBmaWVsZEluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm1hbnVhbCkge1xuICAgICAgICAgICAgICAgIE1ldGFkYXRhLmFkZEZpZWxkKG1ldGFkYXRhLCBmaWVsZEluZGV4LCBmaWVsZCwgdHlwZSwge1xuICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3QgZGVjbGFyZSBnZXR0ZXIvc2V0dGVyIGRlc2NyaXB0b3JcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXhUeXBlS2xhc3MgPSB0eXBlb2YgKE9iamVjdC5rZXlzKHR5cGUpWzBdKSA9PT0gXCJzdHJpbmdcIiAmJiBnZXRUeXBlKE9iamVjdC5rZXlzKHR5cGUpWzBdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSAoY29tcGxleFR5cGVLbGFzcylcbiAgICAgICAgICAgICAgICAgICAgPyBPYmplY3QudmFsdWVzKHR5cGUpWzBdXG4gICAgICAgICAgICAgICAgICAgIDogdHlwZTtcbiAgICAgICAgICAgICAgICBNZXRhZGF0YS5hZGRGaWVsZChtZXRhZGF0YSwgZmllbGRJbmRleCwgZmllbGQsIHR5cGUsIGdldFByb3BlcnR5RGVzY3JpcHRvcihgXyR7ZmllbGR9YCwgZmllbGRJbmRleCwgY2hpbGRUeXBlLCBjb21wbGV4VHlwZUtsYXNzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFByb3BlcnR5RGVzY3JpcHRvcihmaWVsZENhY2hlZCwgZmllbGRJbmRleCwgdHlwZSwgY29tcGxleFR5cGVLbGFzcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW2ZpZWxkQ2FjaGVkXTsgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHRoaXNbZmllbGRDYWNoZWRdID8/IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAvLyBza2lwIGlmIHZhbHVlIGlzIHRoZSBzYW1lIGFzIGNhY2hlZC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxleFR5cGVLbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxsdHkgdHJhbnNmb3JtIEFycmF5IGludG8gQXJyYXlTY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV4VHlwZUtsYXNzLmNvbnN0cnVjdG9yID09PSBBcnJheVNjaGVtYSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlTY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQXJyYXlTY2hlbWEoLi4udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxsdHkgdHJhbnNmb3JtIE1hcCBpbnRvIE1hcFNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXhUeXBlS2xhc3MuY29uc3RydWN0b3IgPT09IE1hcFNjaGVtYSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTWFwU2NoZW1hKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IE1hcFNjaGVtYSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAvLyBhdXRvbWF0aWNhbGx0eSB0cmFuc2Zvcm0gQXJyYXkgaW50byBTZXRTY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIChjb21wbGV4VHlwZUtsYXNzLmNvbnN0cnVjdG9yID09PSBTZXRTY2hlbWEgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIFNldFNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICB2YWx1ZSA9IG5ldyBTZXRTY2hlbWEodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbJGNoaWxkVHlwZV0gPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiAodHlwZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydEluc3RhbmNlVHlwZSh2YWx1ZSwgdHlwZSwgdGhpcywgZmllbGRDYWNoZWQuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydFR5cGUodmFsdWUsIHR5cGUsIHRoaXMsIGZpZWxkQ2FjaGVkLnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IHRoaXNbJGNoYW5nZXNdO1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNpbmcgZXhpc3RpbmcgXCJyZWZcIiwgcmVtb3ZlIGl0IGZyb20gcm9vdC5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcmV2aW91c1ZhbHVlWyRjaGFuZ2VzXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlVHJlZS5yb290Py5yZW1vdmUocHJldmlvdXNWYWx1ZVskY2hhbmdlc10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3RvclskdHJhY2tdKGNoYW5nZVRyZWUsIGZpZWxkSW5kZXgsIGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURV9BTkRfQUREKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3JbJHRyYWNrXShjaGFuZ2VUcmVlLCBmaWVsZEluZGV4LCBleHBvcnRzLk9QRVJBVElPTi5BREQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgc2V0UGFyZW50KCkgcmVjdXJzaXZlbHkgZm9yIHRoaXMgYW5kIGl0cyBjaGlsZFxuICAgICAgICAgICAgICAgICAgICAvLyBzdHJ1Y3R1cmVzLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVskY2hhbmdlc10/LnNldFBhcmVudCh0aGlzLCBjaGFuZ2VUcmVlLnJvb3QsIGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmV2aW91c1ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0dGluZyBhIGZpZWxkIHRvIGBudWxsYCBvciBgdW5kZWZpbmVkYCB3aWxsIGRlbGV0ZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgdGhpc1skY2hhbmdlc10uZGVsZXRlKGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkQ2FjaGVkXSA9IHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYEBkZXByZWNhdGVkKClgIGZsYWcgYSBmaWVsZCBhcyBkZXByZWNhdGVkLlxuICAgICAqIFRoZSBwcmV2aW91cyBgQHR5cGUoKWAgYW5ub3RhdGlvbiBzaG91bGQgcmVtYWluIGFsb25nIHdpdGggdGhpcyBvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZCh0aHJvd3MgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoa2xhc3MsIGZpZWxkKSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRklYTUU6IHRoZSBmb2xsb3dpbmcgYmxvY2sgb2YgY29kZSBpcyByZXBlYXRlZCBhY3Jvc3MgYEB0eXBlKClgLCBgQGRlcHJlY2F0ZWQoKWAgYW5kIGBAdW5yZWxpYWJsZSgpYCBkZWNvcmF0b3JzLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0ga2xhc3MuY29uc3RydWN0b3I7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRDbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRNZXRhZGF0YSA9IHBhcmVudENsYXNzW1N5bWJvbC5tZXRhZGF0YV07XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IChjb25zdHJ1Y3RvcltTeW1ib2wubWV0YWRhdGFdID8/PSBPYmplY3QuYXNzaWduKHt9LCBjb25zdHJ1Y3RvcltTeW1ib2wubWV0YWRhdGFdLCBwYXJlbnRNZXRhZGF0YSA/PyBPYmplY3QuY3JlYXRlKG51bGwpKSk7XG4gICAgICAgICAgICBjb25zdCBmaWVsZEluZGV4ID0gbWV0YWRhdGFbZmllbGRdO1xuICAgICAgICAgICAgLy8gaWYgKCFtZXRhZGF0YVtmaWVsZF0pIHtcbiAgICAgICAgICAgIC8vICAgICAvL1xuICAgICAgICAgICAgLy8gICAgIC8vIGRldGVjdCBpbmRleCBmb3IgdGhpcyBmaWVsZCwgY29uc2lkZXJpbmcgaW5oZXJpdGFuY2VcbiAgICAgICAgICAgIC8vICAgICAvL1xuICAgICAgICAgICAgLy8gICAgIG1ldGFkYXRhW2ZpZWxkXSA9IHtcbiAgICAgICAgICAgIC8vICAgICAgICAgdHlwZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gICAgICAgICBpbmRleDogKG1ldGFkYXRhWyRudW1GaWVsZHNdIC8vIGN1cnJlbnQgc3RydWN0dXJlIGFscmVhZHkgaGFzIGZpZWxkcyBkZWZpbmVkXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICA/PyAocGFyZW50TWV0YWRhdGEgJiYgcGFyZW50TWV0YWRhdGFbJG51bUZpZWxkc10pIC8vIHBhcmVudCBzdHJ1Y3R1cmUgaGFzIGZpZWxkcyBkZWZpbmVkXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICA/PyAtMSkgKyAxIC8vIG5vIGZpZWxkcyBkZWZpbmVkXG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgbWV0YWRhdGFbZmllbGRJbmRleF0uZGVwcmVjYXRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhyb3dzKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGFbJGRlc2NyaXB0b3JzXSA/Pz0ge307XG4gICAgICAgICAgICAgICAgbWV0YWRhdGFbJGRlc2NyaXB0b3JzXVtmaWVsZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoYCR7ZmllbGR9IGlzIGRlcHJlY2F0ZWQuYCk7IH0sXG4gICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IH0sXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmxhZyBtZXRhZGF0YVtmaWVsZF0gYXMgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRhZGF0YSwgZmllbGRJbmRleCwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBtZXRhZGF0YVtmaWVsZEluZGV4XSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVUeXBlcyh0YXJnZXQsIGZpZWxkcywgb3B0aW9ucykge1xuICAgICAgICBmb3IgKGxldCBmaWVsZCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgIHR5cGUoZmllbGRzW2ZpZWxkXSwgb3B0aW9ucykodGFyZ2V0LnByb3RvdHlwZSwgZmllbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVtYShmaWVsZHNBbmRNZXRob2RzLCBuYW1lLCBpbmhlcml0cyA9IFNjaGVtYSkge1xuICAgICAgICBjb25zdCBmaWVsZHMgPSB7fTtcbiAgICAgICAgY29uc3QgbWV0aG9kcyA9IHt9O1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWVzID0ge307XG4gICAgICAgIGNvbnN0IHZpZXdUYWdGaWVsZHMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgZmllbGROYW1lIGluIGZpZWxkc0FuZE1ldGhvZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGRzQW5kTWV0aG9kc1tmaWVsZE5hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlWyd2aWV3J10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3VGFnRmllbGRzW2ZpZWxkTmFtZV0gPSAodHlwZW9mICh2YWx1ZVsndmlldyddKSA9PT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IERFRkFVTFRfVklFV19UQUdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWVbJ3ZpZXcnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmllbGRzW2ZpZWxkTmFtZV0gPSBnZXROb3JtYWxpemVkVHlwZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gZXhwbGljaXQgZGVmYXVsdCBwcm92aWRlZCwgaGFuZGxlIGF1dG9tYXRpYyBpbnN0YW50aWF0aW9uIGZvciBjb2xsZWN0aW9uIHR5cGVzXG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdkZWZhdWx0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIEFycmF5LmlzQXJyYXkoKSBjaGVjay4gVXNlIFsnYXJyYXknXSAhPT0gdW5kZWZpbmVkIG9ubHkuXG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZVsnYXJyYXknXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb2xsZWN0aW9uOiBBcnJheSDihpIgbmV3IEFycmF5U2NoZW1hKClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXNbZmllbGROYW1lXSA9IG5ldyBBcnJheVNjaGVtYSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlWydtYXAnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb2xsZWN0aW9uOiBNYXAg4oaSIG5ldyBNYXBTY2hlbWEoKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlc1tmaWVsZE5hbWVdID0gbmV3IE1hcFNjaGVtYSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlWydjb2xsZWN0aW9uJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29sbGVjdGlvbjogQ29sbGVjdGlvbiDihpIgbmV3IENvbGxlY3Rpb25TY2hlbWEoKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlc1tmaWVsZE5hbWVdID0gbmV3IENvbGxlY3Rpb25TY2hlbWEoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZVsnc2V0J10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29sbGVjdGlvbjogU2V0IOKGkiBuZXcgU2V0U2NoZW1hKClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXNbZmllbGROYW1lXSA9IG5ldyBTZXRTY2hlbWEoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZVsndHlwZSddICE9PSB1bmRlZmluZWQgJiYgU2NoZW1hLmlzKHZhbHVlWyd0eXBlJ10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXJlY3QgU2NoZW1hIHR5cGU6IFR5cGUg4oaSIG5ldyBUeXBlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWVbJ3R5cGUnXS5wcm90b3R5cGUuaW5pdGlhbGl6ZSB8fCB2YWx1ZVsndHlwZSddLnByb3RvdHlwZS5pbml0aWFsaXplLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgYXV0by1pbml0aWFsaXplIFNjaGVtYSBpbnN0YW5jZXMgaWY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSB0aGV5IGRvbid0IGhhdmUgYW4gaW5pdGlhbGl6ZSBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIG9yIGluaXRpYWxpemUgbWV0aG9kIGRvZXNuJ3QgYWNjZXB0IGFueSBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlc1tmaWVsZE5hbWVdID0gbmV3IHZhbHVlWyd0eXBlJ10oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlc1tmaWVsZE5hbWVdID0gdmFsdWVbJ2RlZmF1bHQnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKFNjaGVtYS5pcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGlyZWN0IFNjaGVtYSB0eXBlOiBUeXBlIOKGkiBuZXcgVHlwZSgpXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUucHJvdG90eXBlLmluaXRpYWxpemUgfHwgdmFsdWUucHJvdG90eXBlLmluaXRpYWxpemUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGF1dG8taW5pdGlhbGl6ZSBTY2hlbWEgaW5zdGFuY2VzIGlmOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSB0aGV5IGRvbid0IGhhdmUgYW4gaW5pdGlhbGl6ZSBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gb3IgaW5pdGlhbGl6ZSBtZXRob2QgZG9lc24ndCBhY2NlcHQgYW55IHBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXNbZmllbGROYW1lXSA9IG5ldyB2YWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkc1tmaWVsZE5hbWVdID0gZ2V0Tm9ybWFsaXplZFR5cGUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kc1tmaWVsZE5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmllbGRzW2ZpZWxkTmFtZV0gPSBnZXROb3JtYWxpemVkVHlwZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2V0RGVmYXVsdFZhbHVlcyA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRzID0ge307XG4gICAgICAgICAgICAvLyB1c2UgY3VycmVudCBjbGFzcyBkZWZhdWx0IHZhbHVlc1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgaW4gZGVmYXVsdFZhbHVlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZXNbZmllbGROYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdFZhbHVlICYmIHR5cGVvZiBkZWZhdWx0VmFsdWUuY2xvbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcGxleCwgY2xvbmVhYmxlIHZhbHVlcywgZS5nLiBTY2hlbWEsIEFycmF5U2NoZW1hLCBNYXBTY2hlbWEsIENvbGxlY3Rpb25TY2hlbWEsIFNldFNjaGVtYVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0c1tmaWVsZE5hbWVdID0gZGVmYXVsdFZhbHVlLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFuZCBub24tY2xvbmVhYmxlIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0c1tmaWVsZE5hbWVdID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZ2V0UGFyZW50UHJvcHMgPSAocHJvcHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBPYmplY3Qua2V5cyhmaWVsZHMpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50UHJvcHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWVsZE5hbWVzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50UHJvcHNba2V5XSA9IHByb3BzW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFByb3BzO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGNvZGVnZW4taWdub3JlICovXG4gICAgICAgIGNvbnN0IGtsYXNzID0gTWV0YWRhdGEuc2V0RmllbGRzKGNsYXNzIGV4dGVuZHMgaW5oZXJpdHMge1xuICAgICAgICAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgaW5pdGlhbGl6ZSBtZXRob2RcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kcy5pbml0aWFsaXplICYmIHR5cGVvZiBtZXRob2RzLmluaXRpYWxpemUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7fSwgZ2V0RGVmYXVsdFZhbHVlcygpLCBnZXRQYXJlbnRQcm9wcyhhcmdzWzBdIHx8IHt9KSkpO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogb25seSBjYWxsIGluaXRpYWxpemUoKSBpbiB0aGUgY3VycmVudCBjbGFzcywgbm90IHRoZSBwYXJlbnQgb25lcy5cbiAgICAgICAgICAgICAgICAgICAgICogc2VlIFwic2hvdWxkIG5vdCBjYWxsIGluaXRpYWxpemUgYXV0b21hdGljYWxseSB3aGVuIGNyZWF0aW5nIGFuIGluc3RhbmNlIG9mIGluaGVyaXRlZCBTY2hlbWFcIlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ldy50YXJnZXQgPT09IGtsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oe30sIGdldERlZmF1bHRWYWx1ZXMoKSwgYXJnc1swXSB8fCB7fSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZmllbGRzKTtcbiAgICAgICAgLy8gU3RvcmUgdGhlIGdldERlZmF1bHRWYWx1ZXMgZnVuY3Rpb24gb24gdGhlIGNsYXNzIGZvciBpbmhlcml0YW5jZVxuICAgICAgICBrbGFzcy5fZ2V0RGVmYXVsdFZhbHVlcyA9IGdldERlZmF1bHRWYWx1ZXM7XG4gICAgICAgIC8vIEFkZCBtZXRob2RzIHRvIHRoZSBwcm90b3R5cGVcbiAgICAgICAgT2JqZWN0LmFzc2lnbihrbGFzcy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgICAgICBmb3IgKGxldCBmaWVsZE5hbWUgaW4gdmlld1RhZ0ZpZWxkcykge1xuICAgICAgICAgICAgdmlldyh2aWV3VGFnRmllbGRzW2ZpZWxkTmFtZV0pKGtsYXNzLnByb3RvdHlwZSwgZmllbGROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGtsYXNzLCBcIm5hbWVcIiwgeyB2YWx1ZTogbmFtZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBrbGFzcy5leHRlbmRzID0gKGZpZWxkcywgbmFtZSkgPT4gc2NoZW1hKGZpZWxkcywgbmFtZSwga2xhc3MpO1xuICAgICAgICByZXR1cm4ga2xhc3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SW5kZW50KGxldmVsKSB7XG4gICAgICAgIHJldHVybiAobmV3IEFycmF5KGxldmVsKS5maWxsKDApKS5tYXAoKF8sIGkpID0+IChpID09PSBsZXZlbCAtIDEpID8gYOKUlOKUgCBgIDogYCAgIGApLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGR1bXBDaGFuZ2VzKHNjaGVtYSkge1xuICAgICAgICBjb25zdCAkcm9vdCA9IHNjaGVtYVskY2hhbmdlc10ucm9vdDtcbiAgICAgICAgY29uc3QgZHVtcCA9IHtcbiAgICAgICAgICAgIG9wczoge30sXG4gICAgICAgICAgICByZWZzOiBbXVxuICAgICAgICB9O1xuICAgICAgICAvLyBmb3IgKGNvbnN0IHJlZklkIGluICRyb290LmNoYW5nZXMpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSAkcm9vdC5jaGFuZ2VzLm5leHQ7XG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VUcmVlID0gY3VycmVudC5jaGFuZ2VUcmVlO1xuICAgICAgICAgICAgLy8gc2tpcCBpZiBDaGFuZ2VUcmVlIGlzIHVuZGVmaW5lZFxuICAgICAgICAgICAgaWYgKGNoYW5nZVRyZWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gY2hhbmdlVHJlZS5pbmRleGVkT3BlcmF0aW9ucztcbiAgICAgICAgICAgIGR1bXAucmVmcy5wdXNoKGByZWZJZCMke2NoYW5nZVRyZWUucmVmSWR9YCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluZGV4IGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcCA9IGNoYW5nZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wTmFtZSA9IGV4cG9ydHMuT1BFUkFUSU9OW29wXTtcbiAgICAgICAgICAgICAgICBpZiAoIWR1bXAub3BzW29wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZHVtcC5vcHNbb3BOYW1lXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGR1bXAub3BzW2V4cG9ydHMuT1BFUkFUSU9OW29wXV0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR1bXA7XG4gICAgfVxuXG4gICAgdmFyIF9hLCBfYjtcbiAgICAvKipcbiAgICAgKiBTY2hlbWEgZW5jb2RlciAvIGRlY29kZXJcbiAgICAgKi9cbiAgICBjbGFzcyBTY2hlbWEge1xuICAgICAgICBzdGF0aWMgeyB0aGlzW19hXSA9IGVuY29kZVNjaGVtYU9wZXJhdGlvbjsgfVxuICAgICAgICBzdGF0aWMgeyB0aGlzW19iXSA9IGRlY29kZVNjaGVtYU9wZXJhdGlvbjsgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXNzaWduIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9ycyByZXF1aXJlZCB0byB0cmFjayBjaGFuZ2VzIG9uIHRoaXMgaW5zdGFuY2UuXG4gICAgICAgICAqIEBwYXJhbSBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGluaXRpYWxpemUoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0YW5jZSwgJGNoYW5nZXMsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IENoYW5nZVRyZWUoaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGluc3RhbmNlLCBpbnN0YW5jZS5jb25zdHJ1Y3RvcltTeW1ib2wubWV0YWRhdGFdPy5bJGRlc2NyaXB0b3JzXSB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGlzKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgKHR5cGVbU3ltYm9sLm1ldGFkYXRhXSkgPT09IFwib2JqZWN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrIHByb3BlcnR5IGNoYW5nZXNcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBbKF9hID0gJGVuY29kZXIsIF9iID0gJGRlY29kZXIsICR0cmFjayldKGNoYW5nZVRyZWUsIGluZGV4LCBvcGVyYXRpb24gPSBleHBvcnRzLk9QRVJBVElPTi5BREQpIHtcbiAgICAgICAgICAgIGNoYW5nZVRyZWUuY2hhbmdlKGluZGV4LCBvcGVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmUgaWYgYSBwcm9wZXJ0eSBtdXN0IGJlIGZpbHRlcmVkLlxuICAgICAgICAgKiAtIElmIHJldHVybnMgZmFsc2UsIHRoZSBwcm9wZXJ0eSBpcyBOT1QgZ29pbmcgdG8gYmUgZW5jb2RlZC5cbiAgICAgICAgICogLSBJZiByZXR1cm5zIHRydWUsIHRoZSBwcm9wZXJ0eSBpcyBnb2luZyB0byBiZSBlbmNvZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBFbmNvZGluZyB3aXRoIFwiZmlsdGVyc1wiIGhhcHBlbnMgaW4gdHdvIHN0ZXBzOlxuICAgICAgICAgKiAtIEZpcnN0LCB0aGUgZW5jb2RlciBpdGVyYXRlcyBvdmVyIGFsbCBcIm5vdCBvd25lZFwiIHByb3BlcnRpZXMgYW5kIGVuY29kZXMgdGhlbS5cbiAgICAgICAgICogLSBUaGVuLCB0aGUgZW5jb2RlciBpdGVyYXRlcyBvdmVyIGFsbCBcIm93bmVkXCIgcHJvcGVydGllcyBwZXIgaW5zdGFuY2UgYW5kIGVuY29kZXMgdGhlbS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBbJGZpbHRlcl0ocmVmLCBpbmRleCwgdmlldykge1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSByZWYuY29uc3RydWN0b3JbU3ltYm9sLm1ldGFkYXRhXTtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IG1ldGFkYXRhW2luZGV4XT8udGFnO1xuICAgICAgICAgICAgaWYgKHZpZXcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIHNoYXJlZCBwYXNzL2VuY29kZTogZW5jb2RlIGlmIGRvZXNuJ3QgaGF2ZSBhIHRhZ1xuICAgICAgICAgICAgICAgIHJldHVybiB0YWcgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gdmlldyBwYXNzOiBubyB0YWdcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gREVGQVVMVF9WSUVXX1RBRykge1xuICAgICAgICAgICAgICAgIC8vIHZpZXcgcGFzczogZGVmYXVsdCB0YWdcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlldy5pc0NoYW5nZVRyZWVWaXNpYmxlKHJlZlskY2hhbmdlc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdmlldyBwYXNzOiBjdXN0b20gdGFnXG4gICAgICAgICAgICAgICAgY29uc3QgdGFncyA9IHZpZXcudGFncz8uZ2V0KHJlZlskY2hhbmdlc10pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0YWdzICYmIHRhZ3MuaGFzKHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWxsb3cgaW5oZXJpdGVkIGNsYXNzZXMgdG8gaGF2ZSBhIGNvbnN0cnVjdG9yXG4gICAgICAgIGNvbnN0cnVjdG9yKGFyZykge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGlubGluZVxuICAgICAgICAgICAgLy8gU2NoZW1hLmluaXRpYWxpemUodGhpcyk7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgU2NoZW1hLmluaXRpYWxpemUodGhpcyk7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQXNzaWduIGluaXRpYWwgdmFsdWVzXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NpZ24ocHJvcHMpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIChTZXJ2ZXItc2lkZSk6IEZsYWcgYSBwcm9wZXJ0eSB0byBiZSBlbmNvZGVkIGZvciB0aGUgbmV4dCBwYXRjaC5cbiAgICAgICAgICogQHBhcmFtIGluc3RhbmNlIFNjaGVtYSBpbnN0YW5jZVxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHkgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcHJvcGVydHkgbmFtZSwgb3IgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgaW5kZXggb2YgdGhlIHByb3BlcnR5LlxuICAgICAgICAgKiBAcGFyYW0gb3BlcmF0aW9uIE9QRVJBVElPTiB0byBwZXJmb3JtIChkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RGlydHkocHJvcGVydHksIG9wZXJhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLmNvbnN0cnVjdG9yW1N5bWJvbC5tZXRhZGF0YV07XG4gICAgICAgICAgICB0aGlzWyRjaGFuZ2VzXS5jaGFuZ2UobWV0YWRhdGFbbWV0YWRhdGFbcHJvcGVydHldXS5pbmRleCwgb3BlcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjbG9uZSgpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY3VzdG9tIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICBjb25zdCBjbG9uZWQgPSBPYmplY3QuY3JlYXRlKHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAgICAgICAgIFNjaGVtYS5pbml0aWFsaXplKGNsb25lZCk7XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuY29uc3RydWN0b3JbU3ltYm9sLm1ldGFkYXRhXTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUT0RPOiBjbG9uZSBhbGwgcHJvcGVydGllcywgbm90IG9ubHkgYW5ub3RhdGVkIG9uZXNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBmb3IgKGNvbnN0IGZpZWxkIGluIHRoaXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGRJbmRleCBpbiBtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gbWV0YWRhdGFbZmllbGRJbmRleF0ubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh0aGlzW2ZpZWxkXSkgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mICh0aGlzW2ZpZWxkXT8uY2xvbmUpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVlcCBjbG9uZVxuICAgICAgICAgICAgICAgICAgICBjbG9uZWRbZmllbGRdID0gdGhpc1tmaWVsZF0uY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkW2ZpZWxkXSA9IHRoaXNbZmllbGRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdG9KU09OKCkge1xuICAgICAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuY29uc3RydWN0b3JbU3ltYm9sLm1ldGFkYXRhXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggaW4gbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IG1ldGFkYXRhW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuICAgICAgICAgICAgICAgIGlmICghZmllbGQuZGVwcmVjYXRlZCAmJiB0aGlzW2ZpZWxkTmFtZV0gIT09IG51bGwgJiYgdHlwZW9mICh0aGlzW2ZpZWxkTmFtZV0pICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtmaWVsZE5hbWVdID0gKHR5cGVvZiAodGhpc1tmaWVsZE5hbWVdWyd0b0pTT04nXSkgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpc1tmaWVsZE5hbWVdWyd0b0pTT04nXSgpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXNbZmllbGROYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIGluIHRlc3RzIG9ubHlcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBkaXNjYXJkQWxsQ2hhbmdlcygpIHtcbiAgICAgICAgICAgIHRoaXNbJGNoYW5nZXNdLmRpc2NhcmRBbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBbJGdldEJ5SW5kZXhdKGluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuY29uc3RydWN0b3JbU3ltYm9sLm1ldGFkYXRhXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW21ldGFkYXRhW2luZGV4XS5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBbJGRlbGV0ZUJ5SW5kZXhdKGluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuY29uc3RydWN0b3JbU3ltYm9sLm1ldGFkYXRhXTtcbiAgICAgICAgICAgIHRoaXNbbWV0YWRhdGFbaW5kZXhdLm5hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNwZWN0IHRoZSBgcmVmSWRgIG9mIGFsbCBTY2hlbWEgaW5zdGFuY2VzIGluIHRoZSB0cmVlLiBPcHRpb25hbGx5IGRpc3BsYXkgdGhlIGNvbnRlbnRzIG9mIHRoZSBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJlZiBTY2hlbWEgaW5zdGFuY2VcbiAgICAgICAgICogQHBhcmFtIHNob3dDb250ZW50cyBkaXNwbGF5IEpTT04gY29udGVudHMgb2YgdGhlIGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVidWdSZWZJZHMocmVmLCBzaG93Q29udGVudHMgPSBmYWxzZSwgbGV2ZWwgPSAwLCBkZWNvZGVyLCBrZXlQcmVmaXggPSBcIlwiKSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IChzaG93Q29udGVudHMpID8gYCAtICR7SlNPTi5zdHJpbmdpZnkocmVmLnRvSlNPTigpKX1gIDogXCJcIjtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZVRyZWUgPSByZWZbJGNoYW5nZXNdO1xuICAgICAgICAgICAgY29uc3QgcmVmSWQgPSAoZGVjb2RlcikgPyBkZWNvZGVyLnJvb3QucmVmSWRzLmdldChyZWYpIDogY2hhbmdlVHJlZS5yZWZJZDtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSAoZGVjb2RlcikgPyBkZWNvZGVyLnJvb3QgOiBjaGFuZ2VUcmVlLnJvb3Q7XG4gICAgICAgICAgICAvLyBsb2cgcmVmZXJlbmNlIGNvdW50IGlmID4gMVxuICAgICAgICAgICAgY29uc3QgcmVmQ291bnQgPSAocm9vdD8ucmVmQ291bnQ/LltyZWZJZF0gPiAxKVxuICAgICAgICAgICAgICAgID8gYCBbw5cke3Jvb3QucmVmQ291bnRbcmVmSWRdfV1gXG4gICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgIGxldCBvdXRwdXQgPSBgJHtnZXRJbmRlbnQobGV2ZWwpfSR7a2V5UHJlZml4fSR7cmVmLmNvbnN0cnVjdG9yLm5hbWV9IChyZWZJZDogJHtyZWZJZH0pJHtyZWZDb3VudH0ke2NvbnRlbnRzfVxcbmA7XG4gICAgICAgICAgICBjaGFuZ2VUcmVlLmZvckVhY2hDaGlsZCgoY2hpbGRDaGFuZ2VUcmVlLCBpbmRleE9yS2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IGluZGV4T3JLZXk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleE9yS2V5ID09PSAnbnVtYmVyJyAmJiByZWZbJyRpbmRleGVzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFwU2NoZW1hXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHJlZlsnJGluZGV4ZXMnXS5nZXQoaW5kZXhPcktleSkgPz8gaW5kZXhPcktleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5UHJlZml4ID0gKHJlZlsnZm9yRWFjaCddICE9PSB1bmRlZmluZWQgJiYga2V5ICE9PSB1bmRlZmluZWQpID8gYFtcIiR7a2V5fVwiXTogYCA6IFwiXCI7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IHRoaXMuZGVidWdSZWZJZHMoY2hpbGRDaGFuZ2VUcmVlLnJlZiwgc2hvd0NvbnRlbnRzLCBsZXZlbCArIDEsIGRlY29kZXIsIGtleVByZWZpeCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGRlYnVnUmVmSWRFbmNvZGluZ09yZGVyKHJlZiwgY2hhbmdlU2V0ID0gJ2FsbENoYW5nZXMnKSB7XG4gICAgICAgICAgICBsZXQgZW5jb2RlT3JkZXIgPSBbXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gcmVmWyRjaGFuZ2VzXS5yb290W2NoYW5nZVNldF0ubmV4dDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuY2hhbmdlVHJlZSkge1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVPcmRlci5wdXNoKGN1cnJlbnQuY2hhbmdlVHJlZS5yZWZJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlT3JkZXI7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGRlYnVnUmVmSWRzRnJvbURlY29kZXIoZGVjb2Rlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVidWdSZWZJZHMoZGVjb2Rlci5zdGF0ZSwgZmFsc2UsIDAsIGRlY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNoYW5nZXMgb24gYSBTY2hlbWEgaW5zdGFuY2UuXG4gICAgICAgICAqIFRoZSBsaXN0IG9mIGNoYW5nZXMgaXMgY2xlYXJlZCBhZnRlciBlYWNoIGVuY29kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGluc3RhbmNlIFNjaGVtYSBpbnN0YW5jZVxuICAgICAgICAgKiBAcGFyYW0gaXNFbmNvZGVBbGwgUmV0dXJuIFwiZnVsbCBlbmNvZGVcIiBpbnN0ZWFkIG9mIGN1cnJlbnQgY2hhbmdlIHNldC5cbiAgICAgICAgICogQHJldHVybnNcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWJ1Z0NoYW5nZXMoaW5zdGFuY2UsIGlzRW5jb2RlQWxsID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZVRyZWUgPSBpbnN0YW5jZVskY2hhbmdlc107XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VTZXQgPSAoaXNFbmNvZGVBbGwpID8gY2hhbmdlVHJlZS5hbGxDaGFuZ2VzIDogY2hhbmdlVHJlZS5jaGFuZ2VzO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlU2V0TmFtZSA9IChpc0VuY29kZUFsbCkgPyBcImFsbENoYW5nZXNcIiA6IFwiY2hhbmdlc1wiO1xuICAgICAgICAgICAgbGV0IG91dHB1dCA9IGAke2luc3RhbmNlLmNvbnN0cnVjdG9yLm5hbWV9ICgke2NoYW5nZVRyZWUucmVmSWR9KSAtPiAuJHtjaGFuZ2VTZXROYW1lfTpcXG5gO1xuICAgICAgICAgICAgZnVuY3Rpb24gZHVtcENoYW5nZVNldChjaGFuZ2VTZXQpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VTZXQub3BlcmF0aW9uc1xuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKG9wID0+IG9wKVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaCgoaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gY2hhbmdlVHJlZS5pbmRleGVkT3BlcmF0aW9uc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBgLSBbJHtpbmRleH1dOiAke2V4cG9ydHMuT1BFUkFUSU9OW29wZXJhdGlvbl19ICgke0pTT04uc3RyaW5naWZ5KGNoYW5nZVRyZWUuZ2V0VmFsdWUoTnVtYmVyKGluZGV4KSwgaXNFbmNvZGVBbGwpKX0pXFxuYDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGR1bXBDaGFuZ2VTZXQoY2hhbmdlU2V0KTtcbiAgICAgICAgICAgIC8vIGRpc3BsYXkgZmlsdGVyZWQgY2hhbmdlc1xuICAgICAgICAgICAgaWYgKCFpc0VuY29kZUFsbCAmJlxuICAgICAgICAgICAgICAgIGNoYW5nZVRyZWUuZmlsdGVyZWRDaGFuZ2VzICYmXG4gICAgICAgICAgICAgICAgKGNoYW5nZVRyZWUuZmlsdGVyZWRDaGFuZ2VzLm9wZXJhdGlvbnMpLmZpbHRlcihvcCA9PiBvcCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBgJHtpbnN0YW5jZS5jb25zdHJ1Y3Rvci5uYW1lfSAoJHtjaGFuZ2VUcmVlLnJlZklkfSkgLT4gLmZpbHRlcmVkQ2hhbmdlczpcXG5gO1xuICAgICAgICAgICAgICAgIGR1bXBDaGFuZ2VTZXQoY2hhbmdlVHJlZS5maWx0ZXJlZENoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGlzcGxheSBmaWx0ZXJlZCBjaGFuZ2VzXG4gICAgICAgICAgICBpZiAoaXNFbmNvZGVBbGwgJiZcbiAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlLmFsbEZpbHRlcmVkQ2hhbmdlcyAmJlxuICAgICAgICAgICAgICAgIChjaGFuZ2VUcmVlLmFsbEZpbHRlcmVkQ2hhbmdlcy5vcGVyYXRpb25zKS5maWx0ZXIob3AgPT4gb3ApLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYCR7aW5zdGFuY2UuY29uc3RydWN0b3IubmFtZX0gKCR7Y2hhbmdlVHJlZS5yZWZJZH0pIC0+IC5hbGxGaWx0ZXJlZENoYW5nZXM6XFxuYDtcbiAgICAgICAgICAgICAgICBkdW1wQ2hhbmdlU2V0KGNoYW5nZVRyZWUuYWxsRmlsdGVyZWRDaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGRlYnVnQ2hhbmdlc0RlZXAocmVmLCBjaGFuZ2VTZXROYW1lID0gXCJjaGFuZ2VzXCIpIHtcbiAgICAgICAgICAgIGxldCBvdXRwdXQgPSBcIlwiO1xuICAgICAgICAgICAgY29uc3Qgcm9vdENoYW5nZVRyZWUgPSByZWZbJGNoYW5nZXNdO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IHJvb3RDaGFuZ2VUcmVlLnJvb3Q7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VUcmVlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlUmVmSWRzID0gW107XG4gICAgICAgICAgICBsZXQgdG90YWxPcGVyYXRpb25zID0gMDtcbiAgICAgICAgICAgIC8vIFRPRE86IEZJWE1FOiB0aGlzIG1ldGhvZCBpcyBub3Qgd29ya2luZyBhcyBleHBlY3RlZFxuICAgICAgICAgICAgZm9yIChjb25zdCBbcmVmSWQsIGNoYW5nZXNdIG9mIE9iamVjdC5lbnRyaWVzKHJvb3RbY2hhbmdlU2V0TmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IHJvb3QuY2hhbmdlVHJlZXNbcmVmSWRdO1xuICAgICAgICAgICAgICAgIGlmICghY2hhbmdlVHJlZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGluY2x1ZGVDaGFuZ2VUcmVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudENoYW5nZVRyZWVzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudENoYW5nZVRyZWUgPSBjaGFuZ2VUcmVlLnBhcmVudD8uWyRjaGFuZ2VzXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlVHJlZSA9PT0gcm9vdENoYW5nZVRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZUNoYW5nZVRyZWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBhcmVudENoYW5nZVRyZWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Q2hhbmdlVHJlZXMucHVzaChwYXJlbnRDaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRDaGFuZ2VUcmVlLnJlZiA9PT0gcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZUNoYW5nZVRyZWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Q2hhbmdlVHJlZSA9IHBhcmVudENoYW5nZVRyZWUucGFyZW50Py5bJGNoYW5nZXNdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlQ2hhbmdlVHJlZSkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVJlZklkcy5wdXNoKGNoYW5nZVRyZWUucmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICB0b3RhbE9wZXJhdGlvbnMgKz0gT2JqZWN0LmtleXMoY2hhbmdlcykubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlcy5zZXQoY2hhbmdlVHJlZSwgcGFyZW50Q2hhbmdlVHJlZXMucmV2ZXJzZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQgKz0gXCItLS1cXG5cIjtcbiAgICAgICAgICAgIG91dHB1dCArPSBgcm9vdCByZWZJZDogJHtyb290Q2hhbmdlVHJlZS5yZWZJZH1cXG5gO1xuICAgICAgICAgICAgb3V0cHV0ICs9IGBUb3RhbCBpbnN0YW5jZXM6ICR7aW5zdGFuY2VSZWZJZHMubGVuZ3RofSAocmVmSWRzOiAke2luc3RhbmNlUmVmSWRzLmpvaW4oXCIsIFwiKX0pXFxuYDtcbiAgICAgICAgICAgIG91dHB1dCArPSBgVG90YWwgY2hhbmdlczogJHt0b3RhbE9wZXJhdGlvbnN9XFxuYDtcbiAgICAgICAgICAgIG91dHB1dCArPSBcIi0tLVxcblwiO1xuICAgICAgICAgICAgLy8gYmFzZWQgb24gcm9vdC5jaGFuZ2VzLCBkaXNwbGF5IGEgdHJlZSBvZiBjaGFuZ2VzIHRoYXQgaGFzIHRoZSBcInJlZlwiIGluc3RhbmNlIGFzIHBhcmVudFxuICAgICAgICAgICAgY29uc3QgdmlzaXRlZFBhcmVudHMgPSBuZXcgV2Vha1NldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbY2hhbmdlVHJlZSwgcGFyZW50Q2hhbmdlVHJlZXNdIG9mIGNoYW5nZVRyZWVzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIHBhcmVudENoYW5nZVRyZWVzLmZvckVhY2goKHBhcmVudENoYW5nZVRyZWUsIGxldmVsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFBhcmVudHMuaGFzKHBhcmVudENoYW5nZVRyZWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYCR7Z2V0SW5kZW50KGxldmVsKX0ke3BhcmVudENoYW5nZVRyZWUucmVmLmNvbnN0cnVjdG9yLm5hbWV9IChyZWZJZDogJHtwYXJlbnRDaGFuZ2VUcmVlLnJlZklkfSlcXG5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFBhcmVudHMuYWRkKHBhcmVudENoYW5nZVRyZWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGNoYW5nZVRyZWUuaW5kZXhlZE9wZXJhdGlvbnM7XG4gICAgICAgICAgICAgICAgY29uc3QgbGV2ZWwgPSBwYXJlbnRDaGFuZ2VUcmVlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZW50ID0gZ2V0SW5kZW50KGxldmVsKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJbmRleCA9IChsZXZlbCA+IDApID8gYCgke2NoYW5nZVRyZWUucGFyZW50SW5kZXh9KSBgIDogXCJcIjtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYCR7aW5kZW50fSR7cGFyZW50SW5kZXh9JHtjaGFuZ2VUcmVlLnJlZi5jb25zdHJ1Y3Rvci5uYW1lfSAocmVmSWQ6ICR7Y2hhbmdlVHJlZS5yZWZJZH0pIC0gY2hhbmdlczogJHtPYmplY3Qua2V5cyhjaGFuZ2VzKS5sZW5ndGh9XFxuYDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGluZGV4IGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gY2hhbmdlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBgJHtnZXRJbmRlbnQobGV2ZWwgKyAxKX0ke2V4cG9ydHMuT1BFUkFUSU9OW29wZXJhdGlvbl19OiAke2luZGV4fVxcbmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGAke291dHB1dH1gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG4gICAgUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbiAgICBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG4gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG4gICAgUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbiAgICBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbiAgICBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuICAgIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbiAgICBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcbiAgICBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuICAgIC8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgICAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbiAgICB9XHJcblxyXG4gICAgdHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICAgICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxuICAgIH07XG5cbiAgICBjbGFzcyBSb290IHtcbiAgICAgICAgY29uc3RydWN0b3IodHlwZXMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgICAgIHRoaXMubmV4dFVuaXF1ZUlkID0gMDtcbiAgICAgICAgICAgIHRoaXMucmVmQ291bnQgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlVHJlZXMgPSB7fTtcbiAgICAgICAgICAgIC8vIGFsbCBjaGFuZ2VzXG4gICAgICAgICAgICB0aGlzLmFsbENoYW5nZXMgPSBjcmVhdGVDaGFuZ2VUcmVlTGlzdCgpO1xuICAgICAgICAgICAgdGhpcy5hbGxGaWx0ZXJlZENoYW5nZXMgPSBjcmVhdGVDaGFuZ2VUcmVlTGlzdCgpOyAvLyBUT0RPOiBkbyBub3QgaW5pdGlhbGl6ZSBpdCBpZiBmaWx0ZXJzIGFyZSBub3QgdXNlZFxuICAgICAgICAgICAgLy8gcGVuZGluZyBjaGFuZ2VzIHRvIGJlIGVuY29kZWRcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlcyA9IGNyZWF0ZUNoYW5nZVRyZWVMaXN0KCk7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcmVkQ2hhbmdlcyA9IGNyZWF0ZUNoYW5nZVRyZWVMaXN0KCk7IC8vIFRPRE86IGRvIG5vdCBpbml0aWFsaXplIGl0IGlmIGZpbHRlcnMgYXJlIG5vdCB1c2VkXG4gICAgICAgIH1cbiAgICAgICAgZ2V0TmV4dFVuaXF1ZUlkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dFVuaXF1ZUlkKys7XG4gICAgICAgIH1cbiAgICAgICAgYWRkKGNoYW5nZVRyZWUpIHtcbiAgICAgICAgICAgIC8vIEFzc2lnbiB1bmlxdWUgYHJlZklkYCB0byBjaGFuZ2VUcmVlIGlmIGl0IGRvZXNuJ3QgaGF2ZSBvbmUgeWV0LlxuICAgICAgICAgICAgaWYgKGNoYW5nZVRyZWUucmVmSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZVRyZWUucmVmSWQgPSB0aGlzLmdldE5leHRVbmlxdWVJZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNOZXdDaGFuZ2VUcmVlID0gKHRoaXMuY2hhbmdlVHJlZXNbY2hhbmdlVHJlZS5yZWZJZF0gPT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBpZiAoaXNOZXdDaGFuZ2VUcmVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VUcmVlc1tjaGFuZ2VUcmVlLnJlZklkXSA9IGNoYW5nZVRyZWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1JlZkNvdW50ID0gdGhpcy5yZWZDb3VudFtjaGFuZ2VUcmVlLnJlZklkXTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c1JlZkNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBXaGVuIGEgQ2hhbmdlVHJlZSBpcyByZS1hZGRlZCwgaXQgbWVhbnMgdGhhdCBpdCB3YXMgcHJldmlvdXNseSByZW1vdmVkLlxuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gcmUtYWRkIGFsbCBjaGFuZ2VzIHRvIHRoZSBgY2hhbmdlc2AgbWFwLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgY29uc3Qgb3BzID0gY2hhbmdlVHJlZS5hbGxDaGFuZ2VzLm9wZXJhdGlvbnM7XG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IG9wcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVRyZWUuaW5kZXhlZE9wZXJhdGlvbnNbb3BzW2xlbl1dID0gZXhwb3J0cy5PUEVSQVRJT04uQUREO1xuICAgICAgICAgICAgICAgICAgICBzZXRPcGVyYXRpb25BdEluZGV4KGNoYW5nZVRyZWUuY2hhbmdlcywgbGVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlZkNvdW50W2NoYW5nZVRyZWUucmVmSWRdID0gKHByZXZpb3VzUmVmQ291bnQgfHwgMCkgKyAxO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJBRERcIiwgeyByZWZJZDogY2hhbmdlVHJlZS5yZWZJZCwgcmVmOiBjaGFuZ2VUcmVlLnJlZi5jb25zdHJ1Y3Rvci5uYW1lLCByZWZDb3VudDogdGhpcy5yZWZDb3VudFtjaGFuZ2VUcmVlLnJlZklkXSwgaXNOZXdDaGFuZ2VUcmVlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGlzTmV3Q2hhbmdlVHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmUoY2hhbmdlVHJlZSkge1xuICAgICAgICAgICAgY29uc3QgcmVmQ291bnQgPSAodGhpcy5yZWZDb3VudFtjaGFuZ2VUcmVlLnJlZklkXSkgLSAxO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJSRU1PVkVcIiwgeyByZWZJZDogY2hhbmdlVHJlZS5yZWZJZCwgcmVmOiBjaGFuZ2VUcmVlLnJlZi5jb25zdHJ1Y3Rvci5uYW1lLCByZWZDb3VudCwgbmVlZFJlbW92ZTogcmVmQ291bnQgPD0gMCB9KTtcbiAgICAgICAgICAgIGlmIChyZWZDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJlbW92ZSBcInJvb3RcIiByZWZlcmVuY2UgaWYgaXQncyB0aGUgbGFzdCByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGNoYW5nZVRyZWUucm9vdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jaGFuZ2VUcmVlc1tjaGFuZ2VUcmVlLnJlZklkXTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNoYW5nZUZyb21DaGFuZ2VTZXQoXCJhbGxDaGFuZ2VzXCIsIGNoYW5nZVRyZWUpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hhbmdlRnJvbUNoYW5nZVNldChcImNoYW5nZXNcIiwgY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZVRyZWUuZmlsdGVyZWRDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hhbmdlRnJvbUNoYW5nZVNldChcImFsbEZpbHRlcmVkQ2hhbmdlc1wiLCBjaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGFuZ2VGcm9tQ2hhbmdlU2V0KFwiZmlsdGVyZWRDaGFuZ2VzXCIsIGNoYW5nZVRyZWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlZkNvdW50W2NoYW5nZVRyZWUucmVmSWRdID0gMDtcbiAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlLmZvckVhY2hDaGlsZCgoY2hpbGQsIF8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLnJlbW92ZVBhcmVudChjaGFuZ2VUcmVlLnJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY2hpbGQucGFyZW50Q2hhaW4gPT09IHVuZGVmaW5lZCB8fCAvLyBubyBwYXJlbnQsIHJlbW92ZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjaGlsZC5wYXJlbnRDaGFpbiAmJiB0aGlzLnJlZkNvdW50W2NoaWxkLnJlZklkXSA+IDApIC8vIHBhcmVudCBpcyBzdGlsbCBpbiB1c2UsIGJ1dCBoYXMgbW9yZSB0aGFuIG9uZSByZWZlcmVuY2UsIHJlbW92ZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLnBhcmVudENoYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmUtYXNzaWduaW5nIGEgY2hpbGQgb2YgdGhlIHNhbWUgcm9vdCwgbW92ZSBpdCBuZXh0IHRvIHBhcmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZU5leHRUb1BhcmVudChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmQ291bnRbY2hhbmdlVHJlZS5yZWZJZF0gPSByZWZDb3VudDtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gbG9zaW5nIGEgcmVmZXJlbmNlIHRvIGFuIGluc3RhbmNlLCBpdCBpcyBiZXN0IHRvIG1vdmUgdGhlXG4gICAgICAgICAgICAgICAgLy8gQ2hhbmdlVHJlZSBuZXh0IHRvIGl0cyBwYXJlbnQgaW4gdGhlIGVuY29kaW5nIHF1ZXVlLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3YXksIGF0IGRlY29kaW5nIHRpbWUsIHRoZSBpbnN0YW5jZSB0aGF0IGNvbnRhaW5zIHRoZVxuICAgICAgICAgICAgICAgIC8vIENoYW5nZVRyZWUgd2lsbCBiZSBhdmFpbGFibGUgYmVmb3JlIHRoZSBDaGFuZ2VUcmVlIGl0c2VsZi4gSWYgdGhlXG4gICAgICAgICAgICAgICAgLy8gY29udGFpbmluZyBpbnN0YW5jZSBpcyBub3QgYXZhaWxhYmxlLCB0aGUgRGVjb2RlciB3aWxsIHRocm93XG4gICAgICAgICAgICAgICAgLy8gXCJyZWZJZCBub3QgZm91bmRcIiBlcnJvci5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHRoaXMucmVjdXJzaXZlbHlNb3ZlTmV4dFRvUGFyZW50KGNoYW5nZVRyZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlZkNvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJlY3Vyc2l2ZWx5TW92ZU5leHRUb1BhcmVudChjaGFuZ2VUcmVlKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVOZXh0VG9QYXJlbnQoY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICBjaGFuZ2VUcmVlLmZvckVhY2hDaGlsZCgoY2hpbGQsIF8pID0+IHRoaXMucmVjdXJzaXZlbHlNb3ZlTmV4dFRvUGFyZW50KGNoaWxkKSk7XG4gICAgICAgIH1cbiAgICAgICAgbW92ZU5leHRUb1BhcmVudChjaGFuZ2VUcmVlKSB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlVHJlZS5maWx0ZXJlZENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVOZXh0VG9QYXJlbnRJbkNoYW5nZVRyZWVMaXN0KFwiZmlsdGVyZWRDaGFuZ2VzXCIsIGNoYW5nZVRyZWUpO1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZU5leHRUb1BhcmVudEluQ2hhbmdlVHJlZUxpc3QoXCJhbGxGaWx0ZXJlZENoYW5nZXNcIiwgY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVOZXh0VG9QYXJlbnRJbkNoYW5nZVRyZWVMaXN0KFwiY2hhbmdlc1wiLCBjaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVOZXh0VG9QYXJlbnRJbkNoYW5nZVRyZWVMaXN0KFwiYWxsQ2hhbmdlc1wiLCBjaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtb3ZlTmV4dFRvUGFyZW50SW5DaGFuZ2VUcmVlTGlzdChjaGFuZ2VTZXROYW1lLCBjaGFuZ2VUcmVlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VTZXQgPSB0aGlzW2NoYW5nZVNldE5hbWVdO1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGNoYW5nZVRyZWVbY2hhbmdlU2V0TmFtZV0ucXVldWVSb290Tm9kZTtcbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBwYXJlbnQgaW4gdGhlIGxpbmtlZCBsaXN0XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBjaGFuZ2VUcmVlLnBhcmVudDtcbiAgICAgICAgICAgIGlmICghcGFyZW50IHx8ICFwYXJlbnRbJGNoYW5nZXNdKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBwYXJlbnRbJGNoYW5nZXNdW2NoYW5nZVNldE5hbWVdPy5xdWV1ZVJvb3ROb2RlO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnROb2RlIHx8IHBhcmVudE5vZGUgPT09IG5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gVXNlIGNhY2hlZCBwb3NpdGlvbnMgLSBubyBpdGVyYXRpb24gbmVlZGVkIVxuICAgICAgICAgICAgY29uc3QgcGFyZW50UG9zaXRpb24gPSBwYXJlbnROb2RlLnBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRQb3NpdGlvbiA9IG5vZGUucG9zaXRpb247XG4gICAgICAgICAgICAvLyBJZiBjaGlsZCBpcyBhbHJlYWR5IGFmdGVyIHBhcmVudCwgbm8gbmVlZCB0byBtb3ZlXG4gICAgICAgICAgICBpZiAoY2hpbGRQb3NpdGlvbiA+IHBhcmVudFBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIENoaWxkIGlzIGJlZm9yZSBwYXJlbnQsIHNvIHdlIG5lZWQgdG8gbW92ZSBpdCBhZnRlciBwYXJlbnRcbiAgICAgICAgICAgIC8vIFRoaXMgbWFpbnRhaW5zIGRlY29kaW5nIG9yZGVyIChwYXJlbnQgYmVmb3JlIGNoaWxkKVxuICAgICAgICAgICAgLy8gUmVtb3ZlIG5vZGUgZnJvbSBjdXJyZW50IHBvc2l0aW9uXG4gICAgICAgICAgICBpZiAobm9kZS5wcmV2KSB7XG4gICAgICAgICAgICAgICAgbm9kZS5wcmV2Lm5leHQgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VTZXQubmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLm5leHQpIHtcbiAgICAgICAgICAgICAgICBub2RlLm5leHQucHJldiA9IG5vZGUucHJldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5nZVNldC50YWlsID0gbm9kZS5wcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5zZXJ0IG5vZGUgcmlnaHQgYWZ0ZXIgcGFyZW50XG4gICAgICAgICAgICBub2RlLnByZXYgPSBwYXJlbnROb2RlO1xuICAgICAgICAgICAgbm9kZS5uZXh0ID0gcGFyZW50Tm9kZS5uZXh0O1xuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUubmV4dCkge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUubmV4dC5wcmV2ID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5nZVNldC50YWlsID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudE5vZGUubmV4dCA9IG5vZGU7XG4gICAgICAgICAgICAvLyBVcGRhdGUgcG9zaXRpb25zIGFmdGVyIHRoZSBtb3ZlXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uc0FmdGVyTW92ZShjaGFuZ2VTZXQsIG5vZGUsIHBhcmVudFBvc2l0aW9uICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5xdWV1ZUNoYW5nZVRyZWUoY2hhbmdlVHJlZSwgY2hhbmdlU2V0LCBxdWV1ZVJvb3ROb2RlID0gY2hhbmdlVHJlZVtjaGFuZ2VTZXRdLnF1ZXVlUm9vdE5vZGUpIHtcbiAgICAgICAgICAgIC8vIHNraXBcbiAgICAgICAgICAgIGlmIChxdWV1ZVJvb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRvIGxpbmtlZCBsaXN0IGlmIG5vdCBhbHJlYWR5IHByZXNlbnRcbiAgICAgICAgICAgIGNoYW5nZVRyZWVbY2hhbmdlU2V0XS5xdWV1ZVJvb3ROb2RlID0gdGhpcy5hZGRUb0NoYW5nZVRyZWVMaXN0KHRoaXNbY2hhbmdlU2V0XSwgY2hhbmdlVHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkVG9DaGFuZ2VUcmVlTGlzdChsaXN0LCBjaGFuZ2VUcmVlKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICAgICAgICAgIGNoYW5nZVRyZWUsXG4gICAgICAgICAgICAgICAgbmV4dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHByZXY6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogbGlzdC50YWlsID8gbGlzdC50YWlsLnBvc2l0aW9uICsgMSA6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIWxpc3QubmV4dCkge1xuICAgICAgICAgICAgICAgIGxpc3QubmV4dCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbGlzdC50YWlsID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUucHJldiA9IGxpc3QudGFpbDtcbiAgICAgICAgICAgICAgICBsaXN0LnRhaWwubmV4dCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbGlzdC50YWlsID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZVBvc2l0aW9uc0FmdGVyUmVtb3ZhbChsaXN0LCByZW1vdmVkUG9zaXRpb24pIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwb3NpdGlvbnMgZm9yIGFsbCBub2RlcyBhZnRlciB0aGUgcmVtb3ZlZCBwb3NpdGlvblxuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSBsaXN0Lm5leHQ7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPj0gcmVtb3ZlZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZVBvc2l0aW9uc0FmdGVyTW92ZShsaXN0LCBub2RlLCBuZXdQb3NpdGlvbikge1xuICAgICAgICAgICAgLy8gUmVjYWxjdWxhdGUgYWxsIHBvc2l0aW9ucyAtIHRoaXMgaXMgbW9yZSByZWxpYWJsZSB0aGFuIHRyeWluZyB0byBiZSBjbGV2ZXJcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gbGlzdC5uZXh0O1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW1vdmVDaGFuZ2VGcm9tQ2hhbmdlU2V0KGNoYW5nZVNldE5hbWUsIGNoYW5nZVRyZWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZVNldCA9IHRoaXNbY2hhbmdlU2V0TmFtZV07XG4gICAgICAgICAgICBjb25zdCBub2RlID0gY2hhbmdlVHJlZVtjaGFuZ2VTZXROYW1lXS5xdWV1ZVJvb3ROb2RlO1xuICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5jaGFuZ2VUcmVlID09PSBjaGFuZ2VUcmVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlZFBvc2l0aW9uID0gbm9kZS5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG5vZGUgZnJvbSB0aGUgbGlua2VkIGxpc3RcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5wcmV2KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlU2V0Lm5leHQgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub2RlLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VTZXQudGFpbCA9IG5vZGUucHJldjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHBvc2l0aW9ucyBmb3Igbm9kZXMgdGhhdCBjYW1lIGFmdGVyIHRoZSByZW1vdmVkIG5vZGVcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uc0FmdGVyUmVtb3ZhbChjaGFuZ2VTZXQsIHJlbW92ZWRQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgQ2hhbmdlVHJlZSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlW2NoYW5nZVNldE5hbWVdLnF1ZXVlUm9vdE5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBFbmNvZGVyIHtcbiAgICAgICAgc3RhdGljIHsgdGhpcy5CVUZGRVJfU0laRSA9ICh0eXBlb2YgKEJ1ZmZlcikgIT09IFwidW5kZWZpbmVkXCIpICYmIEJ1ZmZlci5wb29sU2l6ZSB8fCA4ICogMTAyNDsgfSAvLyA4S0JcbiAgICAgICAgY29uc3RydWN0b3Ioc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkQnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKEVuY29kZXIuQlVGRkVSX1NJWkUpO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFVzZSAuY2FjaGUoKSBoZXJlIHRvIGF2b2lkIHJlLWNyZWF0aW5nIGEgbmV3IGNvbnRleHQgZm9yIGV2ZXJ5IG5ldyByb29tIGluc3RhbmNlLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFdlIG1heSBuZWVkIHRvIG1ha2UgdGhpcyBvcHRpb25hbCBpbiBjYXNlIG9mIGR5bmFtaWNhbGx5IGNyZWF0ZWRcbiAgICAgICAgICAgIC8vIHNjaGVtYXMgLSB3aGljaCB3b3VsZCBsZWFkIHRvIG1lbW9yeSBsZWFrc1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IFR5cGVDb250ZXh0LmNhY2hlKHN0YXRlLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IG5ldyBSb290KHRoaXMuY29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiPj4+Pj4+Pj4+Pj4+Pj4+PiBFbmNvZGVyIHR5cGVzXCIpO1xuICAgICAgICAgICAgLy8gdGhpcy5jb250ZXh0LnNjaGVtYXMuZm9yRWFjaCgoaWQsIHNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKFwidHlwZTpcIiwgaWQsIHNjaGVtYS5uYW1lLCBPYmplY3Qua2V5cyhzY2hlbWFbU3ltYm9sLm1ldGFkYXRhXSkpO1xuICAgICAgICAgICAgLy8gfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0U3RhdGUoc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVbJGNoYW5nZXNdLnNldFJvb3QodGhpcy5yb290KTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGUoaXQgPSB7IG9mZnNldDogMCB9LCB2aWV3LCBidWZmZXIgPSB0aGlzLnNoYXJlZEJ1ZmZlciwgY2hhbmdlU2V0TmFtZSA9IFwiY2hhbmdlc1wiLCBpc0VuY29kZUFsbCA9IGNoYW5nZVNldE5hbWUgPT09IFwiYWxsQ2hhbmdlc1wiLCBpbml0aWFsT2Zmc2V0ID0gaXQub2Zmc2V0IC8vIGNhY2hlIGN1cnJlbnQgb2Zmc2V0IGluIGNhc2Ugd2UgbmVlZCB0byByZXNpemUgdGhlIGJ1ZmZlclxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IGhhc1ZpZXcgPSAodmlldyAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3RDaGFuZ2VUcmVlID0gdGhpcy5zdGF0ZVskY2hhbmdlc107XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMucm9vdFtjaGFuZ2VTZXROYW1lXTtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50ID0gY3VycmVudC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IGN1cnJlbnQuY2hhbmdlVHJlZTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVmlldykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZpZXcuaXNDaGFuZ2VUcmVlVmlzaWJsZShjaGFuZ2VUcmVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJNQVJLIEFTIElOVklTSUJMRTpcIiwgeyByZWY6IGNoYW5nZVRyZWUucmVmLmNvbnN0cnVjdG9yLm5hbWUsIHJlZklkOiBjaGFuZ2VUcmVlLnJlZklkLCByYXc6IGNoYW5nZVRyZWUucmVmLnRvSlNPTigpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5pbnZpc2libGUuYWRkKGNoYW5nZVRyZWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIHNraXAgdGhpcyBjaGFuZ2UgdHJlZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuaW52aXNpYmxlLmRlbGV0ZShjaGFuZ2VUcmVlKTsgLy8gcmVtb3ZlIGZyb20gaW52aXNpYmxlIGxpc3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlU2V0ID0gY2hhbmdlVHJlZVtjaGFuZ2VTZXROYW1lXTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWYgPSBjaGFuZ2VUcmVlLnJlZjtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhdm9pZCBpdGVyYXRpbmcgb3ZlciBjaGFuZ2UgdHJlZSBpZiBubyBjaGFuZ2VzIHdlcmUgbWFkZVxuICAgICAgICAgICAgICAgIGNvbnN0IG51bUNoYW5nZXMgPSBjaGFuZ2VTZXQub3BlcmF0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG51bUNoYW5nZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGN0b3IgPSByZWYuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGN0b3JbJGVuY29kZXJdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IGN0b3JbJGZpbHRlcl07XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBjdG9yW1N5bWJvbC5tZXRhZGF0YV07XG4gICAgICAgICAgICAgICAgLy8gc2tpcCByb290IGByZWZJZGAgaWYgaXQncyB0aGUgZmlyc3QgY2hhbmdlIHRyZWVcbiAgICAgICAgICAgICAgICAvLyAodW5sZXNzIGl0IFwiaGFzVmlld1wiLCB3aGljaCB3aWxsIG5lZWQgdG8gcmV2aXNpdCB0aGUgcm9vdClcbiAgICAgICAgICAgICAgICBpZiAoaGFzVmlldyB8fCBpdC5vZmZzZXQgPiBpbml0aWFsT2Zmc2V0IHx8IGNoYW5nZVRyZWUgIT09IHJvb3RDaGFuZ2VUcmVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpdC5vZmZzZXQrK10gPSBTV0lUQ0hfVE9fU1RSVUNUVVJFICYgMjU1O1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGUubnVtYmVyKGJ1ZmZlciwgY2hhbmdlVHJlZS5yZWZJZCwgaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUNoYW5nZXM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZEluZGV4ID0gY2hhbmdlU2V0Lm9wZXJhdGlvbnNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZEluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJwdXJlXCIgb3BlcmF0aW9uIHdpdGhvdXQgZmllbGRJbmRleCAoZS5nLiBDTEVBUiwgUkVWRVJTRSwgZXRjLilcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuY29kZSBhbmQgY29udGludWUgZWFybHkgLSBubyBuZWVkIHRvIHJlYWNoICRmaWx0ZXIgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpdC5vZmZzZXQrK10gPSBNYXRoLmFicyhmaWVsZEluZGV4KSAmIDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IChpc0VuY29kZUFsbClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZXhwb3J0cy5PUEVSQVRJT04uQUREXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNoYW5nZVRyZWUuaW5kZXhlZE9wZXJhdGlvbnNbZmllbGRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpcnN0IHBhc3MgKGVuY29kZUFsbCksIGlkZW50aWZ5IFwiZmlsdGVyZWRcIiBvcGVyYXRpb25zIHdpdGhvdXQgZW5jb2RpbmcgdGhlbVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGV5IHdpbGwgYmUgZW5jb2RlZCBwZXIgY2xpZW50LCBiYXNlZCBvbiB0aGVpciB2aWV3LlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBob3cgY2FuIHdlIG9wdGltaXplIGZpbHRlcmluZyBvdXQgXCJlbmNvZGUgYWxsXCIgb3BlcmF0aW9ucz9cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogYXZvaWQgY2hlY2tpbmcgaWYgbm8gdmlldyB0YWdzIHdlcmUgZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRJbmRleCA9PT0gdW5kZWZpbmVkIHx8IG9wZXJhdGlvbiA9PT0gdW5kZWZpbmVkIHx8IChmaWx0ZXIgJiYgIWZpbHRlcihyZWYsIGZpZWxkSW5kZXgsIHZpZXcpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJBREQgQVMgSU5WSVNJQkxFOlwiLCBmaWVsZEluZGV4LCBjaGFuZ2VUcmVlLnJlZi5jb25zdHJ1Y3Rvci5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmlldz8uaW52aXNpYmxlLmFkZChjaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVuY29kZXIodGhpcywgYnVmZmVyLCBjaGFuZ2VUcmVlLCBmaWVsZEluZGV4LCBvcGVyYXRpb24sIGl0LCBpc0VuY29kZUFsbCwgaGFzVmlldywgbWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdC5vZmZzZXQgPiBidWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBhc3N1bWUgdGhhdCBuICsgMSBwb29sU2l6ZSB3aWxsIHN1ZmZpY2UgZ2l2ZW4gdGhhdCB3ZSBhcmUgbGlrZWx5IGRvbmUgd2l0aCBlbmNvZGluZyBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICAgICAgLy8gbXVsdGlwbGVzIG9mIHBvb2xTaXplIGFyZSBmYXN0ZXIgdG8gYWxsb2NhdGUgdGhhbiBhcmJpdHJhcnkgc2l6ZXNcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgb24gYW4gb2xkZXIgcGxhdGZvcm0gdGhhdCBkb2Vzbid0IGltcGxlbWVudCBwb29saW5nIHVzZSA4a2IgYXMgcG9vbFNpemUgKHRoYXQncyB0aGUgZGVmYXVsdCBmb3Igbm9kZSlcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTaXplID0gTWF0aC5jZWlsKGl0Lm9mZnNldCAvIChCdWZmZXIucG9vbFNpemUgPz8gOCAqIDEwMjQpKSAqIChCdWZmZXIucG9vbFNpemUgPz8gOCAqIDEwMjQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQGNvbHlzZXVzL3NjaGVtYSBidWZmZXIgb3ZlcmZsb3cuIEVuY29kZWQgc3RhdGUgaXMgaGlnaGVyIHRoYW4gZGVmYXVsdCBCVUZGRVJfU0laRS4gVXNlIHRoZSBmb2xsb3dpbmcgdG8gaW5jcmVhc2UgZGVmYXVsdCBCVUZGRVJfU0laRTpcblxuICAgIGltcG9ydCB7IEVuY29kZXIgfSBmcm9tIFwiQGNvbHlzZXVzL3NjaGVtYVwiO1xuICAgIEVuY29kZXIuQlVGRkVSX1NJWkUgPSAke01hdGgucm91bmQobmV3U2l6ZSAvIDEwMjQpfSAqIDEwMjQ7IC8vICR7TWF0aC5yb3VuZChuZXdTaXplIC8gMTAyNCl9IEtCXG5gKTtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIHJlc2l6ZSBidWZmZXIgYW5kIHJlLWVuY29kZSAoVE9ETzogY2FuIHdlIGF2b2lkIHJlLWVuY29kaW5nIGhlcmU/KVxuICAgICAgICAgICAgICAgIC8vIC0+IE5vIHdlIHByb2JhYmx5IGNhbid0IHVubGVzcyB3ZSBjYXRjaCB0aGUgbmVlZCBmb3IgcmVzaXplIGJlZm9yZSBlbmNvZGluZyB3aGljaCBpcyBsaWtlbHkgbW9yZSBjb21wdXRhdGlvbmFsbHkgZXhwZW5zaXZlIHRoYW4gcmVzaXppbmcgb24gZGVtYW5kXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBidWZmZXIgPSBCdWZmZXIuYWxsb2MobmV3U2l6ZSwgYnVmZmVyKTsgLy8gZmlsbCB3aXRoIGJ1ZmZlciBoZXJlIHRvIG1lbWNweSBwcmV2aW91cyBlbmNvZGluZyBzdGVwcyBiZXlvbmQgdGhlIGluaXRpYWxPZmZzZXRcbiAgICAgICAgICAgICAgICAvLyBhc3NpZ24gcmVzaXplZCBidWZmZXIgdG8gbG9jYWwgc2hhcmVkQnVmZmVyXG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlciA9PT0gdGhpcy5zaGFyZWRCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGFyZWRCdWZmZXIgPSBidWZmZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZSh7IG9mZnNldDogaW5pdGlhbE9mZnNldCB9LCB2aWV3LCBidWZmZXIsIGNoYW5nZVNldE5hbWUsIGlzRW5jb2RlQWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIuc3ViYXJyYXkoMCwgaXQub2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbmNvZGVBbGwoaXQgPSB7IG9mZnNldDogMCB9LCBidWZmZXIgPSB0aGlzLnNoYXJlZEJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKGl0LCB1bmRlZmluZWQsIGJ1ZmZlciwgXCJhbGxDaGFuZ2VzXCIsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZUFsbFZpZXcodmlldywgc2hhcmVkT2Zmc2V0LCBpdCwgYnl0ZXMgPSB0aGlzLnNoYXJlZEJ1ZmZlcikge1xuICAgICAgICAgICAgY29uc3Qgdmlld09mZnNldCA9IGl0Lm9mZnNldDtcbiAgICAgICAgICAgIC8vIHRyeSB0byBlbmNvZGUgXCJmaWx0ZXJlZFwiIGNoYW5nZXNcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlKGl0LCB2aWV3LCBieXRlcywgXCJhbGxGaWx0ZXJlZENoYW5nZXNcIiwgdHJ1ZSwgdmlld09mZnNldCk7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgYnl0ZXMuc3ViYXJyYXkoMCwgc2hhcmVkT2Zmc2V0KSxcbiAgICAgICAgICAgICAgICBieXRlcy5zdWJhcnJheSh2aWV3T2Zmc2V0LCBpdC5vZmZzZXQpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGVWaWV3KHZpZXcsIHNoYXJlZE9mZnNldCwgaXQsIGJ5dGVzID0gdGhpcy5zaGFyZWRCdWZmZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXdPZmZzZXQgPSBpdC5vZmZzZXQ7XG4gICAgICAgICAgICAvLyBlbmNvZGUgdmlzaWJpbGl0eSBjaGFuZ2VzIChhZGQvcmVtb3ZlIGZvciB0aGlzIHZpZXcpXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtyZWZJZCwgY2hhbmdlc10gb2Ygdmlldy5jaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IHRoaXMucm9vdC5jaGFuZ2VUcmVlc1tyZWZJZF07XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZVRyZWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZXRhY2hlZCBpbnN0YW5jZSwgcmVtb3ZlIGZyb20gdmlldyBhbmQgc2tpcC5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJkZXRhY2hlZCBpbnN0YW5jZSwgcmVtb3ZlIGZyb20gdmlldyBhbmQgc2tpcC5cIiwgcmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmNoYW5nZXMuZGVsZXRlKHJlZklkKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IGF2b2lkIGhhdmluZyBlbXB0eSBjaGFuZ2VzIGlmIG5vIGNoYW5nZXMgd2VyZSBtYWRlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiY2hhbmdlcy5zaXplID09PSAwLCBza2lwXCIsIHJlZklkLCBjaGFuZ2VUcmVlLnJlZi5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IGNoYW5nZVRyZWUucmVmO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN0b3IgPSByZWYuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGN0b3JbJGVuY29kZXJdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3RvcltTeW1ib2wubWV0YWRhdGFdO1xuICAgICAgICAgICAgICAgIGJ5dGVzW2l0Lm9mZnNldCsrXSA9IFNXSVRDSF9UT19TVFJVQ1RVUkUgJiAyNTU7XG4gICAgICAgICAgICAgICAgZW5jb2RlLm51bWJlcihieXRlcywgY2hhbmdlVHJlZS5yZWZJZCwgaXQpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBudW1DaGFuZ2VzID0ga2V5cy5sZW5ndGg7IGkgPCBudW1DaGFuZ2VzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBOdW1iZXIoa2V5c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdvcmthcm91bmQgd2hlbiB1c2luZyB2aWV3LmFkZCgpIG9uIGl0ZW0gdGhhdCBoYXMgYmVlbiBkZWxldGVkIGZyb20gc3RhdGUgKHNlZSB0ZXN0IFwiYWRkaW5nIHRvIHZpZXcgaXRlbSB0aGF0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSBzdGF0ZVwiKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNoYW5nZVRyZWUucmVmWyRnZXRCeUluZGV4XShpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGNoYW5nZXNbaW5kZXhdKSB8fCBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEU7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzRW5jb2RlQWxsID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzVmlldyA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rlcih0aGlzLCBieXRlcywgY2hhbmdlVHJlZSwgaW5kZXgsIG9wZXJhdGlvbiwgaXQsIGZhbHNlLCB0cnVlLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRPRE86IG9ubHkgY2xlYXIgdmlldyBjaGFuZ2VzIGFmdGVyIGFsbCB2aWV3cyBhcmUgZW5jb2RlZFxuICAgICAgICAgICAgLy8gKHRvIGFsbG93IHJlLXVzaW5nIFN0YXRlVmlldydzIGZvciBtdWx0aXBsZSBjbGllbnRzKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGNsZWFyIFwidmlld1wiIGNoYW5nZXMgYWZ0ZXIgZW5jb2RpbmdcbiAgICAgICAgICAgIHZpZXcuY2hhbmdlcy5jbGVhcigpO1xuICAgICAgICAgICAgLy8gdHJ5IHRvIGVuY29kZSBcImZpbHRlcmVkXCIgY2hhbmdlc1xuICAgICAgICAgICAgdGhpcy5lbmNvZGUoaXQsIHZpZXcsIGJ5dGVzLCBcImZpbHRlcmVkQ2hhbmdlc1wiLCBmYWxzZSwgdmlld09mZnNldCk7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgYnl0ZXMuc3ViYXJyYXkoMCwgc2hhcmVkT2Zmc2V0KSxcbiAgICAgICAgICAgICAgICBieXRlcy5zdWJhcnJheSh2aWV3T2Zmc2V0LCBpdC5vZmZzZXQpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBkaXNjYXJkQ2hhbmdlcygpIHtcbiAgICAgICAgICAgIC8vIGRpc2NhcmQgc2hhcmVkIGNoYW5nZXNcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5yb290LmNoYW5nZXMubmV4dDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5jaGFuZ2VUcmVlLmVuZEVuY29kZSgnY2hhbmdlcycpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJvb3QuY2hhbmdlcyA9IGNyZWF0ZUNoYW5nZVRyZWVMaXN0KCk7XG4gICAgICAgICAgICAvLyBkaXNjYXJkIGZpbHRlcmVkIGNoYW5nZXNcbiAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLnJvb3QuZmlsdGVyZWRDaGFuZ2VzLm5leHQ7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQuY2hhbmdlVHJlZS5lbmRFbmNvZGUoJ2ZpbHRlcmVkQ2hhbmdlcycpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJvb3QuZmlsdGVyZWRDaGFuZ2VzID0gY3JlYXRlQ2hhbmdlVHJlZUxpc3QoKTtcbiAgICAgICAgfVxuICAgICAgICB0cnlFbmNvZGVUeXBlSWQoYnl0ZXMsIGJhc2VUeXBlLCB0YXJnZXRUeXBlLCBpdCkge1xuICAgICAgICAgICAgY29uc3QgYmFzZVR5cGVJZCA9IHRoaXMuY29udGV4dC5nZXRUeXBlSWQoYmFzZVR5cGUpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0VHlwZUlkID0gdGhpcy5jb250ZXh0LmdldFR5cGVJZCh0YXJnZXRUeXBlKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRUeXBlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQGNvbHlzZXVzL3NjaGVtYSBXQVJOSU5HOiBDbGFzcyBcIiR7dGFyZ2V0VHlwZS5uYW1lfVwiIGlzIG5vdCByZWdpc3RlcmVkIG9uIFR5cGVSZWdpc3RyeSAtIFBsZWFzZSBlaXRoZXIgdGFnIHRoZSBjbGFzcyB3aXRoIEBlbnRpdHkgb3IgZGVmaW5lIGEgQHR5cGUoKSBmaWVsZC5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmFzZVR5cGVJZCAhPT0gdGFyZ2V0VHlwZUlkKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gVFlQRV9JRCAmIDI1NTtcbiAgICAgICAgICAgICAgICBlbmNvZGUubnVtYmVyKGJ5dGVzLCB0YXJnZXRUeXBlSWQsIGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXQgaGFzQ2hhbmdlcygpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5yb290LmNoYW5nZXMubmV4dCAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5yb290LmZpbHRlcmVkQ2hhbmdlcy5uZXh0ICE9PSB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3BsaWNlT25lKGFyciwgaW5kZXgpIHtcbiAgICAgICAgLy8gbWFudWFsbHkgc3BsaWNlIGFuIGFycmF5XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEgfHwgaW5kZXggPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbiA9IGFyci5sZW5ndGggLSAxO1xuICAgICAgICBmb3IgKGxldCBpID0gaW5kZXg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgYXJyW2ldID0gYXJyW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBhcnIubGVuZ3RoID0gbGVuO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjbGFzcyBEZWNvZGluZ1dhcm5pbmcgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gXCJEZWNvZGluZ1dhcm5pbmdcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGFzcyBSZWZlcmVuY2VUcmFja2VyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gUmVsYXRpb24gb2YgcmVmSWQgPT4gU2NoZW1hIHN0cnVjdHVyZVxuICAgICAgICAgICAgLy8gRm9yIGRpcmVjdCBhY2Nlc3Mgb2Ygc3RydWN0dXJlcyBkdXJpbmcgZGVjb2RpbmcgdGltZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB0aGlzLnJlZnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLnJlZklkcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgICB0aGlzLnJlZkNvdW50ID0ge307XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZWRSZWZzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcbiAgICAgICAgICAgIHRoaXMubmV4dFVuaXF1ZUlkID0gMDtcbiAgICAgICAgfVxuICAgICAgICBnZXROZXh0VW5pcXVlSWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0VW5pcXVlSWQrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBmb3IgZGVjb2RpbmdcbiAgICAgICAgYWRkUmVmKHJlZklkLCByZWYsIGluY3JlbWVudENvdW50ID0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5yZWZzLnNldChyZWZJZCwgcmVmKTtcbiAgICAgICAgICAgIHRoaXMucmVmSWRzLnNldChyZWYsIHJlZklkKTtcbiAgICAgICAgICAgIGlmIChpbmNyZW1lbnRDb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmQ291bnRbcmVmSWRdID0gKHRoaXMucmVmQ291bnRbcmVmSWRdIHx8IDApICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGV0ZWRSZWZzLmhhcyhyZWZJZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZWRSZWZzLmRlbGV0ZShyZWZJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZm9yIGRlY29kaW5nXG4gICAgICAgIHJlbW92ZVJlZihyZWZJZCkge1xuICAgICAgICAgICAgY29uc3QgcmVmQ291bnQgPSB0aGlzLnJlZkNvdW50W3JlZklkXTtcbiAgICAgICAgICAgIGlmIChyZWZDb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IERlY29kaW5nV2FybmluZyhcInRyeWluZyB0byByZW1vdmUgcmVmSWQgdGhhdCBkb2Vzbid0IGV4aXN0OiBcIiArIHJlZklkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVmQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWYgPSB0aGlzLnJlZnMuZ2V0KHJlZklkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IERlY29kaW5nV2FybmluZyhgdHJ5aW5nIHRvIHJlbW92ZSByZWZJZCAnJHtyZWZJZH0nIHdpdGggMCByZWZDb3VudCAoJHtyZWYuY29uc3RydWN0b3IubmFtZX06ICR7SlNPTi5zdHJpbmdpZnkocmVmKX0pYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0aGlzLnJlZkNvdW50W3JlZklkXSA9IHJlZkNvdW50IC0gMSkgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlZFJlZnMuYWRkKHJlZklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjbGVhclJlZnMoKSB7XG4gICAgICAgICAgICB0aGlzLnJlZnMuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlZFJlZnMuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzID0ge307XG4gICAgICAgICAgICB0aGlzLnJlZkNvdW50ID0ge307XG4gICAgICAgIH1cbiAgICAgICAgLy8gZm9yIGRlY29kaW5nXG4gICAgICAgIGdhcmJhZ2VDb2xsZWN0RGVsZXRlZFJlZnMoKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZWRSZWZzLmZvckVhY2goKHJlZklkKSA9PiB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBTa2lwIGFjdGl2ZSByZWZlcmVuY2VzLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVmQ291bnRbcmVmSWRdID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IHRoaXMucmVmcy5nZXQocmVmSWQpO1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIGNoaWxkIHNjaGVtYSBpbnN0YW5jZXMgaGF2ZSB0aGVpciByZWZlcmVuY2VzIHJlbW92ZWQgYXMgd2VsbC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmIChyZWYuY29uc3RydWN0b3JbU3ltYm9sLm1ldGFkYXRhXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gcmVmLmNvbnN0cnVjdG9yW1N5bWJvbC5tZXRhZGF0YV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggaW4gbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gbWV0YWRhdGFbaW5kZXhdLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFJlZklkID0gdHlwZW9mIChyZWZbZmllbGRdKSA9PT0gXCJvYmplY3RcIiAmJiB0aGlzLnJlZklkcy5nZXQocmVmW2ZpZWxkXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRSZWZJZCAmJiAhdGhpcy5kZWxldGVkUmVmcy5oYXMoY2hpbGRSZWZJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVJlZihjaGlsZFJlZklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocmVmWyRjaGlsZFR5cGVdKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5mcm9tKHJlZi52YWx1ZXMoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFJlZklkID0gdGhpcy5yZWZJZHMuZ2V0KGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVsZXRlZFJlZnMuaGFzKGNoaWxkUmVmSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlUmVmKGNoaWxkUmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVmcy5kZWxldGUocmVmSWQpOyAvLyByZW1vdmUgcmVmXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVmQ291bnRbcmVmSWRdOyAvLyByZW1vdmUgcmVmIGNvdW50XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tzW3JlZklkXTsgLy8gcmVtb3ZlIGNhbGxiYWNrc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBjbGVhciBkZWxldGVkIHJlZnMuXG4gICAgICAgICAgICB0aGlzLmRlbGV0ZWRSZWZzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkQ2FsbGJhY2socmVmSWQsIGZpZWxkT3JPcGVyYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAocmVmSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSAodHlwZW9mIChmaWVsZE9yT3BlcmF0aW9uKSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgPyBleHBvcnRzLk9QRVJBVElPTltmaWVsZE9yT3BlcmF0aW9uXVxuICAgICAgICAgICAgICAgICAgICA6IGZpZWxkT3JPcGVyYXRpb247XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBhZGRDYWxsYmFjayBvbiAnJHtuYW1lfScgKHJlZklkIGlzIHVuZGVmaW5lZClgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5jYWxsYmFja3NbcmVmSWRdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3NbcmVmSWRdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW3JlZklkXVtmaWVsZE9yT3BlcmF0aW9uXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzW3JlZklkXVtmaWVsZE9yT3BlcmF0aW9uXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3NbcmVmSWRdW2ZpZWxkT3JPcGVyYXRpb25dLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHRoaXMucmVtb3ZlQ2FsbGJhY2socmVmSWQsIGZpZWxkT3JPcGVyYXRpb24sIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVDYWxsYmFjayhyZWZJZCwgZmllbGQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuY2FsbGJhY2tzPy5bcmVmSWRdPy5bZmllbGRdPy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHNwbGljZU9uZSh0aGlzLmNhbGxiYWNrc1tyZWZJZF1bZmllbGRdLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBEZWNvZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3Iocm9vdCwgY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVmSWQgPSAwO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShyb290KTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQgfHwgbmV3IFR5cGVDb250ZXh0KHJvb3QuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCI+Pj4+Pj4+Pj4+Pj4+Pj4+IERlY29kZXIgdHlwZXNcIik7XG4gICAgICAgICAgICAvLyB0aGlzLmNvbnRleHQuc2NoZW1hcy5mb3JFYWNoKChpZCwgc2NoZW1hKSA9PiB7XG4gICAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2coXCJ0eXBlOlwiLCBpZCwgc2NoZW1hLm5hbWUsIE9iamVjdC5rZXlzKHNjaGVtYVtTeW1ib2wubWV0YWRhdGFdKSk7XG4gICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRTdGF0ZShyb290KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gcm9vdDtcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IG5ldyBSZWZlcmVuY2VUcmFja2VyKCk7XG4gICAgICAgICAgICB0aGlzLnJvb3QuYWRkUmVmKDAsIHJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZShieXRlcywgaXQgPSB7IG9mZnNldDogMCB9LCByZWYgPSB0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBjb25zdCBhbGxDaGFuZ2VzID0gW107XG4gICAgICAgICAgICBjb25zdCAkcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsQnl0ZXMgPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGRlY29kZXIgPSByZWZbJ2NvbnN0cnVjdG9yJ11bJGRlY29kZXJdO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVmSWQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGl0Lm9mZnNldCA8IHRvdGFsQnl0ZXMpIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFBlZWsgYWhlYWQsIGNoZWNrIGlmIGl0J3MgYSBzd2l0Y2ggdG8gYSBkaWZmZXJlbnQgc3RydWN0dXJlXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBpZiAoYnl0ZXNbaXQub2Zmc2V0XSA9PSBTV0lUQ0hfVE9fU1RSVUNUVVJFKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0Lm9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICByZWZbJG9uRGVjb2RlRW5kXT8uKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRSZWZJZCA9IGRlY29kZS5udW1iZXIoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFJlZiA9ICRyb290LnJlZnMuZ2V0KG5leHRSZWZJZCk7XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeWluZyB0byBhY2Nlc3MgYSByZWZlcmVuY2UgdGhhdCBoYXZlbid0IGJlZW4gZGVjb2RlZCB5ZXQuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dFJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKGBcInJlZklkXCIgbm90IGZvdW5kOiAke25leHRSZWZJZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFwicmVmSWRcIiBub3QgZm91bmQ6ICR7bmV4dFJlZklkfWAsIHsgcHJldmlvdXNSZWY6IHJlZiwgcHJldmlvdXNSZWZJZDogdGhpcy5jdXJyZW50UmVmSWQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJQbGVhc2UgcmVwb3J0IHRoaXMgaXNzdWUgdG8gdGhlIGRldmVsb3BlcnMuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5za2lwQ3VycmVudFN0cnVjdHVyZShieXRlcywgaXQsIHRvdGFsQnl0ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmID0gbmV4dFJlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZXIgPSByZWYuY29uc3RydWN0b3JbJGRlY29kZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVmSWQgPSBuZXh0UmVmSWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlY29kZXIodGhpcywgYnl0ZXMsIGl0LCByZWYsIGFsbENoYW5nZXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IERFRklOSVRJT05fTUlTTUFUQ0gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQGNvbHlzZXVzL3NjaGVtYTogZGVmaW5pdGlvbiBtaXNtYXRjaFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5za2lwQ3VycmVudFN0cnVjdHVyZShieXRlcywgaXQsIHRvdGFsQnl0ZXMpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGSVhNRTogRFJZIHdpdGggU1dJVENIX1RPX1NUUlVDVFVSRSBibG9jay5cbiAgICAgICAgICAgIHJlZlskb25EZWNvZGVFbmRdPy4oKTtcbiAgICAgICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlc1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyQ2hhbmdlcz8uKGFsbENoYW5nZXMpO1xuICAgICAgICAgICAgLy8gZHJvcCByZWZlcmVuY2VzIG9mIHVudXNlZCBzY2hlbWFzXG4gICAgICAgICAgICAkcm9vdC5nYXJiYWdlQ29sbGVjdERlbGV0ZWRSZWZzKCk7XG4gICAgICAgICAgICByZXR1cm4gYWxsQ2hhbmdlcztcbiAgICAgICAgfVxuICAgICAgICBza2lwQ3VycmVudFN0cnVjdHVyZShieXRlcywgaXQsIHRvdGFsQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBrZWVwIHNraXBwaW5nIG5leHQgYnl0ZXMgdW50aWwgcmVhY2hlcyBhIGtub3duIHN0cnVjdHVyZVxuICAgICAgICAgICAgLy8gYnkgbG9jYWwgZGVjb2Rlci5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBjb25zdCBuZXh0SXRlcmF0b3IgPSB7IG9mZnNldDogaXQub2Zmc2V0IH07XG4gICAgICAgICAgICB3aGlsZSAoaXQub2Zmc2V0IDwgdG90YWxCeXRlcykge1xuICAgICAgICAgICAgICAgIGlmIChieXRlc1tpdC5vZmZzZXRdID09PSBTV0lUQ0hfVE9fU1RSVUNUVVJFKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRJdGVyYXRvci5vZmZzZXQgPSBpdC5vZmZzZXQgKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yb290LnJlZnMuaGFzKGRlY29kZS5udW1iZXIoYnl0ZXMsIG5leHRJdGVyYXRvcikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdC5vZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXRJbnN0YW5jZVR5cGUoYnl0ZXMsIGl0LCBkZWZhdWx0VHlwZSkge1xuICAgICAgICAgICAgbGV0IHR5cGU7XG4gICAgICAgICAgICBpZiAoYnl0ZXNbaXQub2Zmc2V0XSA9PT0gVFlQRV9JRCkge1xuICAgICAgICAgICAgICAgIGl0Lm9mZnNldCsrO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVfaWQgPSBkZWNvZGUubnVtYmVyKGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHRoaXMuY29udGV4dC5nZXQodHlwZV9pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZSB8fCBkZWZhdWx0VHlwZTtcbiAgICAgICAgfVxuICAgICAgICBjcmVhdGVJbnN0YW5jZU9mVHlwZSh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHR5cGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVDaGlsZFJlZnMocmVmLCBhbGxDaGFuZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCBuZWVkUmVtb3ZlUmVmID0gdHlwZW9mIChyZWZbJGNoaWxkVHlwZV0pICE9PSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgY29uc3QgcmVmSWQgPSB0aGlzLnJvb3QucmVmSWRzLmdldChyZWYpO1xuICAgICAgICAgICAgcmVmLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBhbGxDaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICByZWY6IHJlZixcbiAgICAgICAgICAgICAgICAgICAgcmVmSWQsXG4gICAgICAgICAgICAgICAgICAgIG9wOiBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBrZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG5lZWRSZW1vdmVSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290LnJlbW92ZVJlZih0aGlzLnJvb3QucmVmSWRzLmdldCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVmbGVjdGlvblxuICAgICAqL1xuICAgIGNsYXNzIFJlZmxlY3Rpb25GaWVsZCBleHRlbmRzIFNjaGVtYSB7XG4gICAgfVxuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0eXBlKFwic3RyaW5nXCIpXG4gICAgXSwgUmVmbGVjdGlvbkZpZWxkLnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHR5cGUoXCJzdHJpbmdcIilcbiAgICBdLCBSZWZsZWN0aW9uRmllbGQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdHlwZShcIm51bWJlclwiKVxuICAgIF0sIFJlZmxlY3Rpb25GaWVsZC5wcm90b3R5cGUsIFwicmVmZXJlbmNlZFR5cGVcIiwgdm9pZCAwKTtcbiAgICBjbGFzcyBSZWZsZWN0aW9uVHlwZSBleHRlbmRzIFNjaGVtYSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuZmllbGRzID0gbmV3IEFycmF5U2NoZW1hKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHR5cGUoXCJudW1iZXJcIilcbiAgICBdLCBSZWZsZWN0aW9uVHlwZS5wcm90b3R5cGUsIFwiaWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdHlwZShcIm51bWJlclwiKVxuICAgIF0sIFJlZmxlY3Rpb25UeXBlLnByb3RvdHlwZSwgXCJleHRlbmRzSWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdHlwZShbUmVmbGVjdGlvbkZpZWxkXSlcbiAgICBdLCBSZWZsZWN0aW9uVHlwZS5wcm90b3R5cGUsIFwiZmllbGRzXCIsIHZvaWQgMCk7XG4gICAgY2xhc3MgUmVmbGVjdGlvbiBleHRlbmRzIFNjaGVtYSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMudHlwZXMgPSBuZXcgQXJyYXlTY2hlbWEoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgVHlwZUNvbnRleHQgb2YgYW4gRW5jb2RlciBpbnRvIGEgYnVmZmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZW5jb2RlciBFbmNvZGVyIGluc3RhbmNlXG4gICAgICAgICAqIEBwYXJhbSBpdFxuICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGVuY29kZShlbmNvZGVyLCBpdCA9IHsgb2Zmc2V0OiAwIH0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBlbmNvZGVyLmNvbnRleHQ7XG4gICAgICAgICAgICBjb25zdCByZWZsZWN0aW9uID0gbmV3IFJlZmxlY3Rpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZmxlY3Rpb25FbmNvZGVyID0gbmV3IEVuY29kZXIocmVmbGVjdGlvbik7XG4gICAgICAgICAgICAvLyByb290VHlwZSBpcyB1c3VhbGx5IHRoZSBmaXJzdCBzY2hlbWEgcGFzc2VkIHRvIHRoZSBFbmNvZGVyXG4gICAgICAgICAgICAvLyAodW5sZXNzIGl0IGluaGVyaXRzIGZyb20gYW5vdGhlciBzY2hlbWEpXG4gICAgICAgICAgICBjb25zdCByb290VHlwZSA9IGNvbnRleHQuc2NoZW1hcy5nZXQoZW5jb2Rlci5zdGF0ZS5jb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICBpZiAocm9vdFR5cGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVmbGVjdGlvbi5yb290VHlwZSA9IHJvb3RUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5jbHVkZWRUeXBlSWRzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgY29uc3QgcGVuZGluZ1JlZmxlY3Rpb25UeXBlcyA9IHt9O1xuICAgICAgICAgICAgLy8gYWRkIHR5cGUgdG8gcmVmbGVjdGlvbiBpbiBhIHdheSB0aGF0IHJlc3BlY3RzIGluaGVyaXRhbmNlXG4gICAgICAgICAgICAvLyAocGFyZW50IHR5cGVzIHNob3VsZCBiZSBhZGRlZCBiZWZvcmUgdGhlaXIgY2hpbGRyZW4pXG4gICAgICAgICAgICBjb25zdCBhZGRUeXBlID0gKHR5cGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5leHRlbmRzSWQgPT09IHVuZGVmaW5lZCB8fCBpbmNsdWRlZFR5cGVJZHMuaGFzKHR5cGUuZXh0ZW5kc0lkKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlZFR5cGVJZHMuYWRkKHR5cGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICByZWZsZWN0aW9uLnR5cGVzLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlcHMgPSBwZW5kaW5nUmVmbGVjdGlvblR5cGVzW3R5cGUuaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVwcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGVuZGluZ1JlZmxlY3Rpb25UeXBlc1t0eXBlLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHMuZm9yRWFjaCgoY2hpbGRUeXBlKSA9PiBhZGRUeXBlKGNoaWxkVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVuZGluZ1JlZmxlY3Rpb25UeXBlc1t0eXBlLmV4dGVuZHNJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1JlZmxlY3Rpb25UeXBlc1t0eXBlLmV4dGVuZHNJZF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUmVmbGVjdGlvblR5cGVzW3R5cGUuZXh0ZW5kc0lkXS5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb250ZXh0LnNjaGVtYXMuZm9yRWFjaCgodHlwZWlkLCBrbGFzcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBuZXcgUmVmbGVjdGlvblR5cGUoKTtcbiAgICAgICAgICAgICAgICB0eXBlLmlkID0gTnVtYmVyKHR5cGVpZCk7XG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydCBpbmhlcml0YW5jZVxuICAgICAgICAgICAgICAgIGNvbnN0IGluaGVyaXRGcm9tID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGtsYXNzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5oZXJpdEZyb20gIT09IFNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlLmV4dGVuZHNJZCA9IGNvbnRleHQuc2NoZW1hcy5nZXQoaW5oZXJpdEZyb20pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGtsYXNzW1N5bWJvbC5tZXRhZGF0YV07XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogdGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIGluaGVyaXRlZCB0eXBlcyB3aXRob3V0IGFkZGl0aW9uYWwgZmllbGRzXG4gICAgICAgICAgICAgICAgLy8gaWYgbWV0YWRhdGEgaXMgdGhlIHNhbWUgcmVmZXJlbmNlIGFzIHRoZSBwYXJlbnQgY2xhc3MgLSBpdCBtZWFucyB0aGUgY2xhc3MgaGFzIG5vIG93biBtZXRhZGF0YVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhICE9PSBpbmhlcml0RnJvbVtTeW1ib2wubWV0YWRhdGFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGRJbmRleCBpbiBtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBOdW1iZXIoZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBtZXRhZGF0YVtpbmRleF0ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNraXAgZmllbGRzIGZyb20gcGFyZW50IGNsYXNzZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1ldGFkYXRhLCBmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZsZWN0aW9uRmllbGQgPSBuZXcgUmVmbGVjdGlvbkZpZWxkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZsZWN0aW9uRmllbGQubmFtZSA9IGZpZWxkTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWVsZFR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IG1ldGFkYXRhW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGZpZWxkLnR5cGUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRUeXBlID0gZmllbGQudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaGlsZFR5cGVTY2hlbWE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiByZWZhY3RvciBiZWxvdy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTY2hlbWEuaXMoZmllbGQudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRUeXBlID0gXCJyZWZcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRUeXBlU2NoZW1hID0gZmllbGQudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkVHlwZSA9IE9iamVjdC5rZXlzKGZpZWxkLnR5cGUpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChmaWVsZC50eXBlW2ZpZWxkVHlwZV0pID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFR5cGUgKz0gXCI6XCIgKyBmaWVsZC50eXBlW2ZpZWxkVHlwZV07IC8vIGFycmF5OnN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRUeXBlU2NoZW1hID0gZmllbGQudHlwZVtmaWVsZFR5cGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmxlY3Rpb25GaWVsZC5yZWZlcmVuY2VkVHlwZSA9IChjaGlsZFR5cGVTY2hlbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY29udGV4dC5nZXRUeXBlSWQoY2hpbGRUeXBlU2NoZW1hKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmbGVjdGlvbkZpZWxkLnR5cGUgPSBmaWVsZFR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlLmZpZWxkcy5wdXNoKHJlZmxlY3Rpb25GaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkVHlwZSh0eXBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGVyZSBhcmUgdHlwZXMgdGhhdCB3ZXJlIG5vdCBhZGRlZCBkdWUgdG8gaW5oZXJpdGFuY2VcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZWlkIGluIHBlbmRpbmdSZWZsZWN0aW9uVHlwZXMpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nUmVmbGVjdGlvblR5cGVzW3R5cGVpZF0uZm9yRWFjaCgodHlwZSkgPT4gcmVmbGVjdGlvbi50eXBlcy5wdXNoKHR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IHJlZmxlY3Rpb25FbmNvZGVyLmVuY29kZUFsbChpdCk7XG4gICAgICAgICAgICByZXR1cm4gYnVmLnNsaWNlKDAsIGl0Lm9mZnNldCk7XG4gICAgICAgICAgICAvLyByZXR1cm4gQnVmZmVyLmZyb20oYnVmLCAwLCBpdC5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIHRoZSBUeXBlQ29udGV4dCBmcm9tIGEgYnVmZmVyIGludG8gYSBEZWNvZGVyIGluc3RhbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYnl0ZXMgUmVmbGVjdGlvbi5lbmNvZGUoKSBvdXRwdXRcbiAgICAgICAgICogQHBhcmFtIGl0XG4gICAgICAgICAqIEByZXR1cm5zIERlY29kZXIgaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWNvZGUoYnl0ZXMsIGl0KSB7XG4gICAgICAgICAgICBjb25zdCByZWZsZWN0aW9uID0gbmV3IFJlZmxlY3Rpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZmxlY3Rpb25EZWNvZGVyID0gbmV3IERlY29kZXIocmVmbGVjdGlvbik7XG4gICAgICAgICAgICByZWZsZWN0aW9uRGVjb2Rlci5kZWNvZGUoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVDb250ZXh0ID0gbmV3IFR5cGVDb250ZXh0KCk7XG4gICAgICAgICAgICAvLyAxc3QgcGFzcywgaW5pdGlhbGl6ZSBtZXRhZGF0YSArIGluaGVyaXRhbmNlXG4gICAgICAgICAgICByZWZsZWN0aW9uLnR5cGVzLmZvckVhY2goKHJlZmxlY3Rpb25UeXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Q2xhc3MgPSB0eXBlQ29udGV4dC5nZXQocmVmbGVjdGlvblR5cGUuZXh0ZW5kc0lkKSA/PyBTY2hlbWE7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gY2xhc3MgXyBleHRlbmRzIHBhcmVudENsYXNzIHtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIHJlZ2lzdGVyIGZvciBpbmhlcml0YW5jZSBzdXBwb3J0XG4gICAgICAgICAgICAgICAgVHlwZUNvbnRleHQucmVnaXN0ZXIoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAvLyAvLyBmb3IgaW5oZXJpdGFuY2Ugc3VwcG9ydFxuICAgICAgICAgICAgICAgIC8vIE1ldGFkYXRhLmluaXRpYWxpemUoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICB0eXBlQ29udGV4dC5hZGQoc2NoZW1hLCByZWZsZWN0aW9uVHlwZS5pZCk7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICAvLyBkZWZpbmUgZmllbGRzXG4gICAgICAgICAgICBjb25zdCBhZGRGaWVsZHMgPSAobWV0YWRhdGEsIHJlZmxlY3Rpb25UeXBlLCBwYXJlbnRGaWVsZEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVmbGVjdGlvblR5cGUuZmllbGRzLmZvckVhY2goKGZpZWxkLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkSW5kZXggPSBwYXJlbnRGaWVsZEluZGV4ICsgaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLnJlZmVyZW5jZWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWVsZFR5cGUgPSBmaWVsZC50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlZlR5cGUgPSB0eXBlQ29udGV4dC5nZXQoZmllbGQucmVmZXJlbmNlZFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFwIG9yIGFycmF5IG9mIHByaW1pdGl2ZSB0eXBlICgtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVmVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVJbmZvID0gZmllbGQudHlwZS5zcGxpdChcIjpcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRUeXBlID0gdHlwZUluZm9bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmVHlwZSA9IHR5cGVJbmZvWzFdOyAvLyBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZFR5cGUgPT09IFwicmVmXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXRhZGF0YS5hZGRGaWVsZChtZXRhZGF0YSwgZmllbGRJbmRleCwgZmllbGQubmFtZSwgcmVmVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXRhZGF0YS5hZGRGaWVsZChtZXRhZGF0YSwgZmllbGRJbmRleCwgZmllbGQubmFtZSwgeyBbZmllbGRUeXBlXTogcmVmVHlwZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1ldGFkYXRhLmFkZEZpZWxkKG1ldGFkYXRhLCBmaWVsZEluZGV4LCBmaWVsZC5uYW1lLCBmaWVsZC50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIDJuZCBwYXNzLCBzZXQgZmllbGRzXG4gICAgICAgICAgICByZWZsZWN0aW9uLnR5cGVzLmZvckVhY2goKHJlZmxlY3Rpb25UeXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gdHlwZUNvbnRleHQuZ2V0KHJlZmxlY3Rpb25UeXBlLmlkKTtcbiAgICAgICAgICAgICAgICAvLyBmb3IgaW5oZXJpdGFuY2Ugc3VwcG9ydFxuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gTWV0YWRhdGEuaW5pdGlhbGl6ZShzY2hlbWEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluaGVyaXRlZFR5cGVzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudFR5cGUgPSByZWZsZWN0aW9uVHlwZTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGluaGVyaXRlZFR5cGVzLnB1c2gocGFyZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFR5cGUgPSByZWZsZWN0aW9uLnR5cGVzLmZpbmQoKHQpID0+IHQuaWQgPT09IHBhcmVudFR5cGUuZXh0ZW5kc0lkKTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50RmllbGRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgaW5oZXJpdGVkVHlwZXMucmV2ZXJzZSgpLmZvckVhY2goKHJlZmxlY3Rpb25UeXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBmaWVsZHMgZnJvbSBhbGwgaW5oZXJpdGVkIGNsYXNzZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogcmVmYWN0b3IgdGhpcyB0byBhdm9pZCBhZGRpbmcgZmllbGRzIGZyb20gcGFyZW50IGNsYXNzZXNcbiAgICAgICAgICAgICAgICAgICAgYWRkRmllbGRzKG1ldGFkYXRhLCByZWZsZWN0aW9uVHlwZSwgcGFyZW50RmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEZpZWxkSW5kZXggKz0gcmVmbGVjdGlvblR5cGUuZmllbGRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBuZXcgKHR5cGVDb250ZXh0LmdldChyZWZsZWN0aW9uLnJvb3RUeXBlIHx8IDApKSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVyKHN0YXRlLCB0eXBlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHR5cGUoW1JlZmxlY3Rpb25UeXBlXSlcbiAgICBdLCBSZWZsZWN0aW9uLnByb3RvdHlwZSwgXCJ0eXBlc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0eXBlKFwibnVtYmVyXCIpXG4gICAgXSwgUmVmbGVjdGlvbi5wcm90b3R5cGUsIFwicm9vdFR5cGVcIiwgdm9pZCAwKTtcblxuICAgIGZ1bmN0aW9uIGdldERlY29kZXJTdGF0ZUNhbGxiYWNrcyhkZWNvZGVyKSB7XG4gICAgICAgIGNvbnN0ICRyb290ID0gZGVjb2Rlci5yb290O1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSAkcm9vdC5jYWxsYmFja3M7XG4gICAgICAgIGNvbnN0IG9uQWRkQ2FsbHMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICBsZXQgY3VycmVudE9uQWRkQ2FsbGJhY2s7XG4gICAgICAgIGRlY29kZXIudHJpZ2dlckNoYW5nZXMgPSBmdW5jdGlvbiAoYWxsQ2hhbmdlcykge1xuICAgICAgICAgICAgY29uc3QgdW5pcXVlUmVmSWRzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhbGxDaGFuZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IGFsbENoYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmSWQgPSBjaGFuZ2UucmVmSWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmID0gY2hhbmdlLnJlZjtcbiAgICAgICAgICAgICAgICBjb25zdCAkY2FsbGJhY2tzID0gY2FsbGJhY2tzW3JlZklkXTtcbiAgICAgICAgICAgICAgICBpZiAoISRjYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlciBvblJlbW92ZSBvbiBjaGlsZCBzdHJ1Y3R1cmUuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBpZiAoKGNoYW5nZS5vcCAmIGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURSkgPT09IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURSAmJlxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UucHJldmlvdXNWYWx1ZSBpbnN0YW5jZW9mIFNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWxldGVDYWxsYmFja3MgPSBjYWxsYmFja3NbJHJvb3QucmVmSWRzLmdldChjaGFuZ2UucHJldmlvdXNWYWx1ZSldPy5bZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGRlbGV0ZUNhbGxiYWNrcz8ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUNhbGxiYWNrc1tpXSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZWYgaW5zdGFuY2VvZiBTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHNjaGVtYSBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXVuaXF1ZVJlZklkcy5oYXMocmVmSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIG9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlQ2FsbGJhY2tzID0gJGNhbGxiYWNrcz8uW2V4cG9ydHMuT1BFUkFUSU9OLlJFUExBQ0VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHJlcGxhY2VDYWxsYmFja3M/Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZUNhbGxiYWNrc1tpXSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoJGNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eShjaGFuZ2UuZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZENhbGxiYWNrcyA9ICRjYWxsYmFja3NbY2hhbmdlLmZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBmaWVsZENhbGxiYWNrcz8ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZENhbGxiYWNrc1tpXShjaGFuZ2UudmFsdWUsIGNoYW5nZS5wcmV2aW91c1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjb2xsZWN0aW9uIG9mIGl0ZW1zXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIGlmICgoY2hhbmdlLm9wICYgZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKSA9PT0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IGBwcmV2aW91c1ZhbHVlYCBzaG91bGQgYWx3YXlzIGJlIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnByZXZpb3VzVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyaWdlciBvblJlbW92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbGV0ZUNhbGxiYWNrcyA9ICRjYWxsYmFja3NbZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gZGVsZXRlQ2FsbGJhY2tzPy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVDYWxsYmFja3NbaV0oY2hhbmdlLnByZXZpb3VzVmFsdWUsIGNoYW5nZS5keW5hbWljSW5kZXggPz8gY2hhbmdlLmZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgREVMRVRFX0FORF9BREQgb3BlcmF0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjaGFuZ2Uub3AgJiBleHBvcnRzLk9QRVJBVElPTi5BREQpID09PSBleHBvcnRzLk9QRVJBVElPTi5BREQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRDYWxsYmFja3MgPSAkY2FsbGJhY2tzW2V4cG9ydHMuT1BFUkFUSU9OLkFERF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGFkZENhbGxiYWNrcz8ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2FsbGJhY2tzW2ldKGNoYW5nZS52YWx1ZSwgY2hhbmdlLmR5bmFtaWNJbmRleCA/PyBjaGFuZ2UuZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgoY2hhbmdlLm9wICYgZXhwb3J0cy5PUEVSQVRJT04uQUREKSA9PT0gZXhwb3J0cy5PUEVSQVRJT04uQUREICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UucHJldmlvdXNWYWx1ZSAhPT0gY2hhbmdlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZXIgb25BZGRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZENhbGxiYWNrcyA9ICRjYWxsYmFja3NbZXhwb3J0cy5PUEVSQVRJT04uQUREXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBhZGRDYWxsYmFja3M/Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2FsbGJhY2tzW2ldKGNoYW5nZS52YWx1ZSwgY2hhbmdlLmR5bmFtaWNJbmRleCA/PyBjaGFuZ2UuZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgb25DaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS52YWx1ZSAhPT0gY2hhbmdlLnByZXZpb3VzVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBzZWUgXCJzaG91bGQgbm90IGVuY29kZSBpdGVtIGlmIGFkZGVkIGFuZCByZW1vdmVkIGF0IHRoZSBzYW1lIHBhdGNoXCIgdGVzdCBjYXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc29tZSBcIkFERFwiICsgXCJERUxFVEVcIiBvcGVyYXRpb25zIG9uIHNhbWUgcGF0Y2ggYXJlIGJlaW5nIGVuY29kZWQgYXMgXCJERUxFVEVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKGNoYW5nZS52YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGNoYW5nZS5wcmV2aW91c1ZhbHVlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlQ2FsbGJhY2tzID0gJGNhbGxiYWNrc1tleHBvcnRzLk9QRVJBVElPTi5SRVBMQUNFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSByZXBsYWNlQ2FsbGJhY2tzPy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDYWxsYmFja3NbaV0oY2hhbmdlLnZhbHVlLCBjaGFuZ2UuZHluYW1pY0luZGV4ID8/IGNoYW5nZS5maWVsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5pcXVlUmVmSWRzLmFkZChyZWZJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGdldFByb3h5KG1ldGFkYXRhT3JUeXBlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBsZXQgbWV0YWRhdGEgPSBjb250ZXh0Lmluc3RhbmNlPy5jb25zdHJ1Y3RvcltTeW1ib2wubWV0YWRhdGFdIHx8IG1ldGFkYXRhT3JUeXBlO1xuICAgICAgICAgICAgbGV0IGlzQ29sbGVjdGlvbiA9ICgoY29udGV4dC5pbnN0YW5jZSAmJiB0eXBlb2YgKGNvbnRleHQuaW5zdGFuY2VbJ2ZvckVhY2gnXSkgPT09IFwiZnVuY3Rpb25cIikgfHxcbiAgICAgICAgICAgICAgICAobWV0YWRhdGFPclR5cGUgJiYgdHlwZW9mIChtZXRhZGF0YU9yVHlwZVtTeW1ib2wubWV0YWRhdGFdKSA9PT0gXCJ1bmRlZmluZWRcIikpO1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhICYmICFpc0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbkFkZExpc3RlbiA9IGZ1bmN0aW9uIChyZWYsIHByb3AsIGNhbGxiYWNrLCBpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW1tZWRpYXRlIHRyaWdnZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltbWVkaWF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5pbnN0YW5jZVtwcm9wXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhb25BZGRDYWxscy5oYXMoY3VycmVudE9uQWRkQ2FsbGJhY2spIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2x5c2V1cy9zY2hlbWEvaXNzdWVzLzE0N1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGNvbnRleHQuaW5zdGFuY2VbcHJvcF0sIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRyb290LmFkZENhbGxiYWNrKCRyb290LnJlZklkcy5nZXQocmVmKSwgcHJvcCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU2NoZW1hIGluc3RhbmNlc1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJveHkoe1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3Rlbihwcm9wLCBjYWxsYmFjaywgaW1tZWRpYXRlID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25BZGRMaXN0ZW4oY29udGV4dC5pbnN0YW5jZSwgcHJvcCwgY2FsbGJhY2ssIGltbWVkaWF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb2xsZWN0aW9uIGluc3RhbmNlIG5vdCByZWNlaXZlZCB5ZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGV0YWNoQ2FsbGJhY2sgPSAoKSA9PiB7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkluc3RhbmNlQXZhaWxhYmxlKChyZWYsIGV4aXN0aW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFjaENhbGxiYWNrID0gb25BZGRMaXN0ZW4ocmVmLCBwcm9wLCBjYWxsYmFjaywgaW1tZWRpYXRlICYmIGV4aXN0aW5nICYmICFvbkFkZENhbGxzLmhhcyhjdXJyZW50T25BZGRDYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBkZXRhY2hDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkcm9vdC5hZGRDYWxsYmFjaygkcm9vdC5yZWZJZHMuZ2V0KGNvbnRleHQuaW5zdGFuY2UpLCBleHBvcnRzLk9QRVJBVElPTi5SRVBMQUNFLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIGBiaW5kVG8oKWAgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIHJvb20gZm9yIGltcHJvdmVtZW50LlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICBiaW5kVG86IGZ1bmN0aW9uIGJpbmRUbyh0YXJnZXRPYmplY3QsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhtZXRhZGF0YSkubWFwKChpbmRleCkgPT4gbWV0YWRhdGFbaW5kZXhdLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRyb290LmFkZENhbGxiYWNrKCRyb290LnJlZklkcy5nZXQoY29udGV4dC5pbnN0YW5jZSksIGV4cG9ydHMuT1BFUkFUSU9OLlJFUExBQ0UsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goKHByb3ApID0+IHRhcmdldE9iamVjdFtwcm9wXSA9IGNvbnRleHQuaW5zdGFuY2VbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhRmllbGQgPSBtZXRhZGF0YVttZXRhZGF0YVtwcm9wXV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gY29udGV4dC5pbnN0YW5jZT8uW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uSW5zdGFuY2VBdmFpbGFibGUgPSAoKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVuYmluZCA9ICQoY29udGV4dC5pbnN0YW5jZSkubGlzdGVuKHByb3AsICh2YWx1ZSwgXykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBieSBcInVuYmluZGluZ1wiIHRoZSBjYWxsYmFjayBoZXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgd2lsbCBub3Qgc3VwcG9ydCB3aGVuIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlLWluc3RhbnRpYXRlcyB0aGUgaW5zdGFuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5iaW5kPy4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoYXMgZXhpc3RpbmcgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRyb290LnJlZklkcy5nZXQoaW5zdGFuY2UpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGluc3RhbmNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm94eShtZXRhZGF0YUZpZWxkLnR5cGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHJlZklkIGlzIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIGluc3RhbmNlIHRvIGJlIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6ICgkcm9vdC5yZWZJZHMuZ2V0KGluc3RhbmNlKSAmJiBpbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEluc3RhbmNlOiBjb250ZXh0Lmluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkluc3RhbmNlQXZhaWxhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWNjZXNzaW5nIHRoZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGhhcyh0YXJnZXQsIHByb3ApIHsgcmV0dXJuIG1ldGFkYXRhW3Byb3BdICE9PSB1bmRlZmluZWQ7IH0sXG4gICAgICAgICAgICAgICAgICAgIHNldChfLCBfMSwgXzIpIHsgdGhyb3cgbmV3IEVycm9yKFwibm90IGFsbG93ZWRcIik7IH0sXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KF8sIF8xKSB7IHRocm93IG5ldyBFcnJvcihcIm5vdCBhbGxvd2VkXCIpOyB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ29sbGVjdGlvbiBpbnN0YW5jZXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25zdCBvbkFkZCA9IGZ1bmN0aW9uIChyZWYsIGNhbGxiYWNrLCBpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBjYWxsYmFjayBvbiBleGlzdGluZyBpdGVtc1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWYuZm9yRWFjaCgodiwgaykgPT4gY2FsbGJhY2sodiwgaykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcm9vdC5hZGRDYWxsYmFjaygkcm9vdC5yZWZJZHMuZ2V0KHJlZiksIGV4cG9ydHMuT1BFUkFUSU9OLkFERCwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQWRkQ2FsbHMuc2V0KGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPbkFkZENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh2YWx1ZSwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQWRkQ2FsbHMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPbkFkZENhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uUmVtb3ZlID0gZnVuY3Rpb24gKHJlZiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRyb290LmFkZENhbGxiYWNrKCRyb290LnJlZklkcy5nZXQocmVmKSwgZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBvbkNoYW5nZSA9IGZ1bmN0aW9uIChyZWYsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcm9vdC5hZGRDYWxsYmFjaygkcm9vdC5yZWZJZHMuZ2V0KHJlZiksIGV4cG9ydHMuT1BFUkFUSU9OLlJFUExBQ0UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJveHkoe1xuICAgICAgICAgICAgICAgICAgICBvbkFkZDogZnVuY3Rpb24gKGNhbGxiYWNrLCBpbW1lZGlhdGUgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvbHlzZXVzL3NjaGVtYS9pc3N1ZXMvMTQ3XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwYXJlbnQgaW5zdGFuY2UgaGFzIFwib25BZGRcIiByZWdpc3RlcmVkLCBhdm9pZCB0cmlnZ2VyaW5nIGltbWVkaWF0ZSBjYWxsYmFjay5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvbkFkZChjb250ZXh0Lmluc3RhbmNlLCBjYWxsYmFjaywgaW1tZWRpYXRlICYmICFvbkFkZENhbGxzLmhhcyhjdXJyZW50T25BZGRDYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGV4dC5vbkluc3RhbmNlQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29sbGVjdGlvbiBpbnN0YW5jZSBub3QgcmVjZWl2ZWQgeWV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRldGFjaENhbGxiYWNrID0gKCkgPT4geyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25JbnN0YW5jZUF2YWlsYWJsZSgocmVmLCBleGlzdGluZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhY2hDYWxsYmFjayA9IG9uQWRkKHJlZiwgY2FsbGJhY2ssIGltbWVkaWF0ZSAmJiBleGlzdGluZyAmJiAhb25BZGRDYWxscy5oYXMoY3VycmVudE9uQWRkQ2FsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gZGV0YWNoQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25SZW1vdmU6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25SZW1vdmUoY29udGV4dC5pbnN0YW5jZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGV4dC5vbkluc3RhbmNlQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29sbGVjdGlvbiBpbnN0YW5jZSBub3QgcmVjZWl2ZWQgeWV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRldGFjaENhbGxiYWNrID0gKCkgPT4geyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25JbnN0YW5jZUF2YWlsYWJsZSgocmVmKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFjaENhbGxiYWNrID0gb25SZW1vdmUocmVmLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGRldGFjaENhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0Lmluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uQ2hhbmdlKGNvbnRleHQuaW5zdGFuY2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRleHQub25JbnN0YW5jZUF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbGxlY3Rpb24gaW5zdGFuY2Ugbm90IHJlY2VpdmVkIHlldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkZXRhY2hDYWxsYmFjayA9ICgpID0+IHsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uSW5zdGFuY2VBdmFpbGFibGUoKHJlZikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhY2hDYWxsYmFjayA9IG9uQ2hhbmdlKHJlZiwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBkZXRhY2hDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGFjY2VzcyAnJHtwcm9wfScgdGhyb3VnaCBjYWxsYmFjayBwcm94eS4gYWNjZXNzIHRoZSBpbnN0YW5jZSBkaXJlY3RseS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGhhcyh0YXJnZXQsIHByb3ApIHsgcmV0dXJuIHRhcmdldFtwcm9wXSAhPT0gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgICAgICBzZXQoXywgXzEsIF8yKSB7IHRocm93IG5ldyBFcnJvcihcIm5vdCBhbGxvd2VkXCIpOyB9LFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eShfLCBfMSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJub3QgYWxsb3dlZFwiKTsgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiAkKGluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UHJveHkodW5kZWZpbmVkLCB7IGluc3RhbmNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFJhd0NoYW5nZXNDYWxsYmFjayhkZWNvZGVyLCBjYWxsYmFjaykge1xuICAgICAgICBkZWNvZGVyLnRyaWdnZXJDaGFuZ2VzID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgY2xhc3MgU3RhdGVWaWV3IHtcbiAgICAgICAgY29uc3RydWN0b3IoaXRlcmFibGUgPSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5pdGVyYWJsZSA9IGl0ZXJhYmxlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMaXN0IG9mIENoYW5nZVRyZWUncyB0aGF0IGFyZSB2aXNpYmxlIHRvIHRoaXMgdmlld1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnZpc2libGUgPSBuZXcgV2Vha1NldCgpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMaXN0IG9mIENoYW5nZVRyZWUncyB0aGF0IGFyZSBpbnZpc2libGUgdG8gdGhpcyB2aWV3XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaW52aXNpYmxlID0gbmV3IFdlYWtTZXQoKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWFudWFsIFwiQUREXCIgb3BlcmF0aW9ucyBmb3IgY2hhbmdlcyBwZXIgQ2hhbmdlVHJlZSwgc3BlY2lmaWMgdG8gdGhpcyB2aWV3LlxuICAgICAgICAgICAgICogKFRoaXMgaXMgdXNlZCB0byBmb3JjZSBlbmNvZGluZyBhIHByb3BlcnR5LCBldmVuIGlmIGl0IHdhcyBub3QgY2hhbmdlZClcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IGFsbG93IHRvIHNldCBtdWx0aXBsZSB0YWdzIGF0IG9uY2VcbiAgICAgICAgYWRkKG9iaiwgdGFnID0gREVGQVVMVF9WSUVXX1RBRywgY2hlY2tJbmNsdWRlUGFyZW50ID0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IG9iaj8uWyRjaGFuZ2VzXTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudENoYW5nZVRyZWUgPSBjaGFuZ2VUcmVlLnBhcmVudDtcbiAgICAgICAgICAgIGlmICghY2hhbmdlVHJlZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlN0YXRlVmlldyNhZGQoKSwgaW52YWxpZCBvYmplY3Q6XCIsIG9iaik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXBhcmVudENoYW5nZVRyZWUgJiZcbiAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlLnJlZklkICE9PSAwIC8vIGFsbG93IHJvb3Qgb2JqZWN0XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUT0RPOiBjYW4gd2UgYXZvaWQgdGhpcz9cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIFdoZW4gdGhlIFwicGFyZW50XCIgc3RydWN0dXJlIGhhcyB0aGUgQHZpZXcoKSB0YWcsIGl0IGlzIGN1cnJlbnRseVxuICAgICAgICAgICAgICAgICAqIG5vdCBwb3NzaWJsZSB0byBpZGVudGlmeSBpdCBoYXMgdG8gYmUgYWRkZWQgdG8gdGhlIHZpZXcgYXMgd2VsbFxuICAgICAgICAgICAgICAgICAqICh0aGlzLmFkZFBhcmVudE9mKCkgaXMgbm90IGNhbGxlZCkuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgYWRkIGEgZGV0YWNoZWQgaW5zdGFuY2UgdG8gdGhlIFN0YXRlVmlldy4gTWFrZSBzdXJlIHRvIGFzc2lnbiB0aGUgXCIke2NoYW5nZVRyZWUucmVmLmNvbnN0cnVjdG9yLm5hbWV9XCIgaW5zdGFuY2UgdG8gdGhlIHN0YXRlIGJlZm9yZSBjYWxsaW5nIHZpZXcuYWRkKClgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZJWE1FOiBBcnJheVNjaGVtYS9NYXBTY2hlbWEgZG8gbm90IGhhdmUgbWV0YWRhdGFcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gb2JqLmNvbnN0cnVjdG9yW1N5bWJvbC5tZXRhZGF0YV07XG4gICAgICAgICAgICB0aGlzLnZpc2libGUuYWRkKGNoYW5nZVRyZWUpO1xuICAgICAgICAgICAgLy8gYWRkIHRvIGl0ZXJhYmxlIGxpc3QgKG9ubHkgdGhlIGV4cGxpY2l0bHkgYWRkZWQgaXRlbXMpXG4gICAgICAgICAgICBpZiAodGhpcy5pdGVyYWJsZSAmJiBjaGVja0luY2x1ZGVQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2gob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCBwYXJlbnQgQ2hhbmdlVHJlZSdzXG4gICAgICAgICAgICAvLyAtIGlmIGl0IHdhcyBpbnZpc2libGUgdG8gdGhpcyB2aWV3XG4gICAgICAgICAgICAvLyAtIGlmIGl0IHdlcmUgcHJldmlvdXNseSBmaWx0ZXJlZCBvdXRcbiAgICAgICAgICAgIGlmIChjaGVja0luY2x1ZGVQYXJlbnQgJiYgcGFyZW50Q2hhbmdlVHJlZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkUGFyZW50T2YoY2hhbmdlVHJlZSwgdGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaGFuZ2VzID0gdGhpcy5jaGFuZ2VzLmdldChjaGFuZ2VUcmVlLnJlZklkKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzID0ge307XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgLyBPUFRJTUlaRTogZG8gbm90IGFkZCBpZiBubyBjaGFuZ2VzIGFyZSBuZWVkZWRcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZXMuc2V0KGNoYW5nZVRyZWUucmVmSWQsIGNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGlzQ2hpbGRBZGRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEFkZCBjaGlsZHJlbiBvZiB0aGlzIENoYW5nZVRyZWUgZmlyc3QuXG4gICAgICAgICAgICAvLyBJZiBzdWNjZXNzZnVsLCB3ZSBtdXN0IGxpbmsgdGhlIGN1cnJlbnQgQ2hhbmdlVHJlZSB0byB0aGUgY2hpbGQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgY2hhbmdlVHJlZS5mb3JFYWNoQ2hpbGQoKGNoYW5nZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgQUREIGNoaWxkcmVuIHRoYXQgZG9uJ3QgaGF2ZSB0aGUgc2FtZSB0YWdcbiAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEgJiZcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFbaW5kZXhdLnRhZyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhW2luZGV4XS50YWcgIT09IHRhZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFkZChjaGFuZ2UucmVmLCB0YWcsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICBpc0NoaWxkQWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gc2V0IHRhZ1xuICAgICAgICAgICAgaWYgKHRhZyAhPT0gREVGQVVMVF9WSUVXX1RBRykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy50YWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFncyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCB0YWdzO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy50YWdzLmhhcyhjaGFuZ2VUcmVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0YWdzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ3Muc2V0KGNoYW5nZVRyZWUsIHRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFncyA9IHRoaXMudGFncy5nZXQoY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhZ3MuYWRkKHRhZyk7XG4gICAgICAgICAgICAgICAgLy8gUmVmOiBhZGQgdGFnZ2VkIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICBtZXRhZGF0YT8uWyRmaWVsZEluZGV4ZXNCeVZpZXdUYWddPy5bdGFnXT8uZm9yRWFjaCgoaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZVRyZWUuZ2V0Q2hhbmdlKGluZGV4KSAhPT0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzW2luZGV4XSA9IGV4cG9ydHMuT1BFUkFUSU9OLkFERDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWNoYW5nZVRyZWUuaXNOZXcgfHwgaXNDaGlsZEFkZGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gbmV3IHN0cnVjdHVyZXMgd2lsbCBiZSBhZGRlZCBhcyBwYXJ0IG9mIC5lbmNvZGUoKSBjYWxsLCBubyBuZWVkIHRvIGZvcmNlIGl0IHRvIC5lbmNvZGVWaWV3KClcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VTZXQgPSAoY2hhbmdlVHJlZS5maWx0ZXJlZENoYW5nZXMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgPyBjaGFuZ2VUcmVlLmFsbEZpbHRlcmVkQ2hhbmdlc1xuICAgICAgICAgICAgICAgICAgICA6IGNoYW5nZVRyZWUuYWxsQ2hhbmdlcztcbiAgICAgICAgICAgICAgICBjb25zdCBpc0ludmlzaWJsZSA9IHRoaXMuaW52aXNpYmxlLmhhcyhjaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2hhbmdlU2V0Lm9wZXJhdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjaGFuZ2VTZXQub3BlcmF0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9IC8vIHNraXAgXCJ1bmRlZmluZWRcIiBpbmRleGVzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wID0gY2hhbmdlVHJlZS5pbmRleGVkT3BlcmF0aW9uc1tpbmRleF0gPz8gZXhwb3J0cy5PUEVSQVRJT04uQUREO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWdBdEluZGV4ID0gbWV0YWRhdGE/LltpbmRleF0udGFnO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3AgIT09IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGlzSW52aXNpYmxlIHx8IC8vIGlmIFwiaW52aXNpYmxlXCIsIGluY2x1ZGUgYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnQXRJbmRleCA9PT0gdW5kZWZpbmVkIHx8IC8vIFwiYWxsIGNoYW5nZVwiIHdpdGggbm8gdGFnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnQXRJbmRleCA9PT0gdGFnIC8vIHRhZ2dlZCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlc1tpbmRleF0gPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ2hpbGRBZGRlZCA9IHRydWU7IC8vIEZJWE1FOiBhc3NpZ24gb25seSBvbmNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNDaGlsZEFkZGVkO1xuICAgICAgICB9XG4gICAgICAgIGFkZFBhcmVudE9mKGNoaWxkQ2hhbmdlVHJlZSwgdGFnKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VUcmVlID0gY2hpbGRDaGFuZ2VUcmVlLnBhcmVudFskY2hhbmdlc107XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRJbmRleCA9IGNoaWxkQ2hhbmdlVHJlZS5wYXJlbnRJbmRleDtcbiAgICAgICAgICAgIGlmICghdGhpcy52aXNpYmxlLmhhcyhjaGFuZ2VUcmVlKSkge1xuICAgICAgICAgICAgICAgIC8vIHZpZXcgbXVzdCBoYXZlIGFsbCBcImNoYW5nZVRyZWVcIiBwYXJlbnQgdHJlZVxuICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZS5hZGQoY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICAgICAgLy8gYWRkIHBhcmVudCdzIHBhcmVudFxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudENoYW5nZVRyZWUgPSBjaGFuZ2VUcmVlLnBhcmVudD8uWyRjaGFuZ2VzXTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Q2hhbmdlVHJlZSAmJiAocGFyZW50Q2hhbmdlVHJlZS5maWx0ZXJlZENoYW5nZXMgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRQYXJlbnRPZihjaGFuZ2VUcmVlLCB0YWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAvLyBwYXJlbnQgaXMgYWxyZWFkeSBhdmFpbGFibGUsIG5vIG5lZWQgdG8gYWRkIGl0IVxuICAgICAgICAgICAgICAgIC8vIGlmICghdGhpcy5pbnZpc2libGUuaGFzKGNoYW5nZVRyZWUpKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIHBhcmVudCdzIHRhZyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBpZiAoY2hhbmdlVHJlZS5nZXRDaGFuZ2UocGFyZW50SW5kZXgpICE9PSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hhbmdlcyA9IHRoaXMuY2hhbmdlcy5nZXQoY2hhbmdlVHJlZS5yZWZJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzID0ge307XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5zZXQoY2hhbmdlVHJlZS5yZWZJZCwgY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy50YWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFncyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCB0YWdzO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy50YWdzLmhhcyhjaGFuZ2VUcmVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0YWdzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ3Muc2V0KGNoYW5nZVRyZWUsIHRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFncyA9IHRoaXMudGFncy5nZXQoY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhZ3MuYWRkKHRhZyk7XG4gICAgICAgICAgICAgICAgY2hhbmdlc1twYXJlbnRJbmRleF0gPSBleHBvcnRzLk9QRVJBVElPTi5BREQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlKG9iaiwgdGFnID0gREVGQVVMVF9WSUVXX1RBRywgX2lzQ2xlYXIgPSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IG9ialskY2hhbmdlc107XG4gICAgICAgICAgICBpZiAoIWNoYW5nZVRyZWUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJTdGF0ZVZpZXcjcmVtb3ZlKCksIGludmFsaWQgb2JqZWN0OlwiLCBvYmopO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52aXNpYmxlLmRlbGV0ZShjaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIGl0ZXJhYmxlIGxpc3RcbiAgICAgICAgICAgIGlmICh0aGlzLml0ZXJhYmxlICYmXG4gICAgICAgICAgICAgICAgIV9pc0NsZWFyIC8vIG5vIG5lZWQgdG8gcmVtb3ZlIGR1cmluZyBjbGVhcigpLCBhcyBpdCB3aWxsIGJlIGNsZWFyZWQgZW50aXJlbHlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHNwbGljZU9uZSh0aGlzLml0ZW1zLCB0aGlzLml0ZW1zLmluZGV4T2Yob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWYgPSBjaGFuZ2VUcmVlLnJlZjtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gcmVmLmNvbnN0cnVjdG9yW1N5bWJvbC5tZXRhZGF0YV07IC8vIEFycmF5U2NoZW1hL01hcFNjaGVtYSBkbyBub3QgaGF2ZSBtZXRhZGF0YVxuICAgICAgICAgICAgbGV0IGNoYW5nZXMgPSB0aGlzLmNoYW5nZXMuZ2V0KGNoYW5nZVRyZWUucmVmSWQpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMgPSB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZXMuc2V0KGNoYW5nZVRyZWUucmVmSWQsIGNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhZyA9PT0gREVGQVVMVF9WSUVXX1RBRykge1xuICAgICAgICAgICAgICAgIC8vIHBhcmVudCBpcyBjb2xsZWN0aW9uIChNYXAvQXJyYXkpXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gY2hhbmdlVHJlZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiAhTWV0YWRhdGEuaXNWYWxpZEluc3RhbmNlKHBhcmVudCkgJiYgY2hhbmdlVHJlZS5pc0ZpbHRlcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudENoYW5nZVRyZWUgPSBwYXJlbnRbJGNoYW5nZXNdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hhbmdlcyA9IHRoaXMuY2hhbmdlcy5nZXQocGFyZW50Q2hhbmdlVHJlZS5yZWZJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5zZXQocGFyZW50Q2hhbmdlVHJlZS5yZWZJZCwgY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhbmdlc1tjaGFuZ2VUcmVlLnBhcmVudEluZGV4XSA9PT0gZXhwb3J0cy5PUEVSQVRJT04uQUREKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU0FNRSBQQVRDSCBBREQgKyBSRU1PVkU6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgJ2NoYW5nZXMnIG9mIGRlbGV0ZWQgc3RydWN0dXJlIHNob3VsZCBiZSBpZ25vcmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5kZWxldGUoY2hhbmdlVHJlZS5yZWZJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gREVMRVRFIC8gREVMRVRFIEJZIFJFRiBJRFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzW2NoYW5nZVRyZWUucGFyZW50SW5kZXhdID0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgY2hpbGQgc2NoZW1hIGZyb20gdmlzaWJsZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVjdXJzaXZlRGVsZXRlVmlzaWJsZUNoYW5nZVRyZWUoY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGUgYWxsIFwidGFnZ2VkXCIgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE/Llskdmlld0ZpZWxkSW5kZXhlc10/LmZvckVhY2goKGluZGV4KSA9PiBjaGFuZ2VzW2luZGV4XSA9IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIG9ubHkgdGFnZ2VkIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICBtZXRhZGF0YT8uWyRmaWVsZEluZGV4ZXNCeVZpZXdUYWddW3RhZ10uZm9yRWFjaCgoaW5kZXgpID0+IGNoYW5nZXNbaW5kZXhdID0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0YWdcbiAgICAgICAgICAgIGlmICh0aGlzLnRhZ3MgJiYgdGhpcy50YWdzLmhhcyhjaGFuZ2VUcmVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ3MgPSB0aGlzLnRhZ3MuZ2V0KGNoYW5nZVRyZWUpO1xuICAgICAgICAgICAgICAgIGlmICh0YWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGUgYWxsIHRhZ3NcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdzLmRlbGV0ZShjaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBzcGVjaWZpYyB0YWdcbiAgICAgICAgICAgICAgICAgICAgdGFncy5kZWxldGUodGFnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGFnIHNldCBpcyBlbXB0eSwgZGVsZXRlIGl0IGVudGlyZWx5XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFncy5kZWxldGUoY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBoYXMob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlLmhhcyhvYmpbJGNoYW5nZXNdKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNUYWcob2IsIHRhZyA9IERFRkFVTFRfVklFV19UQUcpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZ3MgPSB0aGlzLnRhZ3M/LmdldChvYlskY2hhbmdlc10pO1xuICAgICAgICAgICAgcmV0dXJuIHRhZ3M/Lmhhcyh0YWcpID8/IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLml0ZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGVWaWV3I2NsZWFyKCkgaXMgb25seSBhdmFpbGFibGUgZm9yIGl0ZXJhYmxlIFN0YXRlVmlldydzLiBVc2UgU3RhdGVWaWV3KGl0ZXJhYmxlOiB0cnVlKSBjb25zdHJ1Y3Rvci5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUodGhpcy5pdGVtc1tpXSwgREVGQVVMVF9WSUVXX1RBRywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjbGVhciBpdGVtcyBhcnJheVxuICAgICAgICAgICAgdGhpcy5pdGVtcy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlzQ2hhbmdlVHJlZVZpc2libGUoY2hhbmdlVHJlZSkge1xuICAgICAgICAgICAgbGV0IGlzVmlzaWJsZSA9IHRoaXMudmlzaWJsZS5oYXMoY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVE9ETzogYXZvaWQgY2hlY2tpbmcgZm9yIHBhcmVudCB2aXNpYmlsaXR5LCBtb3N0IG9mIHRoZSB0aW1lIGl0J3Mgbm90IG5lZWRlZFxuICAgICAgICAgICAgLy8gU2VlIHRlc3QgY2FzZTogJ3Nob3VsZCBub3QgYmUgcmVxdWlyZWQgdG8gbWFudWFsbHkgY2FsbCB2aWV3LmFkZCgpIGl0ZW1zIHRvIGNoaWxkIGFycmF5cyB3aXRob3V0IEB2aWV3KCkgdGFnJ1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGlmICghaXNWaXNpYmxlICYmIGNoYW5nZVRyZWUuaXNWaXNpYmlsaXR5U2hhcmVkV2l0aFBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiQ0hFQ0sgQUdBSU5TVCBQQVJFTlQuLi5cIiwge1xuICAgICAgICAgICAgICAgIC8vICAgICByZWY6IGNoYW5nZVRyZWUucmVmLmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAgICAgICAgICAgLy8gICAgIHJlZklkOiBjaGFuZ2VUcmVlLnJlZklkLFxuICAgICAgICAgICAgICAgIC8vICAgICBwYXJlbnQ6IGNoYW5nZVRyZWUucGFyZW50LmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAgICAgICAgICAgLy8gfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmlzaWJsZS5oYXMoY2hhbmdlVHJlZS5wYXJlbnRbJGNoYW5nZXNdKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2libGUuYWRkKGNoYW5nZVRyZWUpO1xuICAgICAgICAgICAgICAgICAgICBpc1Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1Zpc2libGU7XG4gICAgICAgIH1cbiAgICAgICAgX3JlY3Vyc2l2ZURlbGV0ZVZpc2libGVDaGFuZ2VUcmVlKGNoYW5nZVRyZWUpIHtcbiAgICAgICAgICAgIGNoYW5nZVRyZWUuZm9yRWFjaENoaWxkKChjaGlsZENoYW5nZVRyZWUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2libGUuZGVsZXRlKGNoaWxkQ2hhbmdlVHJlZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdXJzaXZlRGVsZXRlVmlzaWJsZUNoYW5nZVRyZWUoY2hpbGRDaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJUeXBlKFwibWFwXCIsIHsgY29uc3RydWN0b3I6IE1hcFNjaGVtYSB9KTtcbiAgICByZWdpc3RlclR5cGUoXCJhcnJheVwiLCB7IGNvbnN0cnVjdG9yOiBBcnJheVNjaGVtYSB9KTtcbiAgICByZWdpc3RlclR5cGUoXCJzZXRcIiwgeyBjb25zdHJ1Y3RvcjogU2V0U2NoZW1hIH0pO1xuICAgIHJlZ2lzdGVyVHlwZShcImNvbGxlY3Rpb25cIiwgeyBjb25zdHJ1Y3RvcjogQ29sbGVjdGlvblNjaGVtYSwgfSk7XG5cbiAgICBleHBvcnRzLiRjaGFuZ2VzID0gJGNoYW5nZXM7XG4gICAgZXhwb3J0cy4kY2hpbGRUeXBlID0gJGNoaWxkVHlwZTtcbiAgICBleHBvcnRzLiRkZWNvZGVyID0gJGRlY29kZXI7XG4gICAgZXhwb3J0cy4kZGVsZXRlQnlJbmRleCA9ICRkZWxldGVCeUluZGV4O1xuICAgIGV4cG9ydHMuJGVuY29kZXIgPSAkZW5jb2RlcjtcbiAgICBleHBvcnRzLiRmaWx0ZXIgPSAkZmlsdGVyO1xuICAgIGV4cG9ydHMuJGdldEJ5SW5kZXggPSAkZ2V0QnlJbmRleDtcbiAgICBleHBvcnRzLiR0cmFjayA9ICR0cmFjaztcbiAgICBleHBvcnRzLkFycmF5U2NoZW1hID0gQXJyYXlTY2hlbWE7XG4gICAgZXhwb3J0cy5DaGFuZ2VUcmVlID0gQ2hhbmdlVHJlZTtcbiAgICBleHBvcnRzLkNvbGxlY3Rpb25TY2hlbWEgPSBDb2xsZWN0aW9uU2NoZW1hO1xuICAgIGV4cG9ydHMuRGVjb2RlciA9IERlY29kZXI7XG4gICAgZXhwb3J0cy5FbmNvZGVyID0gRW5jb2RlcjtcbiAgICBleHBvcnRzLk1hcFNjaGVtYSA9IE1hcFNjaGVtYTtcbiAgICBleHBvcnRzLk1ldGFkYXRhID0gTWV0YWRhdGE7XG4gICAgZXhwb3J0cy5SZWZsZWN0aW9uID0gUmVmbGVjdGlvbjtcbiAgICBleHBvcnRzLlJlZmxlY3Rpb25GaWVsZCA9IFJlZmxlY3Rpb25GaWVsZDtcbiAgICBleHBvcnRzLlJlZmxlY3Rpb25UeXBlID0gUmVmbGVjdGlvblR5cGU7XG4gICAgZXhwb3J0cy5TY2hlbWEgPSBTY2hlbWE7XG4gICAgZXhwb3J0cy5TZXRTY2hlbWEgPSBTZXRTY2hlbWE7XG4gICAgZXhwb3J0cy5TdGF0ZVZpZXcgPSBTdGF0ZVZpZXc7XG4gICAgZXhwb3J0cy5UeXBlQ29udGV4dCA9IFR5cGVDb250ZXh0O1xuICAgIGV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuICAgIGV4cG9ydHMuZGVjb2RlS2V5VmFsdWVPcGVyYXRpb24gPSBkZWNvZGVLZXlWYWx1ZU9wZXJhdGlvbjtcbiAgICBleHBvcnRzLmRlY29kZVNjaGVtYU9wZXJhdGlvbiA9IGRlY29kZVNjaGVtYU9wZXJhdGlvbjtcbiAgICBleHBvcnRzLmRlZmluZUN1c3RvbVR5cGVzID0gZGVmaW5lQ3VzdG9tVHlwZXM7XG4gICAgZXhwb3J0cy5kZWZpbmVUeXBlcyA9IGRlZmluZVR5cGVzO1xuICAgIGV4cG9ydHMuZGVwcmVjYXRlZCA9IGRlcHJlY2F0ZWQ7XG4gICAgZXhwb3J0cy5kdW1wQ2hhbmdlcyA9IGR1bXBDaGFuZ2VzO1xuICAgIGV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuICAgIGV4cG9ydHMuZW5jb2RlQXJyYXkgPSBlbmNvZGVBcnJheTtcbiAgICBleHBvcnRzLmVuY29kZUtleVZhbHVlT3BlcmF0aW9uID0gZW5jb2RlS2V5VmFsdWVPcGVyYXRpb247XG4gICAgZXhwb3J0cy5lbmNvZGVTY2hlbWFPcGVyYXRpb24gPSBlbmNvZGVTY2hlbWFPcGVyYXRpb247XG4gICAgZXhwb3J0cy5lbnRpdHkgPSBlbnRpdHk7XG4gICAgZXhwb3J0cy5nZXREZWNvZGVyU3RhdGVDYWxsYmFja3MgPSBnZXREZWNvZGVyU3RhdGVDYWxsYmFja3M7XG4gICAgZXhwb3J0cy5nZXRSYXdDaGFuZ2VzQ2FsbGJhY2sgPSBnZXRSYXdDaGFuZ2VzQ2FsbGJhY2s7XG4gICAgZXhwb3J0cy5yZWdpc3RlclR5cGUgPSByZWdpc3RlclR5cGU7XG4gICAgZXhwb3J0cy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgZXhwb3J0cy50eXBlID0gdHlwZTtcbiAgICBleHBvcnRzLnZpZXcgPSB2aWV3O1xuXG59KSk7XG4iLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2Fzc2VydC5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8yYTUxYWU0MjRhNTEzZWM5YTZhYTM0NjZiYWEwY2MxZDU1ZGQ0ZjNiXG5cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvZXJyb3JzJyksXG4gIF9yZXF1aXJlJGNvZGVzID0gX3JlcXVpcmUuY29kZXMsXG4gIEVSUl9BTUJJR1VPVVNfQVJHVU1FTlQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfQU1CSUdVT1VTX0FSR1VNRU5ULFxuICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICBFUlJfSU5WQUxJRF9BUkdfVkFMVUUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVkFMVUUsXG4gIEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSxcbiAgRVJSX01JU1NJTkdfQVJHUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NSVNTSU5HX0FSR1M7XG52YXIgQXNzZXJ0aW9uRXJyb3IgPSByZXF1aXJlKCcuL2ludGVybmFsL2Fzc2VydC9hc3NlcnRpb25fZXJyb3InKTtcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCd1dGlsLycpLFxuICBpbnNwZWN0ID0gX3JlcXVpcmUyLmluc3BlY3Q7XG52YXIgX3JlcXVpcmUkdHlwZXMgPSByZXF1aXJlKCd1dGlsLycpLnR5cGVzLFxuICBpc1Byb21pc2UgPSBfcmVxdWlyZSR0eXBlcy5pc1Byb21pc2UsXG4gIGlzUmVnRXhwID0gX3JlcXVpcmUkdHlwZXMuaXNSZWdFeHA7XG52YXIgb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LmFzc2lnbi9wb2x5ZmlsbCcpKCk7XG52YXIgb2JqZWN0SXMgPSByZXF1aXJlKCdvYmplY3QtaXMvcG9seWZpbGwnKSgpO1xudmFyIFJlZ0V4cFByb3RvdHlwZVRlc3QgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJykoJ1JlZ0V4cC5wcm90b3R5cGUudGVzdCcpO1xudmFyIGVycm9yQ2FjaGUgPSBuZXcgTWFwKCk7XG52YXIgaXNEZWVwRXF1YWw7XG52YXIgaXNEZWVwU3RyaWN0RXF1YWw7XG52YXIgcGFyc2VFeHByZXNzaW9uQXQ7XG52YXIgZmluZE5vZGVBcm91bmQ7XG52YXIgZGVjb2RlcjtcbmZ1bmN0aW9uIGxhenlMb2FkQ29tcGFyaXNvbigpIHtcbiAgdmFyIGNvbXBhcmlzb24gPSByZXF1aXJlKCcuL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMnKTtcbiAgaXNEZWVwRXF1YWwgPSBjb21wYXJpc29uLmlzRGVlcEVxdWFsO1xuICBpc0RlZXBTdHJpY3RFcXVhbCA9IGNvbXBhcmlzb24uaXNEZWVwU3RyaWN0RXF1YWw7XG59XG5cbi8vIEVzY2FwZSBjb250cm9sIGNoYXJhY3RlcnMgYnV0IG5vdCBcXG4gYW5kIFxcdCB0byBrZWVwIHRoZSBsaW5lIGJyZWFrcyBhbmRcbi8vIGluZGVudGF0aW9uIGludGFjdC5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG52YXIgZXNjYXBlU2VxdWVuY2VzUmVnRXhwID0gL1tcXHgwMC1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZl0vZztcbnZhciBtZXRhID0gW1wiXFxcXHUwMDAwXCIsIFwiXFxcXHUwMDAxXCIsIFwiXFxcXHUwMDAyXCIsIFwiXFxcXHUwMDAzXCIsIFwiXFxcXHUwMDA0XCIsIFwiXFxcXHUwMDA1XCIsIFwiXFxcXHUwMDA2XCIsIFwiXFxcXHUwMDA3XCIsICdcXFxcYicsICcnLCAnJywgXCJcXFxcdTAwMGJcIiwgJ1xcXFxmJywgJycsIFwiXFxcXHUwMDBlXCIsIFwiXFxcXHUwMDBmXCIsIFwiXFxcXHUwMDEwXCIsIFwiXFxcXHUwMDExXCIsIFwiXFxcXHUwMDEyXCIsIFwiXFxcXHUwMDEzXCIsIFwiXFxcXHUwMDE0XCIsIFwiXFxcXHUwMDE1XCIsIFwiXFxcXHUwMDE2XCIsIFwiXFxcXHUwMDE3XCIsIFwiXFxcXHUwMDE4XCIsIFwiXFxcXHUwMDE5XCIsIFwiXFxcXHUwMDFhXCIsIFwiXFxcXHUwMDFiXCIsIFwiXFxcXHUwMDFjXCIsIFwiXFxcXHUwMDFkXCIsIFwiXFxcXHUwMDFlXCIsIFwiXFxcXHUwMDFmXCJdO1xudmFyIGVzY2FwZUZuID0gZnVuY3Rpb24gZXNjYXBlRm4oc3RyKSB7XG4gIHJldHVybiBtZXRhW3N0ci5jaGFyQ29kZUF0KDApXTtcbn07XG52YXIgd2FybmVkID0gZmFsc2U7XG5cbi8vIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcbnZhciBOT19FWENFUFRJT05fU0VOVElORUwgPSB7fTtcblxuLy8gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBpbm5lckZhaWwob2JqKSB7XG4gIGlmIChvYmoubWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB0aHJvdyBvYmoubWVzc2FnZTtcbiAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG9iaik7XG59XG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0Rm4pIHtcbiAgdmFyIGFyZ3NMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW50ZXJuYWxNZXNzYWdlO1xuICBpZiAoYXJnc0xlbiA9PT0gMCkge1xuICAgIGludGVybmFsTWVzc2FnZSA9ICdGYWlsZWQnO1xuICB9IGVsc2UgaWYgKGFyZ3NMZW4gPT09IDEpIHtcbiAgICBtZXNzYWdlID0gYWN0dWFsO1xuICAgIGFjdHVhbCA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICBpZiAod2FybmVkID09PSBmYWxzZSkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHZhciB3YXJuID0gcHJvY2Vzcy5lbWl0V2FybmluZyA/IHByb2Nlc3MuZW1pdFdhcm5pbmcgOiBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtcbiAgICAgIHdhcm4oJ2Fzc2VydC5mYWlsKCkgd2l0aCBtb3JlIHRoYW4gb25lIGFyZ3VtZW50IGlzIGRlcHJlY2F0ZWQuICcgKyAnUGxlYXNlIHVzZSBhc3NlcnQuc3RyaWN0RXF1YWwoKSBpbnN0ZWFkIG9yIG9ubHkgcGFzcyBhIG1lc3NhZ2UuJywgJ0RlcHJlY2F0aW9uV2FybmluZycsICdERVAwMDk0Jyk7XG4gICAgfVxuICAgIGlmIChhcmdzTGVuID09PSAyKSBvcGVyYXRvciA9ICchPSc7XG4gIH1cbiAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgbWVzc2FnZTtcbiAgdmFyIGVyckFyZ3MgPSB7XG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvciA9PT0gdW5kZWZpbmVkID8gJ2ZhaWwnIDogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm4gfHwgZmFpbFxuICB9O1xuICBpZiAobWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXJyQXJncy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKGVyckFyZ3MpO1xuICBpZiAoaW50ZXJuYWxNZXNzYWdlKSB7XG4gICAgZXJyLm1lc3NhZ2UgPSBpbnRlcm5hbE1lc3NhZ2U7XG4gICAgZXJyLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHRocm93IGVycjtcbn1cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gaW50ZXJuYWwvZXJyb3IuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBBc3NlcnRpb25FcnJvcjtcbmZ1bmN0aW9uIGlubmVyT2soZm4sIGFyZ0xlbiwgdmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHZhciBnZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gICAgaWYgKGFyZ0xlbiA9PT0gMCkge1xuICAgICAgZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gICAgICBtZXNzYWdlID0gJ05vIHZhbHVlIGFyZ3VtZW50IHBhc3NlZCB0byBgYXNzZXJ0Lm9rKClgJztcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgbWVzc2FnZTtcbiAgICB9XG4gICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICBhY3R1YWw6IHZhbHVlLFxuICAgICAgZXhwZWN0ZWQ6IHRydWUsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICc9PScsXG4gICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgfSk7XG4gICAgZXJyLmdlbmVyYXRlZE1lc3NhZ2UgPSBnZW5lcmF0ZWRNZXNzYWdlO1xuICAgIHRocm93IGVycjtcbiAgfVxufVxuXG4vLyBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIXZhbHVlLlxuZnVuY3Rpb24gb2soKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgaW5uZXJPay5hcHBseSh2b2lkIDAsIFtvaywgYXJncy5sZW5ndGhdLmNvbmNhdChhcmdzKSk7XG59XG5hc3NlcnQub2sgPSBvaztcblxuLy8gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoID09LlxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzICovXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICc9PScsXG4gICAgICBzdGFja1N0YXJ0Rm46IGVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3Rcbi8vIGVxdWFsIHdpdGggIT0uXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICchPScsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG4gIGlmICghaXNEZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdkZWVwRXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBkZWVwRXF1YWxcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcbiAgaWYgKGlzRGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90RGVlcEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90RGVlcEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cbmFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBkZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuICBpZiAoIWlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZGVlcFN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG5hc3NlcnQubm90RGVlcFN0cmljdEVxdWFsID0gbm90RGVlcFN0cmljdEVxdWFsO1xuZnVuY3Rpb24gbm90RGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcbiAgaWYgKGlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90RGVlcFN0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90RGVlcFN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn1cbmFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG4gIGlmICghb2JqZWN0SXMoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdzdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IHN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuICBpZiAob2JqZWN0SXMoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdub3RTdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdFN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG52YXIgQ29tcGFyaXNvbiA9IC8qI19fUFVSRV9fKi9fY3JlYXRlQ2xhc3MoZnVuY3Rpb24gQ29tcGFyaXNvbihvYmosIGtleXMsIGFjdHVhbCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcGFyaXNvbik7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChhY3R1YWwgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgYWN0dWFsW2tleV0gPT09ICdzdHJpbmcnICYmIGlzUmVnRXhwKG9ialtrZXldKSAmJiBSZWdFeHBQcm90b3R5cGVUZXN0KG9ialtrZXldLCBhY3R1YWxba2V5XSkpIHtcbiAgICAgICAgX3RoaXNba2V5XSA9IGFjdHVhbFtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXNba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59KTtcbmZ1bmN0aW9uIGNvbXBhcmVFeGNlcHRpb25LZXkoYWN0dWFsLCBleHBlY3RlZCwga2V5LCBtZXNzYWdlLCBrZXlzLCBmbikge1xuICBpZiAoIShrZXkgaW4gYWN0dWFsKSB8fCAhaXNEZWVwU3RyaWN0RXF1YWwoYWN0dWFsW2tleV0sIGV4cGVjdGVkW2tleV0pKSB7XG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAvLyBDcmVhdGUgcGxhY2Vob2xkZXIgb2JqZWN0cyB0byBjcmVhdGUgYSBuaWNlIG91dHB1dC5cbiAgICAgIHZhciBhID0gbmV3IENvbXBhcmlzb24oYWN0dWFsLCBrZXlzKTtcbiAgICAgIHZhciBiID0gbmV3IENvbXBhcmlzb24oZXhwZWN0ZWQsIGtleXMsIGFjdHVhbCk7XG4gICAgICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgYWN0dWFsOiBhLFxuICAgICAgICBleHBlY3RlZDogYixcbiAgICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgICB9KTtcbiAgICAgIGVyci5hY3R1YWwgPSBhY3R1YWw7XG4gICAgICBlcnIuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICAgIGVyci5vcGVyYXRvciA9IGZuLm5hbWU7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogZm4ubmFtZSxcbiAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCwgbXNnLCBmbikge1xuICBpZiAodHlwZW9mIGV4cGVjdGVkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGlzUmVnRXhwKGV4cGVjdGVkKSkgcmV0dXJuIFJlZ0V4cFByb3RvdHlwZVRlc3QoZXhwZWN0ZWQsIGFjdHVhbCk7XG4gICAgLy8gYXNzZXJ0LmRvZXNOb3RUaHJvdyBkb2VzIG5vdCBhY2NlcHQgb2JqZWN0cy5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdleHBlY3RlZCcsIFsnRnVuY3Rpb24nLCAnUmVnRXhwJ10sIGV4cGVjdGVkKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJpbWl0aXZlcyBwcm9wZXJseS5cbiAgICBpZiAoX3R5cGVvZihhY3R1YWwpICE9PSAnb2JqZWN0JyB8fCBhY3R1YWwgPT09IG51bGwpIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJyxcbiAgICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgICAgfSk7XG4gICAgICBlcnIub3BlcmF0b3IgPSBmbi5uYW1lO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV4cGVjdGVkKTtcbiAgICAvLyBTcGVjaWFsIGhhbmRsZSBlcnJvcnMgdG8gbWFrZSBzdXJlIHRoZSBuYW1lIGFuZCB0aGUgbWVzc2FnZSBhcmUgY29tcGFyZWRcbiAgICAvLyBhcyB3ZWxsLlxuICAgIGlmIChleHBlY3RlZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBrZXlzLnB1c2goJ25hbWUnLCAnbWVzc2FnZScpO1xuICAgIH0gZWxzZSBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUoJ2Vycm9yJywgZXhwZWN0ZWQsICdtYXkgbm90IGJlIGFuIGVtcHR5IG9iamVjdCcpO1xuICAgIH1cbiAgICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICh0eXBlb2YgYWN0dWFsW2tleV0gPT09ICdzdHJpbmcnICYmIGlzUmVnRXhwKGV4cGVjdGVkW2tleV0pICYmIFJlZ0V4cFByb3RvdHlwZVRlc3QoZXhwZWN0ZWRba2V5XSwgYWN0dWFsW2tleV0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbXBhcmVFeGNlcHRpb25LZXkoYWN0dWFsLCBleHBlY3RlZCwga2V5LCBtc2csIGtleXMsIGZuKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBHdWFyZCBpbnN0YW5jZW9mIGFnYWluc3QgYXJyb3cgZnVuY3Rpb25zIGFzIHRoZXkgZG9uJ3QgaGF2ZSBhIHByb3RvdHlwZS5cbiAgaWYgKGV4cGVjdGVkLnByb3RvdHlwZSAhPT0gdW5kZWZpbmVkICYmIGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKEVycm9yLmlzUHJvdG90eXBlT2YoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0QWN0dWFsKGZuKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2ZuJywgJ0Z1bmN0aW9uJywgZm4pO1xuICB9XG4gIHRyeSB7XG4gICAgZm4oKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG4gIHJldHVybiBOT19FWENFUFRJT05fU0VOVElORUw7XG59XG5mdW5jdGlvbiBjaGVja0lzUHJvbWlzZShvYmopIHtcbiAgLy8gQWNjZXB0IG5hdGl2ZSBFUzYgcHJvbWlzZXMgYW5kIHByb21pc2VzIHRoYXQgYXJlIGltcGxlbWVudGVkIGluIGEgc2ltaWxhclxuICAvLyB3YXkuIERvIG5vdCBhY2NlcHQgdGhlbmFibGVzIHRoYXQgdXNlIGEgZnVuY3Rpb24gYXMgYG9iamAgYW5kIHRoYXQgaGF2ZSBub1xuICAvLyBgY2F0Y2hgIGhhbmRsZXIuXG5cbiAgLy8gVE9ETzogdGhlbmFibGVzIGFyZSBjaGVja2VkIHVwIHVudGlsIHRoZXkgaGF2ZSB0aGUgY29ycmVjdCBtZXRob2RzLFxuICAvLyBidXQgYWNjb3JkaW5nIHRvIGRvY3VtZW50YXRpb24sIHRoZSBgdGhlbmAgbWV0aG9kIHNob3VsZCByZWNlaXZlXG4gIC8vIHRoZSBgZnVsZmlsbGAgYW5kIGByZWplY3RgIGFyZ3VtZW50cyBhcyB3ZWxsIG9yIGl0IG1heSBiZSBuZXZlciByZXNvbHZlZC5cblxuICByZXR1cm4gaXNQcm9taXNlKG9iaikgfHwgb2JqICE9PSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouY2F0Y2ggPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiB3YWl0Rm9yQWN0dWFsKHByb21pc2VGbikge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdFByb21pc2U7XG4gICAgaWYgKHR5cGVvZiBwcm9taXNlRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFJldHVybiBhIHJlamVjdGVkIHByb21pc2UgaWYgYHByb21pc2VGbmAgdGhyb3dzIHN5bmNocm9ub3VzbHkuXG4gICAgICByZXN1bHRQcm9taXNlID0gcHJvbWlzZUZuKCk7XG4gICAgICAvLyBGYWlsIGluIGNhc2Ugbm8gcHJvbWlzZSBpcyByZXR1cm5lZC5cbiAgICAgIGlmICghY2hlY2tJc1Byb21pc2UocmVzdWx0UHJvbWlzZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSgnaW5zdGFuY2Ugb2YgUHJvbWlzZScsICdwcm9taXNlRm4nLCByZXN1bHRQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoZWNrSXNQcm9taXNlKHByb21pc2VGbikpIHtcbiAgICAgIHJlc3VsdFByb21pc2UgPSBwcm9taXNlRm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgncHJvbWlzZUZuJywgWydGdW5jdGlvbicsICdQcm9taXNlJ10sIHByb21pc2VGbik7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXN1bHRQcm9taXNlO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIE5PX0VYQ0VQVElPTl9TRU5USU5FTDtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZXhwZWN0c0Vycm9yKHN0YWNrU3RhcnRGbiwgYWN0dWFsLCBlcnJvciwgbWVzc2FnZSkge1xuICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2Vycm9yJywgWydPYmplY3QnLCAnRXJyb3InLCAnRnVuY3Rpb24nLCAnUmVnRXhwJ10sIGVycm9yKTtcbiAgICB9XG4gICAgaWYgKF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsKSB7XG4gICAgICBpZiAoYWN0dWFsLm1lc3NhZ2UgPT09IGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFUlJfQU1CSUdVT1VTX0FSR1VNRU5UKCdlcnJvci9tZXNzYWdlJywgXCJUaGUgZXJyb3IgbWVzc2FnZSBcXFwiXCIuY29uY2F0KGFjdHVhbC5tZXNzYWdlLCBcIlxcXCIgaXMgaWRlbnRpY2FsIHRvIHRoZSBtZXNzYWdlLlwiKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhY3R1YWwgPT09IGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0FNQklHVU9VU19BUkdVTUVOVCgnZXJyb3IvbWVzc2FnZScsIFwiVGhlIGVycm9yIFxcXCJcIi5jb25jYXQoYWN0dWFsLCBcIlxcXCIgaXMgaWRlbnRpY2FsIHRvIHRoZSBtZXNzYWdlLlwiKSk7XG4gICAgfVxuICAgIG1lc3NhZ2UgPSBlcnJvcjtcbiAgICBlcnJvciA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChlcnJvciAhPSBudWxsICYmIF90eXBlb2YoZXJyb3IpICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgZXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2Vycm9yJywgWydPYmplY3QnLCAnRXJyb3InLCAnRnVuY3Rpb24nLCAnUmVnRXhwJ10sIGVycm9yKTtcbiAgfVxuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT05fU0VOVElORUwpIHtcbiAgICB2YXIgZGV0YWlscyA9ICcnO1xuICAgIGlmIChlcnJvciAmJiBlcnJvci5uYW1lKSB7XG4gICAgICBkZXRhaWxzICs9IFwiIChcIi5jb25jYXQoZXJyb3IubmFtZSwgXCIpXCIpO1xuICAgIH1cbiAgICBkZXRhaWxzICs9IG1lc3NhZ2UgPyBcIjogXCIuY29uY2F0KG1lc3NhZ2UpIDogJy4nO1xuICAgIHZhciBmblR5cGUgPSBzdGFja1N0YXJ0Rm4ubmFtZSA9PT0gJ3JlamVjdHMnID8gJ3JlamVjdGlvbicgOiAnZXhjZXB0aW9uJztcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiB1bmRlZmluZWQsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBvcGVyYXRvcjogc3RhY2tTdGFydEZuLm5hbWUsXG4gICAgICBtZXNzYWdlOiBcIk1pc3NpbmcgZXhwZWN0ZWQgXCIuY29uY2F0KGZuVHlwZSkuY29uY2F0KGRldGFpbHMpLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm5cbiAgICB9KTtcbiAgfVxuICBpZiAoZXJyb3IgJiYgIWV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UsIHN0YWNrU3RhcnRGbikpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cbn1cbmZ1bmN0aW9uIGV4cGVjdHNOb0Vycm9yKHN0YWNrU3RhcnRGbiwgYWN0dWFsLCBlcnJvciwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT05fU0VOVElORUwpIHJldHVybjtcbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXJyb3I7XG4gICAgZXJyb3IgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKCFlcnJvciB8fCBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGVycm9yKSkge1xuICAgIHZhciBkZXRhaWxzID0gbWVzc2FnZSA/IFwiOiBcIi5jb25jYXQobWVzc2FnZSkgOiAnLic7XG4gICAgdmFyIGZuVHlwZSA9IHN0YWNrU3RhcnRGbi5uYW1lID09PSAnZG9lc05vdFJlamVjdCcgPyAncmVqZWN0aW9uJyA6ICdleGNlcHRpb24nO1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBlcnJvcixcbiAgICAgIG9wZXJhdG9yOiBzdGFja1N0YXJ0Rm4ubmFtZSxcbiAgICAgIG1lc3NhZ2U6IFwiR290IHVud2FudGVkIFwiLmNvbmNhdChmblR5cGUpLmNvbmNhdChkZXRhaWxzLCBcIlxcblwiKSArIFwiQWN0dWFsIG1lc3NhZ2U6IFxcXCJcIi5jb25jYXQoYWN0dWFsICYmIGFjdHVhbC5tZXNzYWdlLCBcIlxcXCJcIiksXG4gICAgICBzdGFja1N0YXJ0Rm46IHN0YWNrU3RhcnRGblxuICAgIH0pO1xuICB9XG4gIHRocm93IGFjdHVhbDtcbn1cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbiB0aHJvd3MocHJvbWlzZUZuKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuICBleHBlY3RzRXJyb3IuYXBwbHkodm9pZCAwLCBbdGhyb3dzLCBnZXRBY3R1YWwocHJvbWlzZUZuKV0uY29uY2F0KGFyZ3MpKTtcbn07XG5hc3NlcnQucmVqZWN0cyA9IGZ1bmN0aW9uIHJlamVjdHMocHJvbWlzZUZuKSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgYXJnc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuICByZXR1cm4gd2FpdEZvckFjdHVhbChwcm9taXNlRm4pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiBleHBlY3RzRXJyb3IuYXBwbHkodm9pZCAwLCBbcmVqZWN0cywgcmVzdWx0XS5jb25jYXQoYXJncykpO1xuICB9KTtcbn07XG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24gZG9lc05vdFRocm93KGZuKSB7XG4gIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCA+IDEgPyBfbGVuNCAtIDEgOiAwKSwgX2tleTQgPSAxOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgYXJnc1tfa2V5NCAtIDFdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgfVxuICBleHBlY3RzTm9FcnJvci5hcHBseSh2b2lkIDAsIFtkb2VzTm90VGhyb3csIGdldEFjdHVhbChmbildLmNvbmNhdChhcmdzKSk7XG59O1xuYXNzZXJ0LmRvZXNOb3RSZWplY3QgPSBmdW5jdGlvbiBkb2VzTm90UmVqZWN0KGZuKSB7XG4gIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNSA+IDEgPyBfbGVuNSAtIDEgOiAwKSwgX2tleTUgPSAxOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgYXJnc1tfa2V5NSAtIDFdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgfVxuICByZXR1cm4gd2FpdEZvckFjdHVhbChmbikudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIGV4cGVjdHNOb0Vycm9yLmFwcGx5KHZvaWQgMCwgW2RvZXNOb3RSZWplY3QsIHJlc3VsdF0uY29uY2F0KGFyZ3MpKTtcbiAgfSk7XG59O1xuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbiBpZkVycm9yKGVycikge1xuICBpZiAoZXJyICE9PSBudWxsICYmIGVyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnaWZFcnJvciBnb3QgdW53YW50ZWQgZXhjZXB0aW9uOiAnO1xuICAgIGlmIChfdHlwZW9mKGVycikgPT09ICdvYmplY3QnICYmIHR5cGVvZiBlcnIubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChlcnIubWVzc2FnZS5sZW5ndGggPT09IDAgJiYgZXJyLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gZXJyLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlICs9IGVyci5tZXNzYWdlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlICs9IGluc3BlY3QoZXJyKTtcbiAgICB9XG4gICAgdmFyIG5ld0VyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICBhY3R1YWw6IGVycixcbiAgICAgIGV4cGVjdGVkOiBudWxsLFxuICAgICAgb3BlcmF0b3I6ICdpZkVycm9yJyxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBzdGFja1N0YXJ0Rm46IGlmRXJyb3JcbiAgICB9KTtcblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIGEgc3RhY2sgdHJhY2UhXG4gICAgdmFyIG9yaWdTdGFjayA9IGVyci5zdGFjaztcbiAgICBpZiAodHlwZW9mIG9yaWdTdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCByZW1vdmUgYW55IGR1cGxpY2F0ZWQgZnJhbWVzIGZyb20gdGhlIGVycm9yIGZyYW1lcyB0YWtlblxuICAgICAgLy8gZnJvbSB3aXRoaW4gYGlmRXJyb3JgIGFuZCBhZGQgdGhlIG9yaWdpbmFsIGVycm9yIGZyYW1lcyB0byB0aGUgbmV3bHlcbiAgICAgIC8vIGNyZWF0ZWQgb25lcy5cbiAgICAgIHZhciB0bXAyID0gb3JpZ1N0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHRtcDIuc2hpZnQoKTtcbiAgICAgIC8vIEZpbHRlciBhbGwgZnJhbWVzIGV4aXN0aW5nIGluIGVyci5zdGFjay5cbiAgICAgIHZhciB0bXAxID0gbmV3RXJyLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG1wMi5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIHRoZSBmcmFtZS5cbiAgICAgICAgdmFyIHBvcyA9IHRtcDEuaW5kZXhPZih0bXAyW2ldKTtcbiAgICAgICAgaWYgKHBvcyAhPT0gLTEpIHtcbiAgICAgICAgICAvLyBPbmx5IGtlZXAgbmV3IGZyYW1lcy5cbiAgICAgICAgICB0bXAxID0gdG1wMS5zbGljZSgwLCBwb3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXdFcnIuc3RhY2sgPSBcIlwiLmNvbmNhdCh0bXAxLmpvaW4oJ1xcbicpLCBcIlxcblwiKS5jb25jYXQodG1wMi5qb2luKCdcXG4nKSk7XG4gICAgfVxuICAgIHRocm93IG5ld0VycjtcbiAgfVxufTtcblxuLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9hc3NlcnQuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMmE4NzFkZjNkZmI4ZWE2NjNlZjVlMWY4ZjYyNzAxZWM1MTM4NGVjYlxuZnVuY3Rpb24gaW50ZXJuYWxNYXRjaChzdHJpbmcsIHJlZ2V4cCwgbWVzc2FnZSwgZm4sIGZuTmFtZSkge1xuICBpZiAoIWlzUmVnRXhwKHJlZ2V4cCkpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ3JlZ2V4cCcsICdSZWdFeHAnLCByZWdleHApO1xuICB9XG4gIHZhciBtYXRjaCA9IGZuTmFtZSA9PT0gJ21hdGNoJztcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnIHx8IFJlZ0V4cFByb3RvdHlwZVRlc3QocmVnZXhwLCBzdHJpbmcpICE9PSBtYXRjaCkge1xuICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgfVxuICAgIHZhciBnZW5lcmF0ZWRNZXNzYWdlID0gIW1lc3NhZ2U7XG5cbiAgICAvLyAnVGhlIGlucHV0IHdhcyBleHBlY3RlZCB0byBub3QgbWF0Y2ggdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiAnICtcbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycgPyAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSAnICsgXCJcIi5jb25jYXQoX3R5cGVvZihzdHJpbmcpLCBcIiAoXCIpLmNvbmNhdChpbnNwZWN0KHN0cmluZyksIFwiKVwiKSA6IChtYXRjaCA/ICdUaGUgaW5wdXQgZGlkIG5vdCBtYXRjaCB0aGUgcmVndWxhciBleHByZXNzaW9uICcgOiAnVGhlIGlucHV0IHdhcyBleHBlY3RlZCB0byBub3QgbWF0Y2ggdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiAnKSArIFwiXCIuY29uY2F0KGluc3BlY3QocmVnZXhwKSwgXCIuIElucHV0OlxcblxcblwiKS5jb25jYXQoaW5zcGVjdChzdHJpbmcpLCBcIlxcblwiKSk7XG4gICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICBhY3R1YWw6IHN0cmluZyxcbiAgICAgIGV4cGVjdGVkOiByZWdleHAsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6IGZuTmFtZSxcbiAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICB9KTtcbiAgICBlcnIuZ2VuZXJhdGVkTWVzc2FnZSA9IGdlbmVyYXRlZE1lc3NhZ2U7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5hc3NlcnQubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChzdHJpbmcsIHJlZ2V4cCwgbWVzc2FnZSkge1xuICBpbnRlcm5hbE1hdGNoKHN0cmluZywgcmVnZXhwLCBtZXNzYWdlLCBtYXRjaCwgJ21hdGNoJyk7XG59O1xuYXNzZXJ0LmRvZXNOb3RNYXRjaCA9IGZ1bmN0aW9uIGRvZXNOb3RNYXRjaChzdHJpbmcsIHJlZ2V4cCwgbWVzc2FnZSkge1xuICBpbnRlcm5hbE1hdGNoKHN0cmluZywgcmVnZXhwLCBtZXNzYWdlLCBkb2VzTm90TWF0Y2gsICdkb2VzTm90TWF0Y2gnKTtcbn07XG5cbi8vIEV4cG9zZSBhIHN0cmljdCBvbmx5IHZhcmlhbnQgb2YgYXNzZXJ0XG5mdW5jdGlvbiBzdHJpY3QoKSB7XG4gIGZvciAodmFyIF9sZW42ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNiksIF9rZXk2ID0gMDsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgIGFyZ3NbX2tleTZdID0gYXJndW1lbnRzW19rZXk2XTtcbiAgfVxuICBpbm5lck9rLmFwcGx5KHZvaWQgMCwgW3N0cmljdCwgYXJncy5sZW5ndGhdLmNvbmNhdChhcmdzKSk7XG59XG5hc3NlcnQuc3RyaWN0ID0gb2JqZWN0QXNzaWduKHN0cmljdCwgYXNzZXJ0LCB7XG4gIGVxdWFsOiBhc3NlcnQuc3RyaWN0RXF1YWwsXG4gIGRlZXBFcXVhbDogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCxcbiAgbm90RXF1YWw6IGFzc2VydC5ub3RTdHJpY3RFcXVhbCxcbiAgbm90RGVlcEVxdWFsOiBhc3NlcnQubm90RGVlcFN0cmljdEVxdWFsXG59KTtcbmFzc2VydC5zdHJpY3Quc3RyaWN0ID0gYXNzZXJ0LnN0cmljdDsiLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL2Fzc2VydC9hc3NlcnRpb25fZXJyb3IuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMDgxNzg0MGY3NzUwMzIxNjlkZGQ3MGM4NWFjMDU5ZjE4ZmZjYzgxY1xuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkOyBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzOyBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7IGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpOyBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9IFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IFdyYXBwZXIsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpOyB9OyByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7IH1cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdC5iaW5kKCk7IH0gZWxzZSB7IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgdmFyIGEgPSBbbnVsbF07IGEucHVzaC5hcHBseShhLCBhcmdzKTsgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpOyB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTsgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7IHJldHVybiBpbnN0YW5jZTsgfTsgfSByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7IHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7IH1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgndXRpbC8nKSxcbiAgaW5zcGVjdCA9IF9yZXF1aXJlLmluc3BlY3Q7XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgnLi4vZXJyb3JzJyksXG4gIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUyLmNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFO1xuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn1cblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGVhdFxuZnVuY3Rpb24gcmVwZWF0KHN0ciwgY291bnQpIHtcbiAgY291bnQgPSBNYXRoLmZsb29yKGNvdW50KTtcbiAgaWYgKHN0ci5sZW5ndGggPT0gMCB8fCBjb3VudCA9PSAwKSByZXR1cm4gJyc7XG4gIHZhciBtYXhDb3VudCA9IHN0ci5sZW5ndGggKiBjb3VudDtcbiAgY291bnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKGNvdW50KSAvIE1hdGgubG9nKDIpKTtcbiAgd2hpbGUgKGNvdW50KSB7XG4gICAgc3RyICs9IHN0cjtcbiAgICBjb3VudC0tO1xuICB9XG4gIHN0ciArPSBzdHIuc3Vic3RyaW5nKDAsIG1heENvdW50IC0gc3RyLmxlbmd0aCk7XG4gIHJldHVybiBzdHI7XG59XG52YXIgYmx1ZSA9ICcnO1xudmFyIGdyZWVuID0gJyc7XG52YXIgcmVkID0gJyc7XG52YXIgd2hpdGUgPSAnJztcbnZhciBrUmVhZGFibGVPcGVyYXRvciA9IHtcbiAgZGVlcFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGRlZXAtZXF1YWw6JyxcbiAgc3RyaWN0RXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgc3RyaWN0bHkgZXF1YWw6JyxcbiAgc3RyaWN0RXF1YWxPYmplY3Q6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIHJlZmVyZW5jZS1lcXVhbCB0byBcImV4cGVjdGVkXCI6JyxcbiAgZGVlcEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIGxvb3NlbHkgZGVlcC1lcXVhbDonLFxuICBlcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBsb29zZWx5IGVxdWFsOicsXG4gIG5vdERlZXBTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgbm90IHRvIGJlIHN0cmljdGx5IGRlZXAtZXF1YWwgdG86JyxcbiAgbm90U3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIHN0cmljdGx5IHVuZXF1YWwgdG86JyxcbiAgbm90U3RyaWN0RXF1YWxPYmplY3Q6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSByZWZlcmVuY2UtZXF1YWwgdG8gXCJleHBlY3RlZFwiOicsXG4gIG5vdERlZXBFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgbm90IHRvIGJlIGxvb3NlbHkgZGVlcC1lcXVhbCB0bzonLFxuICBub3RFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgdG8gYmUgbG9vc2VseSB1bmVxdWFsIHRvOicsXG4gIG5vdElkZW50aWNhbDogJ1ZhbHVlcyBpZGVudGljYWwgYnV0IG5vdCByZWZlcmVuY2UtZXF1YWw6J1xufTtcblxuLy8gQ29tcGFyaW5nIHNob3J0IHByaW1pdGl2ZXMgc2hvdWxkIGp1c3Qgc2hvdyA9PT0gLyAhPT0gaW5zdGVhZCBvZiB1c2luZyB0aGVcbi8vIGRpZmYuXG52YXIga01heFNob3J0TGVuZ3RoID0gMTA7XG5mdW5jdGlvbiBjb3B5RXJyb3Ioc291cmNlKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIHRhcmdldCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZSkpO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCAnbWVzc2FnZScsIHtcbiAgICB2YWx1ZTogc291cmNlLm1lc3NhZ2VcbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBpbnNwZWN0VmFsdWUodmFsKSB7XG4gIC8vIFRoZSB1dGlsLmluc3BlY3QgZGVmYXVsdCB2YWx1ZXMgY291bGQgYmUgY2hhbmdlZC4gVGhpcyBtYWtlcyBzdXJlIHRoZVxuICAvLyBlcnJvciBtZXNzYWdlcyBjb250YWluIHRoZSBuZWNlc3NhcnkgaW5mb3JtYXRpb24gbmV2ZXJ0aGVsZXNzLlxuICByZXR1cm4gaW5zcGVjdCh2YWwsIHtcbiAgICBjb21wYWN0OiBmYWxzZSxcbiAgICBjdXN0b21JbnNwZWN0OiBmYWxzZSxcbiAgICBkZXB0aDogMTAwMCxcbiAgICBtYXhBcnJheUxlbmd0aDogSW5maW5pdHksXG4gICAgLy8gQXNzZXJ0IGNvbXBhcmVzIG9ubHkgZW51bWVyYWJsZSBwcm9wZXJ0aWVzICh3aXRoIGEgZmV3IGV4Y2VwdGlvbnMpLlxuICAgIHNob3dIaWRkZW46IGZhbHNlLFxuICAgIC8vIEhhdmluZyBhIGxvbmcgbGluZSBhcyBlcnJvciBpcyBiZXR0ZXIgdGhhbiB3cmFwcGluZyB0aGUgbGluZSBmb3JcbiAgICAvLyBjb21wYXJpc29uIGZvciBub3cuXG4gICAgLy8gVE9ETyhCcmlkZ2VBUik6IGBicmVha0xlbmd0aGAgc2hvdWxkIGJlIGxpbWl0ZWQgYXMgc29vbiBhcyBzb29uIGFzIHdlXG4gICAgLy8gaGF2ZSBtZXRhIGluZm9ybWF0aW9uIGFib3V0IHRoZSBpbnNwZWN0ZWQgcHJvcGVydGllcyAoaS5lLiwga25vdyB3aGVyZVxuICAgIC8vIGluIHdoYXQgbGluZSB0aGUgcHJvcGVydHkgc3RhcnRzIGFuZCBlbmRzKS5cbiAgICBicmVha0xlbmd0aDogSW5maW5pdHksXG4gICAgLy8gQXNzZXJ0IGRvZXMgbm90IGRldGVjdCBwcm94aWVzIGN1cnJlbnRseS5cbiAgICBzaG93UHJveHk6IGZhbHNlLFxuICAgIHNvcnRlZDogdHJ1ZSxcbiAgICAvLyBJbnNwZWN0IGdldHRlcnMgYXMgd2UgYWxzbyBjaGVjayB0aGVtIHdoZW4gY29tcGFyaW5nIGVudHJpZXMuXG4gICAgZ2V0dGVyczogdHJ1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVyckRpZmYoYWN0dWFsLCBleHBlY3RlZCwgb3BlcmF0b3IpIHtcbiAgdmFyIG90aGVyID0gJyc7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGxhc3RQb3MgPSAwO1xuICB2YXIgZW5kID0gJyc7XG4gIHZhciBza2lwcGVkID0gZmFsc2U7XG4gIHZhciBhY3R1YWxJbnNwZWN0ZWQgPSBpbnNwZWN0VmFsdWUoYWN0dWFsKTtcbiAgdmFyIGFjdHVhbExpbmVzID0gYWN0dWFsSW5zcGVjdGVkLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGV4cGVjdGVkTGluZXMgPSBpbnNwZWN0VmFsdWUoZXhwZWN0ZWQpLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgaW5kaWNhdG9yID0gJyc7XG5cbiAgLy8gSW4gY2FzZSBib3RoIHZhbHVlcyBhcmUgb2JqZWN0cyBleHBsaWNpdGx5IG1hcmsgdGhlbSBhcyBub3QgcmVmZXJlbmNlIGVxdWFsXG4gIC8vIGZvciB0aGUgYHN0cmljdEVxdWFsYCBvcGVyYXRvci5cbiAgaWYgKG9wZXJhdG9yID09PSAnc3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihleHBlY3RlZCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCAmJiBleHBlY3RlZCAhPT0gbnVsbCkge1xuICAgIG9wZXJhdG9yID0gJ3N0cmljdEVxdWFsT2JqZWN0JztcbiAgfVxuXG4gIC8vIElmIFwiYWN0dWFsXCIgYW5kIFwiZXhwZWN0ZWRcIiBmaXQgb24gYSBzaW5nbGUgbGluZSBhbmQgdGhleSBhcmUgbm90IHN0cmljdGx5XG4gIC8vIGVxdWFsLCBjaGVjayBmdXJ0aGVyIHNwZWNpYWwgaGFuZGxpbmcuXG4gIGlmIChhY3R1YWxMaW5lcy5sZW5ndGggPT09IDEgJiYgZXhwZWN0ZWRMaW5lcy5sZW5ndGggPT09IDEgJiYgYWN0dWFsTGluZXNbMF0gIT09IGV4cGVjdGVkTGluZXNbMF0pIHtcbiAgICB2YXIgaW5wdXRMZW5ndGggPSBhY3R1YWxMaW5lc1swXS5sZW5ndGggKyBleHBlY3RlZExpbmVzWzBdLmxlbmd0aDtcbiAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGxlbmd0aCBvZiBcImFjdHVhbFwiIGFuZCBcImV4cGVjdGVkXCIgdG9nZXRoZXIgaXMgbGVzcyB0aGFuXG4gICAgLy8ga01heFNob3J0TGVuZ3RoIGFuZCBpZiBuZWl0aGVyIGlzIGFuIG9iamVjdCBhbmQgYXQgbGVhc3Qgb25lIG9mIHRoZW0gaXNcbiAgICAvLyBub3QgYHplcm9gLCB1c2UgdGhlIHN0cmljdCBlcXVhbCBjb21wYXJpc29uIHRvIHZpc3VhbGl6ZSB0aGUgb3V0cHV0LlxuICAgIGlmIChpbnB1dExlbmd0aCA8PSBrTWF4U2hvcnRMZW5ndGgpIHtcbiAgICAgIGlmICgoX3R5cGVvZihhY3R1YWwpICE9PSAnb2JqZWN0JyB8fCBhY3R1YWwgPT09IG51bGwpICYmIChfdHlwZW9mKGV4cGVjdGVkKSAhPT0gJ29iamVjdCcgfHwgZXhwZWN0ZWQgPT09IG51bGwpICYmIChhY3R1YWwgIT09IDAgfHwgZXhwZWN0ZWQgIT09IDApKSB7XG4gICAgICAgIC8vIC0wID09PSArMFxuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoa1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdLCBcIlxcblxcblwiKSArIFwiXCIuY29uY2F0KGFjdHVhbExpbmVzWzBdLCBcIiAhPT0gXCIpLmNvbmNhdChleHBlY3RlZExpbmVzWzBdLCBcIlxcblwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wZXJhdG9yICE9PSAnc3RyaWN0RXF1YWxPYmplY3QnKSB7XG4gICAgICAvLyBJZiB0aGUgc3RkZXJyIGlzIGEgdHR5IGFuZCB0aGUgaW5wdXQgbGVuZ3RoIGlzIGxvd2VyIHRoYW4gdGhlIGN1cnJlbnRcbiAgICAgIC8vIGNvbHVtbnMgcGVyIGxpbmUsIGFkZCBhIG1pc21hdGNoIGluZGljYXRvciBiZWxvdyB0aGUgb3V0cHV0LiBJZiBpdCBpc1xuICAgICAgLy8gbm90IGEgdHR5LCB1c2UgYSBkZWZhdWx0IHZhbHVlIG9mIDgwIGNoYXJhY3RlcnMuXG4gICAgICB2YXIgbWF4TGVuZ3RoID0gcHJvY2Vzcy5zdGRlcnIgJiYgcHJvY2Vzcy5zdGRlcnIuaXNUVFkgPyBwcm9jZXNzLnN0ZGVyci5jb2x1bW5zIDogODA7XG4gICAgICBpZiAoaW5wdXRMZW5ndGggPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgd2hpbGUgKGFjdHVhbExpbmVzWzBdW2ldID09PSBleHBlY3RlZExpbmVzWzBdW2ldKSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmlyc3QgY2hhcmFjdGVycy5cbiAgICAgICAgaWYgKGkgPiAyKSB7XG4gICAgICAgICAgLy8gQWRkIHBvc2l0aW9uIGluZGljYXRvciBmb3IgdGhlIGZpcnN0IG1pc21hdGNoIGluIGNhc2UgaXQgaXMgYVxuICAgICAgICAgIC8vIHNpbmdsZSBsaW5lIGFuZCB0aGUgaW5wdXQgbGVuZ3RoIGlzIGxlc3MgdGhhbiB0aGUgY29sdW1uIGxlbmd0aC5cbiAgICAgICAgICBpbmRpY2F0b3IgPSBcIlxcbiAgXCIuY29uY2F0KHJlcGVhdCgnICcsIGkpLCBcIl5cIik7XG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgYWxsIGVuZGluZyBsaW5lcyB0aGF0IG1hdGNoICh0aGlzIG9wdGltaXplcyB0aGUgb3V0cHV0IGZvclxuICAvLyByZWFkYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgbnVtYmVyIG9mIHRvdGFsIGNoYW5nZWQgbGluZXMpLlxuICB2YXIgYSA9IGFjdHVhbExpbmVzW2FjdHVhbExpbmVzLmxlbmd0aCAtIDFdO1xuICB2YXIgYiA9IGV4cGVjdGVkTGluZXNbZXhwZWN0ZWRMaW5lcy5sZW5ndGggLSAxXTtcbiAgd2hpbGUgKGEgPT09IGIpIHtcbiAgICBpZiAoaSsrIDwgMikge1xuICAgICAgZW5kID0gXCJcXG4gIFwiLmNvbmNhdChhKS5jb25jYXQoZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXIgPSBhO1xuICAgIH1cbiAgICBhY3R1YWxMaW5lcy5wb3AoKTtcbiAgICBleHBlY3RlZExpbmVzLnBvcCgpO1xuICAgIGlmIChhY3R1YWxMaW5lcy5sZW5ndGggPT09IDAgfHwgZXhwZWN0ZWRMaW5lcy5sZW5ndGggPT09IDApIGJyZWFrO1xuICAgIGEgPSBhY3R1YWxMaW5lc1thY3R1YWxMaW5lcy5sZW5ndGggLSAxXTtcbiAgICBiID0gZXhwZWN0ZWRMaW5lc1tleHBlY3RlZExpbmVzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHZhciBtYXhMaW5lcyA9IE1hdGgubWF4KGFjdHVhbExpbmVzLmxlbmd0aCwgZXhwZWN0ZWRMaW5lcy5sZW5ndGgpO1xuICAvLyBTdHJpY3QgZXF1YWwgd2l0aCBpZGVudGljYWwgb2JqZWN0cyB0aGF0IGFyZSBub3QgaWRlbnRpY2FsIGJ5IHJlZmVyZW5jZS5cbiAgLy8gRS5nLiwgYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCh7IGE6IFN5bWJvbCgpIH0sIHsgYTogU3ltYm9sKCkgfSlcbiAgaWYgKG1heExpbmVzID09PSAwKSB7XG4gICAgLy8gV2UgaGF2ZSB0byBnZXQgdGhlIHJlc3VsdCBhZ2Fpbi4gVGhlIGxpbmVzIHdlcmUgYWxsIHJlbW92ZWQgYmVmb3JlLlxuICAgIHZhciBfYWN0dWFsTGluZXMgPSBhY3R1YWxJbnNwZWN0ZWQuc3BsaXQoJ1xcbicpO1xuXG4gICAgLy8gT25seSByZW1vdmUgbGluZXMgaW4gY2FzZSBpdCBtYWtlcyBzZW5zZSB0byBjb2xsYXBzZSB0aG9zZS5cbiAgICAvLyBUT0RPOiBBY2NlcHQgZW52IHRvIGFsd2F5cyBzaG93IHRoZSBmdWxsIGVycm9yLlxuICAgIGlmIChfYWN0dWFsTGluZXMubGVuZ3RoID4gMzApIHtcbiAgICAgIF9hY3R1YWxMaW5lc1syNl0gPSBcIlwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgd2hpbGUgKF9hY3R1YWxMaW5lcy5sZW5ndGggPiAyNykge1xuICAgICAgICBfYWN0dWFsTGluZXMucG9wKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIlwiLmNvbmNhdChrUmVhZGFibGVPcGVyYXRvci5ub3RJZGVudGljYWwsIFwiXFxuXFxuXCIpLmNvbmNhdChfYWN0dWFsTGluZXMuam9pbignXFxuJyksIFwiXFxuXCIpO1xuICB9XG4gIGlmIChpID4gMykge1xuICAgIGVuZCA9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KGVuZCk7XG4gICAgc2tpcHBlZCA9IHRydWU7XG4gIH1cbiAgaWYgKG90aGVyICE9PSAnJykge1xuICAgIGVuZCA9IFwiXFxuICBcIi5jb25jYXQob3RoZXIpLmNvbmNhdChlbmQpO1xuICAgIG90aGVyID0gJyc7XG4gIH1cbiAgdmFyIHByaW50ZWRMaW5lcyA9IDA7XG4gIHZhciBtc2cgPSBrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0gKyBcIlxcblwiLmNvbmNhdChncmVlbiwgXCIrIGFjdHVhbFwiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQocmVkLCBcIi0gZXhwZWN0ZWRcIikuY29uY2F0KHdoaXRlKTtcbiAgdmFyIHNraXBwZWRNc2cgPSBcIiBcIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlLCBcIiBMaW5lcyBza2lwcGVkXCIpO1xuICBmb3IgKGkgPSAwOyBpIDwgbWF4TGluZXM7IGkrKykge1xuICAgIC8vIE9ubHkgZXh0cmEgZXhwZWN0ZWQgbGluZXMgZXhpc3RcbiAgICB2YXIgY3VyID0gaSAtIGxhc3RQb3M7XG4gICAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA8IGkgKyAxKSB7XG4gICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxuICAgICAgLy8gY3VycmVudCBsaW5lIGlzIGF0IGxlYXN0IGxpbmUgdGhyZWUsIGFkZCBzb21lIG9mIHRoZSBmb3JtZXIgbGluZXMgYW5kXG4gICAgICAvLyBhbHNvIGFkZCBkb3RzIHRvIGluZGljYXRlIHNraXBwZWQgZW50cmllcy5cbiAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XG4gICAgICAgIGlmIChjdXIgPiA0KSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VyID4gMykge1xuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGV4cGVjdGVkTGluZXNbaSAtIDJdKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfVxuICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChleHBlY3RlZExpbmVzW2kgLSAxXSk7XG4gICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgfVxuICAgICAgLy8gTWFyayB0aGUgY3VycmVudCBsaW5lIGFzIHRoZSBsYXN0IGRpdmVyZ2luZyBvbmUuXG4gICAgICBsYXN0UG9zID0gaTtcbiAgICAgIC8vIEFkZCB0aGUgZXhwZWN0ZWQgbGluZSB0byB0aGUgY2FjaGUuXG4gICAgICBvdGhlciArPSBcIlxcblwiLmNvbmNhdChyZWQsIFwiLVwiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpXSk7XG4gICAgICBwcmludGVkTGluZXMrKztcbiAgICAgIC8vIE9ubHkgZXh0cmEgYWN0dWFsIGxpbmVzIGV4aXN0XG4gICAgfSBlbHNlIGlmIChleHBlY3RlZExpbmVzLmxlbmd0aCA8IGkgKyAxKSB7XG4gICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxuICAgICAgLy8gY3VycmVudCBsaW5lIGlzIGF0IGxlYXN0IGxpbmUgdGhyZWUsIGFkZCBzb21lIG9mIHRoZSBmb3JtZXIgbGluZXMgYW5kXG4gICAgICAvLyBhbHNvIGFkZCBkb3RzIHRvIGluZGljYXRlIHNraXBwZWQgZW50cmllcy5cbiAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XG4gICAgICAgIGlmIChjdXIgPiA0KSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VyID4gMykge1xuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmVzW2kgLSAyXSk7XG4gICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgIH1cbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKTtcbiAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICB9XG4gICAgICAvLyBNYXJrIHRoZSBjdXJyZW50IGxpbmUgYXMgdGhlIGxhc3QgZGl2ZXJnaW5nIG9uZS5cbiAgICAgIGxhc3RQb3MgPSBpO1xuICAgICAgLy8gQWRkIHRoZSBhY3R1YWwgbGluZSB0byB0aGUgcmVzdWx0LlxuICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGdyZWVuLCBcIitcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGFjdHVhbExpbmVzW2ldKTtcbiAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgLy8gTGluZXMgZGl2ZXJnZVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXhwZWN0ZWRMaW5lID0gZXhwZWN0ZWRMaW5lc1tpXTtcbiAgICAgIHZhciBhY3R1YWxMaW5lID0gYWN0dWFsTGluZXNbaV07XG4gICAgICAvLyBJZiB0aGUgbGluZXMgZGl2ZXJnZSwgc3BlY2lmaWNhbGx5IGNoZWNrIGZvciBsaW5lcyB0aGF0IG9ubHkgZGl2ZXJnZSBieVxuICAgICAgLy8gYSB0cmFpbGluZyBjb21tYS4gSW4gdGhhdCBjYXNlIGl0IGlzIGFjdHVhbGx5IGlkZW50aWNhbCBhbmQgd2Ugc2hvdWxkXG4gICAgICAvLyBtYXJrIGl0IGFzIHN1Y2guXG4gICAgICB2YXIgZGl2ZXJnaW5nTGluZXMgPSBhY3R1YWxMaW5lICE9PSBleHBlY3RlZExpbmUgJiYgKCFlbmRzV2l0aChhY3R1YWxMaW5lLCAnLCcpIHx8IGFjdHVhbExpbmUuc2xpY2UoMCwgLTEpICE9PSBleHBlY3RlZExpbmUpO1xuICAgICAgLy8gSWYgdGhlIGV4cGVjdGVkIGxpbmUgaGFzIGEgdHJhaWxpbmcgY29tbWEgYnV0IGlzIG90aGVyd2lzZSBpZGVudGljYWwsXG4gICAgICAvLyBhZGQgYSBjb21tYSBhdCB0aGUgZW5kIG9mIHRoZSBhY3R1YWwgbGluZS4gT3RoZXJ3aXNlIHRoZSBvdXRwdXQgY291bGRcbiAgICAgIC8vIGxvb2sgd2VpcmQgYXMgaW46XG4gICAgICAvL1xuICAgICAgLy8gICBbXG4gICAgICAvLyAgICAgMSAgICAgICAgIC8vIE5vIGNvbW1hIGF0IHRoZSBlbmQhXG4gICAgICAvLyArICAgMlxuICAgICAgLy8gICBdXG4gICAgICAvL1xuICAgICAgaWYgKGRpdmVyZ2luZ0xpbmVzICYmIGVuZHNXaXRoKGV4cGVjdGVkTGluZSwgJywnKSAmJiBleHBlY3RlZExpbmUuc2xpY2UoMCwgLTEpID09PSBhY3R1YWxMaW5lKSB7XG4gICAgICAgIGRpdmVyZ2luZ0xpbmVzID0gZmFsc2U7XG4gICAgICAgIGFjdHVhbExpbmUgKz0gJywnO1xuICAgICAgfVxuICAgICAgaWYgKGRpdmVyZ2luZ0xpbmVzKSB7XG4gICAgICAgIC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSBhbmQgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhdCBsZWFzdCBsaW5lIHRocmVlLCBhZGQgc29tZSBvZiB0aGUgZm9ybWVyIGxpbmVzIGFuZFxuICAgICAgICAvLyBhbHNvIGFkZCBkb3RzIHRvIGluZGljYXRlIHNraXBwZWQgZW50cmllcy5cbiAgICAgICAgaWYgKGN1ciA+IDEgJiYgaSA+IDIpIHtcbiAgICAgICAgICBpZiAoY3VyID4gNCkge1xuICAgICAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1ciA+IDMpIHtcbiAgICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmVzW2kgLSAyXSk7XG4gICAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXJrIHRoZSBjdXJyZW50IGxpbmUgYXMgdGhlIGxhc3QgZGl2ZXJnaW5nIG9uZS5cbiAgICAgICAgbGFzdFBvcyA9IGk7XG4gICAgICAgIC8vIEFkZCB0aGUgYWN0dWFsIGxpbmUgdG8gdGhlIHJlc3VsdCBhbmQgY2FjaGUgdGhlIGV4cGVjdGVkIGRpdmVyZ2luZ1xuICAgICAgICAvLyBsaW5lIHNvIGNvbnNlY3V0aXZlIGRpdmVyZ2luZyBsaW5lcyBzaG93IHVwIGFzICsrKy0tLSBhbmQgbm90ICstKy0rLS5cbiAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGdyZWVuLCBcIitcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGFjdHVhbExpbmUpO1xuICAgICAgICBvdGhlciArPSBcIlxcblwiLmNvbmNhdChyZWQsIFwiLVwiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRMaW5lKTtcbiAgICAgICAgcHJpbnRlZExpbmVzICs9IDI7XG4gICAgICAgIC8vIExpbmVzIGFyZSBpZGVudGljYWxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZCBhbGwgY2FjaGVkIGluZm9ybWF0aW9uIHRvIHRoZSByZXN1bHQgYmVmb3JlIGFkZGluZyBvdGhlciB0aGluZ3NcbiAgICAgICAgLy8gYW5kIHJlc2V0IHRoZSBjYWNoZS5cbiAgICAgICAgcmVzICs9IG90aGVyO1xuICAgICAgICBvdGhlciA9ICcnO1xuICAgICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBleGFjdGx5IG9uZSBsaW5lIGFib3ZlIG9yIGlmIGl0IGlzIHRoZVxuICAgICAgICAvLyB2ZXJ5IGZpcnN0IGxpbmUsIGFkZCB0aGUgbGluZSB0byB0aGUgcmVzdWx0LlxuICAgICAgICBpZiAoY3VyID09PSAxIHx8IGkgPT09IDApIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBJbnNwZWN0ZWQgb2JqZWN0IHRvIGJpZyAoU2hvdyB+MjAgcm93cyBtYXgpXG4gICAgaWYgKHByaW50ZWRMaW5lcyA+IDIwICYmIGkgPCBtYXhMaW5lcyAtIDIpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChtc2cpLmNvbmNhdChza2lwcGVkTXNnLCBcIlxcblwiKS5jb25jYXQocmVzLCBcIlxcblwiKS5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKS5jb25jYXQob3RoZXIsIFwiXFxuXCIpICsgXCJcIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFwiXCIuY29uY2F0KG1zZykuY29uY2F0KHNraXBwZWQgPyBza2lwcGVkTXNnIDogJycsIFwiXFxuXCIpLmNvbmNhdChyZXMpLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZCkuY29uY2F0KGluZGljYXRvcik7XG59XG52YXIgQXNzZXJ0aW9uRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvciwgX2luc3BlY3QkY3VzdG9tKSB7XG4gIF9pbmhlcml0cyhBc3NlcnRpb25FcnJvciwgX0Vycm9yKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihBc3NlcnRpb25FcnJvcik7XG4gIGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFzc2VydGlvbkVycm9yKTtcbiAgICBpZiAoX3R5cGVvZihvcHRpb25zKSAhPT0gJ29iamVjdCcgfHwgb3B0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdvcHRpb25zJywgJ09iamVjdCcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB2YXIgbWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcixcbiAgICAgIHN0YWNrU3RhcnRGbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZuO1xuICAgIHZhciBhY3R1YWwgPSBvcHRpb25zLmFjdHVhbCxcbiAgICAgIGV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgICB2YXIgbGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMDtcbiAgICBpZiAobWVzc2FnZSAhPSBudWxsKSB7XG4gICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFN0cmluZyhtZXNzYWdlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLnN0ZGVyciAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSkge1xuICAgICAgICAvLyBSZXNldCBvbiBlYWNoIGNhbGwgdG8gbWFrZSBzdXJlIHdlIGhhbmRsZSBkeW5hbWljYWxseSBzZXQgZW52aXJvbm1lbnRcbiAgICAgICAgLy8gdmFyaWFibGVzIGNvcnJlY3QuXG4gICAgICAgIGlmIChwcm9jZXNzLnN0ZGVyciAmJiBwcm9jZXNzLnN0ZGVyci5nZXRDb2xvckRlcHRoICYmIHByb2Nlc3Muc3RkZXJyLmdldENvbG9yRGVwdGgoKSAhPT0gMSkge1xuICAgICAgICAgIGJsdWUgPSBcIlxceDFCWzM0bVwiO1xuICAgICAgICAgIGdyZWVuID0gXCJcXHgxQlszMm1cIjtcbiAgICAgICAgICB3aGl0ZSA9IFwiXFx4MUJbMzltXCI7XG4gICAgICAgICAgcmVkID0gXCJcXHgxQlszMW1cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBibHVlID0gJyc7XG4gICAgICAgICAgZ3JlZW4gPSAnJztcbiAgICAgICAgICB3aGl0ZSA9ICcnO1xuICAgICAgICAgIHJlZCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IHRoZSBlcnJvciBzdGFjayBmcm9tIGJlaW5nIHZpc2libGUgYnkgZHVwbGljYXRpbmcgdGhlIGVycm9yXG4gICAgICAvLyBpbiBhIHZlcnkgY2xvc2Ugd2F5IHRvIHRoZSBvcmlnaW5hbCBpbiBjYXNlIGJvdGggc2lkZXMgYXJlIGFjdHVhbGx5XG4gICAgICAvLyBpbnN0YW5jZXMgb2YgRXJyb3IuXG4gICAgICBpZiAoX3R5cGVvZihhY3R1YWwpID09PSAnb2JqZWN0JyAmJiBhY3R1YWwgIT09IG51bGwgJiYgX3R5cGVvZihleHBlY3RlZCkgPT09ICdvYmplY3QnICYmIGV4cGVjdGVkICE9PSBudWxsICYmICdzdGFjaycgaW4gYWN0dWFsICYmIGFjdHVhbCBpbnN0YW5jZW9mIEVycm9yICYmICdzdGFjaycgaW4gZXhwZWN0ZWQgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBhY3R1YWwgPSBjb3B5RXJyb3IoYWN0dWFsKTtcbiAgICAgICAgZXhwZWN0ZWQgPSBjb3B5RXJyb3IoZXhwZWN0ZWQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wZXJhdG9yID09PSAnZGVlcFN0cmljdEVxdWFsJyB8fCBvcGVyYXRvciA9PT0gJ3N0cmljdEVxdWFsJykge1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNyZWF0ZUVyckRpZmYoYWN0dWFsLCBleHBlY3RlZCwgb3BlcmF0b3IpKTtcbiAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09ICdub3REZWVwU3RyaWN0RXF1YWwnIHx8IG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnKSB7XG4gICAgICAgIC8vIEluIGNhc2UgdGhlIG9iamVjdHMgYXJlIGVxdWFsIGJ1dCB0aGUgb3BlcmF0b3IgcmVxdWlyZXMgdW5lcXVhbCwgc2hvd1xuICAgICAgICAvLyB0aGUgZmlyc3Qgb2JqZWN0IGFuZCBzYXkgQSBlcXVhbHMgQlxuICAgICAgICB2YXIgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcbiAgICAgICAgdmFyIHJlcyA9IGluc3BlY3RWYWx1ZShhY3R1YWwpLnNwbGl0KCdcXG4nKTtcblxuICAgICAgICAvLyBJbiBjYXNlIFwiYWN0dWFsXCIgaXMgYW4gb2JqZWN0LCBpdCBzaG91bGQgbm90IGJlIHJlZmVyZW5jZSBlcXVhbC5cbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsKSB7XG4gICAgICAgICAgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yLm5vdFN0cmljdEVxdWFsT2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSByZW1vdmUgbGluZXMgaW4gY2FzZSBpdCBtYWtlcyBzZW5zZSB0byBjb2xsYXBzZSB0aG9zZS5cbiAgICAgICAgLy8gVE9ETzogQWNjZXB0IGVudiB0byBhbHdheXMgc2hvdyB0aGUgZnVsbCBlcnJvci5cbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAzMCkge1xuICAgICAgICAgIHJlc1syNl0gPSBcIlwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgIHdoaWxlIChyZXMubGVuZ3RoID4gMjcpIHtcbiAgICAgICAgICAgIHJlcy5wb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IHByaW50IGEgc2luZ2xlIGlucHV0LlxuICAgICAgICBpZiAocmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgXCJcIi5jb25jYXQoYmFzZSwgXCIgXCIpLmNvbmNhdChyZXNbMF0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiXFxuXFxuXCIpLmNvbmNhdChyZXMuam9pbignXFxuJyksIFwiXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9yZXMgPSBpbnNwZWN0VmFsdWUoYWN0dWFsKTtcbiAgICAgICAgdmFyIG90aGVyID0gJyc7XG4gICAgICAgIHZhciBrbm93bk9wZXJhdG9ycyA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnbm90RGVlcEVxdWFsJyB8fCBvcGVyYXRvciA9PT0gJ25vdEVxdWFsJykge1xuICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0sIFwiXFxuXFxuXCIpLmNvbmNhdChfcmVzKTtcbiAgICAgICAgICBpZiAoX3Jlcy5sZW5ndGggPiAxMDI0KSB7XG4gICAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoX3Jlcy5zbGljZSgwLCAxMDIxKSwgXCIuLi5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG90aGVyID0gXCJcIi5jb25jYXQoaW5zcGVjdFZhbHVlKGV4cGVjdGVkKSk7XG4gICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoX3Jlcy5zbGljZSgwLCA1MDkpLCBcIi4uLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG90aGVyLmxlbmd0aCA+IDUxMikge1xuICAgICAgICAgICAgb3RoZXIgPSBcIlwiLmNvbmNhdChvdGhlci5zbGljZSgwLCA1MDkpLCBcIi4uLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnZGVlcEVxdWFsJyB8fCBvcGVyYXRvciA9PT0gJ2VxdWFsJykge1xuICAgICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KGtub3duT3BlcmF0b3JzLCBcIlxcblxcblwiKS5jb25jYXQoX3JlcywgXCJcXG5cXG5zaG91bGQgZXF1YWxcXG5cXG5cIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG90aGVyID0gXCIgXCIuY29uY2F0KG9wZXJhdG9yLCBcIiBcIikuY29uY2F0KG90aGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcIlwiLmNvbmNhdChfcmVzKS5jb25jYXQob3RoZXIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gbGltaXQ7XG4gICAgX3RoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9ICFtZXNzYWdlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgJ25hbWUnLCB7XG4gICAgICB2YWx1ZTogJ0Fzc2VydGlvbkVycm9yIFtFUlJfQVNTRVJUSU9OXScsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgX3RoaXMuY29kZSA9ICdFUlJfQVNTRVJUSU9OJztcbiAgICBfdGhpcy5hY3R1YWwgPSBhY3R1YWw7XG4gICAgX3RoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICBfdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgc3RhY2tTdGFydEZuKTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBlcnJvciBjb2RlIGluIHRoZSBuYW1lLlxuICAgIF90aGlzLnN0YWNrO1xuICAgIC8vIFJlc2V0IHRoZSBuYW1lLlxuICAgIF90aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcyk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEFzc2VydGlvbkVycm9yLCBbe1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLm5hbWUsIFwiIFtcIikuY29uY2F0KHRoaXMuY29kZSwgXCJdOiBcIikuY29uY2F0KHRoaXMubWVzc2FnZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBfaW5zcGVjdCRjdXN0b20sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlY3Vyc2VUaW1lcywgY3R4KSB7XG4gICAgICAvLyBUaGlzIGxpbWl0cyB0aGUgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAgcHJvcGVydHkgZGVmYXVsdCBpbnNwZWN0aW9uIHRvXG4gICAgICAvLyB0aGUgbWluaW11bSBkZXB0aC4gT3RoZXJ3aXNlIHRob3NlIHZhbHVlcyB3b3VsZCBiZSB0b28gdmVyYm9zZSBjb21wYXJlZFxuICAgICAgLy8gdG8gdGhlIGFjdHVhbCBlcnJvciBtZXNzYWdlIHdoaWNoIGNvbnRhaW5zIGEgY29tYmluZWQgdmlldyBvZiB0aGVzZSB0d29cbiAgICAgIC8vIGlucHV0IHZhbHVlcy5cbiAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY3R4KSwge30sIHtcbiAgICAgICAgY3VzdG9tSW5zcGVjdDogZmFsc2UsXG4gICAgICAgIGRlcHRoOiAwXG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBBc3NlcnRpb25FcnJvcjtcbn0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSwgaW5zcGVjdC5jdXN0b20pO1xubW9kdWxlLmV4cG9ydHMgPSBBc3NlcnRpb25FcnJvcjsiLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL2Vycm9ycy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8zYjA0NDk2MmM0OGZlMzEzOTA1ODc3YTk2YjVkMDg5NGE1NDA0ZjZmXG5cbi8qIGVzbGludCBub2RlLWNvcmUvZG9jdW1lbnRlZC1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuLyogZXNsaW50IG5vZGUtY29yZS9hbHBoYWJldGl6ZS1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuLyogZXNsaW50IG5vZGUtY29yZS9wcmVmZXItdXRpbC1mb3JtYXQtZXJyb3JzOiBcImVycm9yXCIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgd2hvbGUgcG9pbnQgYmVoaW5kIHRoaXMgaW50ZXJuYWwgbW9kdWxlIGlzIHRvIGFsbG93IE5vZGUuanMgdG8gbm9cbi8vIGxvbmdlciBiZSBmb3JjZWQgdG8gdHJlYXQgZXZlcnkgZXJyb3IgbWVzc2FnZSBjaGFuZ2UgYXMgYSBzZW12ZXItbWFqb3Jcbi8vIGNoYW5nZS4gVGhlIE5vZGVFcnJvciBjbGFzc2VzIGhlcmUgYWxsIGV4cG9zZSBhIGBjb2RlYCBwcm9wZXJ0eSB3aG9zZVxuLy8gdmFsdWUgc3RhdGljYWxseSBhbmQgcGVybWFuZW50bHkgaWRlbnRpZmllcyB0aGUgZXJyb3IuIFdoaWxlIHRoZSBlcnJvclxuLy8gbWVzc2FnZSBtYXkgY2hhbmdlLCB0aGUgY29kZSBzaG91bGQgbm90LlxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxudmFyIGNvZGVzID0ge307XG5cbi8vIExhenkgbG9hZGVkXG52YXIgYXNzZXJ0O1xudmFyIHV0aWw7XG5mdW5jdGlvbiBjcmVhdGVFcnJvclR5cGUoY29kZSwgbWVzc2FnZSwgQmFzZSkge1xuICBpZiAoIUJhc2UpIHtcbiAgICBCYXNlID0gRXJyb3I7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH1cbiAgfVxuICB2YXIgTm9kZUVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZSkge1xuICAgIF9pbmhlcml0cyhOb2RlRXJyb3IsIF9CYXNlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE5vZGVFcnJvcik7XG4gICAgZnVuY3Rpb24gTm9kZUVycm9yKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIHZhciBfdGhpcztcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlRXJyb3IpO1xuICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpKTtcbiAgICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKE5vZGVFcnJvcik7XG4gIH0oQmFzZSk7XG4gIGNvZGVzW2NvZGVdID0gTm9kZUVycm9yO1xufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MTAuOC4wL2xpYi9pbnRlcm5hbC9lcnJvcnMuanNcbmZ1bmN0aW9uIG9uZU9mKGV4cGVjdGVkLCB0aGluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICB2YXIgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGkpO1xuICAgIH0pO1xuICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyksIFwiLCBvciBcIikgKyBleHBlY3RlZFtsZW4gLSAxXTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSwgXCIgb3IgXCIpLmNvbmNhdChleHBlY3RlZFsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChTdHJpbmcoZXhwZWN0ZWQpKTtcbiAgfVxufVxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3RhcnRzV2l0aFxuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHNlYXJjaCwgcG9zKSB7XG4gIHJldHVybiBzdHIuc3Vic3RyKCFwb3MgfHwgcG9zIDwgMCA/IDAgOiArcG9zLCBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xufVxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn1cblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2luY2x1ZGVzXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cbiAgaWYgKHN0YXJ0ICsgc2VhcmNoLmxlbmd0aCA+IHN0ci5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKHNlYXJjaCwgc3RhcnQpICE9PSAtMTtcbiAgfVxufVxuY3JlYXRlRXJyb3JUeXBlKCdFUlJfQU1CSUdVT1VTX0FSR1VNRU5UJywgJ1RoZSBcIiVzXCIgYXJndW1lbnQgaXMgYW1iaWd1b3VzLiAlcycsIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJywgZnVuY3Rpb24gKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgaWYgKGFzc2VydCA9PT0gdW5kZWZpbmVkKSBhc3NlcnQgPSByZXF1aXJlKCcuLi9hc3NlcnQnKTtcbiAgYXNzZXJ0KHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgXCInbmFtZScgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICAvLyBkZXRlcm1pbmVyOiAnbXVzdCBiZScgb3IgJ211c3Qgbm90IGJlJ1xuICB2YXIgZGV0ZXJtaW5lcjtcbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgc3RhcnRzV2l0aChleHBlY3RlZCwgJ25vdCAnKSkge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgfVxuICB2YXIgbXNnO1xuICBpZiAoZW5kc1dpdGgobmFtZSwgJyBhcmd1bWVudCcpKSB7XG4gICAgLy8gRm9yIGNhc2VzIGxpa2UgJ2ZpcnN0IGFyZ3VtZW50J1xuICAgIG1zZyA9IFwiVGhlIFwiLmNvbmNhdChuYW1lLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0eXBlID0gaW5jbHVkZXMobmFtZSwgJy4nKSA/ICdwcm9wZXJ0eScgOiAnYXJndW1lbnQnO1xuICAgIG1zZyA9IFwiVGhlIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiIFwiKS5jb25jYXQodHlwZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfVxuXG4gIC8vIFRPRE8oQnJpZGdlQVIpOiBJbXByb3ZlIHRoZSBvdXRwdXQgYnkgc2hvd2luZyBgbnVsbGAgYW5kIHNpbWlsYXIuXG4gIG1zZyArPSBcIi4gUmVjZWl2ZWQgdHlwZSBcIi5jb25jYXQoX3R5cGVvZihhY3R1YWwpKTtcbiAgcmV0dXJuIG1zZztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX0FSR19WQUxVRScsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICB2YXIgcmVhc29uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnaXMgaW52YWxpZCc7XG4gIGlmICh1dGlsID09PSB1bmRlZmluZWQpIHV0aWwgPSByZXF1aXJlKCd1dGlsLycpO1xuICB2YXIgaW5zcGVjdGVkID0gdXRpbC5pbnNwZWN0KHZhbHVlKTtcbiAgaWYgKGluc3BlY3RlZC5sZW5ndGggPiAxMjgpIHtcbiAgICBpbnNwZWN0ZWQgPSBcIlwiLmNvbmNhdChpbnNwZWN0ZWQuc2xpY2UoMCwgMTI4KSwgXCIuLi5cIik7XG4gIH1cbiAgcmV0dXJuIFwiVGhlIGFyZ3VtZW50ICdcIi5jb25jYXQobmFtZSwgXCInIFwiKS5jb25jYXQocmVhc29uLCBcIi4gUmVjZWl2ZWQgXCIpLmNvbmNhdChpbnNwZWN0ZWQpO1xufSwgVHlwZUVycm9yLCBSYW5nZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFJywgZnVuY3Rpb24gKGlucHV0LCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgdHlwZTtcbiAgaWYgKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICB0eXBlID0gXCJpbnN0YW5jZSBvZiBcIi5jb25jYXQodmFsdWUuY29uc3RydWN0b3IubmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdHlwZSA9IFwidHlwZSBcIi5jb25jYXQoX3R5cGVvZih2YWx1ZSkpO1xuICB9XG4gIHJldHVybiBcIkV4cGVjdGVkIFwiLmNvbmNhdChpbnB1dCwgXCIgdG8gYmUgcmV0dXJuZWQgZnJvbSB0aGUgXFxcIlwiKS5jb25jYXQobmFtZSwgXCJcXFwiXCIpICsgXCIgZnVuY3Rpb24gYnV0IGdvdCBcIi5jb25jYXQodHlwZSwgXCIuXCIpO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX01JU1NJTkdfQVJHUycsIGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICBpZiAoYXNzZXJ0ID09PSB1bmRlZmluZWQpIGFzc2VydCA9IHJlcXVpcmUoJy4uL2Fzc2VydCcpO1xuICBhc3NlcnQoYXJncy5sZW5ndGggPiAwLCAnQXQgbGVhc3Qgb25lIGFyZyBuZWVkcyB0byBiZSBzcGVjaWZpZWQnKTtcbiAgdmFyIG1zZyA9ICdUaGUgJztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICBhcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gXCJcXFwiXCIuY29uY2F0KGEsIFwiXFxcIlwiKTtcbiAgfSk7XG4gIHN3aXRjaCAobGVuKSB7XG4gICAgY2FzZSAxOlxuICAgICAgbXNnICs9IFwiXCIuY29uY2F0KGFyZ3NbMF0sIFwiIGFyZ3VtZW50XCIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgbXNnICs9IFwiXCIuY29uY2F0KGFyZ3NbMF0sIFwiIGFuZCBcIikuY29uY2F0KGFyZ3NbMV0sIFwiIGFyZ3VtZW50c1wiKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBtc2cgKz0gYXJncy5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpO1xuICAgICAgbXNnICs9IFwiLCBhbmQgXCIuY29uY2F0KGFyZ3NbbGVuIC0gMV0sIFwiIGFyZ3VtZW50c1wiKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBcIlwiLmNvbmNhdChtc2csIFwiIG11c3QgYmUgc3BlY2lmaWVkXCIpO1xufSwgVHlwZUVycm9yKTtcbm1vZHVsZS5leHBvcnRzLmNvZGVzID0gY29kZXM7IiwiLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC91dGlsL2NvbXBhcmlzb25zLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzExMmNjN2MyNzU1MTI1NGFhMmIxNzA5OGZiNzc0ODY3ZjA1ZWQwZDlcblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHQucmV0dXJuICYmICh1ID0gdC5yZXR1cm4oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxudmFyIHJlZ2V4RmxhZ3NTdXBwb3J0ZWQgPSAvYS9nLmZsYWdzICE9PSB1bmRlZmluZWQ7XG52YXIgYXJyYXlGcm9tU2V0ID0gZnVuY3Rpb24gYXJyYXlGcm9tU2V0KHNldCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFycmF5LnB1c2godmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIGFycmF5O1xufTtcbnZhciBhcnJheUZyb21NYXAgPSBmdW5jdGlvbiBhcnJheUZyb21NYXAobWFwKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICBtYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHJldHVybiBhcnJheS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0pO1xuICByZXR1cm4gYXJyYXk7XG59O1xudmFyIG9iamVjdElzID0gT2JqZWN0LmlzID8gT2JqZWN0LmlzIDogcmVxdWlyZSgnb2JqZWN0LWlzJyk7XG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbXTtcbn07XG52YXIgbnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gPyBOdW1iZXIuaXNOYU4gOiByZXF1aXJlKCdpcy1uYW4nKTtcbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgcmV0dXJuIGYuY2FsbC5iaW5kKGYpO1xufVxudmFyIGhhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlKTtcbnZhciBvYmplY3RUb1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xudmFyIF9yZXF1aXJlJHR5cGVzID0gcmVxdWlyZSgndXRpbC8nKS50eXBlcyxcbiAgaXNBbnlBcnJheUJ1ZmZlciA9IF9yZXF1aXJlJHR5cGVzLmlzQW55QXJyYXlCdWZmZXIsXG4gIGlzQXJyYXlCdWZmZXJWaWV3ID0gX3JlcXVpcmUkdHlwZXMuaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzRGF0ZSA9IF9yZXF1aXJlJHR5cGVzLmlzRGF0ZSxcbiAgaXNNYXAgPSBfcmVxdWlyZSR0eXBlcy5pc01hcCxcbiAgaXNSZWdFeHAgPSBfcmVxdWlyZSR0eXBlcy5pc1JlZ0V4cCxcbiAgaXNTZXQgPSBfcmVxdWlyZSR0eXBlcy5pc1NldCxcbiAgaXNOYXRpdmVFcnJvciA9IF9yZXF1aXJlJHR5cGVzLmlzTmF0aXZlRXJyb3IsXG4gIGlzQm94ZWRQcmltaXRpdmUgPSBfcmVxdWlyZSR0eXBlcy5pc0JveGVkUHJpbWl0aXZlLFxuICBpc051bWJlck9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzTnVtYmVyT2JqZWN0LFxuICBpc1N0cmluZ09iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzU3RyaW5nT2JqZWN0LFxuICBpc0Jvb2xlYW5PYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc0Jvb2xlYW5PYmplY3QsXG4gIGlzQmlnSW50T2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNCaWdJbnRPYmplY3QsXG4gIGlzU3ltYm9sT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNTeW1ib2xPYmplY3QsXG4gIGlzRmxvYXQzMkFycmF5ID0gX3JlcXVpcmUkdHlwZXMuaXNGbG9hdDMyQXJyYXksXG4gIGlzRmxvYXQ2NEFycmF5ID0gX3JlcXVpcmUkdHlwZXMuaXNGbG9hdDY0QXJyYXk7XG5mdW5jdGlvbiBpc05vbkluZGV4KGtleSkge1xuICBpZiAoa2V5Lmxlbmd0aCA9PT0gMCB8fCBrZXkubGVuZ3RoID4gMTApIHJldHVybiB0cnVlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb2RlID0ga2V5LmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gNTcpIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIFRoZSBtYXhpbXVtIHNpemUgZm9yIGFuIGFycmF5IGlzIDIgKiogMzIgLTEuXG4gIHJldHVybiBrZXkubGVuZ3RoID09PSAxMCAmJiBrZXkgPj0gTWF0aC5wb3coMiwgMzIpO1xufVxuZnVuY3Rpb24gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkuZmlsdGVyKGlzTm9uSW5kZXgpLmNvbmNhdChvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpLmZpbHRlcihPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmJpbmQodmFsdWUpKSk7XG59XG5cbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82ODBlOWU1ZTQ4OGYyMmFhYzI3NTk5YTU3ZGM4NDRhNjMxNTkyOGRkL2luZGV4LmpzXG4vLyBvcmlnaW5hbCBub3RpY2U6XG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgeCA9IGEubGVuZ3RoO1xuICB2YXIgeSA9IGIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICh4IDwgeSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoeSA8IHgpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbnZhciBPTkxZX0VOVU1FUkFCTEUgPSB1bmRlZmluZWQ7XG52YXIga1N0cmljdCA9IHRydWU7XG52YXIga0xvb3NlID0gZmFsc2U7XG52YXIga05vSXRlcmF0b3IgPSAwO1xudmFyIGtJc0FycmF5ID0gMTtcbnZhciBrSXNTZXQgPSAyO1xudmFyIGtJc01hcCA9IDM7XG5cbi8vIENoZWNrIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSBzb3VyY2UgYW5kIGZsYWdzXG5mdW5jdGlvbiBhcmVTaW1pbGFyUmVnRXhwcyhhLCBiKSB7XG4gIHJldHVybiByZWdleEZsYWdzU3VwcG9ydGVkID8gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3MgOiBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSkgPT09IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChiKTtcbn1cbmZ1bmN0aW9uIGFyZVNpbWlsYXJGbG9hdEFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBhLmJ5dGVMZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgaWYgKGFbb2Zmc2V0XSAhPT0gYltvZmZzZXRdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYXJlU2ltaWxhclR5cGVkQXJyYXlzKGEsIGIpIHtcbiAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLCBhLmJ5dGVPZmZzZXQsIGEuYnl0ZUxlbmd0aCksIG5ldyBVaW50OEFycmF5KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aCkpID09PSAwO1xufVxuZnVuY3Rpb24gYXJlRXF1YWxBcnJheUJ1ZmZlcnMoYnVmMSwgYnVmMikge1xuICByZXR1cm4gYnVmMS5ieXRlTGVuZ3RoID09PSBidWYyLmJ5dGVMZW5ndGggJiYgY29tcGFyZShuZXcgVWludDhBcnJheShidWYxKSwgbmV3IFVpbnQ4QXJyYXkoYnVmMikpID09PSAwO1xufVxuZnVuY3Rpb24gaXNFcXVhbEJveGVkUHJpbWl0aXZlKHZhbDEsIHZhbDIpIHtcbiAgaWYgKGlzTnVtYmVyT2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyT2JqZWN0KHZhbDIpICYmIG9iamVjdElzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpLCBOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKSk7XG4gIH1cbiAgaWYgKGlzU3RyaW5nT2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nT2JqZWN0KHZhbDIpICYmIFN0cmluZy5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbiAgfVxuICBpZiAoaXNCb29sZWFuT2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzQm9vbGVhbk9iamVjdCh2YWwyKSAmJiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbiAgfVxuICBpZiAoaXNCaWdJbnRPYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNCaWdJbnRPYmplY3QodmFsMikgJiYgQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xuICB9XG4gIHJldHVybiBpc1N5bWJvbE9iamVjdCh2YWwyKSAmJiBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG59XG5cbi8vIE5vdGVzOiBUeXBlIHRhZ3MgYXJlIGhpc3RvcmljYWwgW1tDbGFzc11dIHByb3BlcnRpZXMgdGhhdCBjYW4gYmUgc2V0IGJ5XG4vLyBGdW5jdGlvblRlbXBsYXRlOjpTZXRDbGFzc05hbWUoKSBpbiBDKysgb3IgU3ltYm9sLnRvU3RyaW5nVGFnIGluIEpTXG4vLyBhbmQgcmV0cmlldmVkIHVzaW5nIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopIGluIEpTXG4vLyBTZWUgaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xuLy8gZm9yIGEgbGlzdCBvZiB0YWdzIHByZS1kZWZpbmVkIGluIHRoZSBzcGVjLlxuLy8gVGhlcmUgYXJlIHNvbWUgdW5zcGVjaWZpZWQgdGFncyBpbiB0aGUgd2lsZCB0b28gKGUuZy4gdHlwZWQgYXJyYXkgdGFncykuXG4vLyBTaW5jZSB0YWdzIGNhbiBiZSBhbHRlcmVkLCB0aGV5IG9ubHkgc2VydmUgZmFzdCBmYWlsdXJlc1xuLy9cbi8vIFR5cGVkIGFycmF5cyBhbmQgYnVmZmVycyBhcmUgY2hlY2tlZCBieSBjb21wYXJpbmcgdGhlIGNvbnRlbnQgaW4gdGhlaXJcbi8vIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIuIFRoaXMgb3B0aW1pemF0aW9uIHJlcXVpcmVzIHRoYXQgaXQnc1xuLy8gcmVhc29uYWJsZSB0byBpbnRlcnByZXQgdGhlaXIgdW5kZXJseWluZyBtZW1vcnkgaW4gdGhlIHNhbWUgd2F5LFxuLy8gd2hpY2ggaXMgY2hlY2tlZCBieSBjb21wYXJpbmcgdGhlaXIgdHlwZSB0YWdzLlxuLy8gKGUuZy4gYSBVaW50OEFycmF5IGFuZCBhIFVpbnQxNkFycmF5IHdpdGggdGhlIHNhbWUgbWVtb3J5IGNvbnRlbnRcbi8vIGNvdWxkIHN0aWxsIGJlIGRpZmZlcmVudCBiZWNhdXNlIHRoZXkgd2lsbCBiZSBpbnRlcnByZXRlZCBkaWZmZXJlbnRseSkuXG4vL1xuLy8gRm9yIHN0cmljdCBjb21wYXJpc29uLCBvYmplY3RzIHNob3VsZCBoYXZlXG4vLyBhKSBUaGUgc2FtZSBidWlsdC1pbiB0eXBlIHRhZ3Ncbi8vIGIpIFRoZSBzYW1lIHByb3RvdHlwZXMuXG5cbmZ1bmN0aW9uIGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MpIHtcbiAgLy8gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAodmFsMSA9PT0gdmFsMikge1xuICAgIGlmICh2YWwxICE9PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gc3RyaWN0ID8gb2JqZWN0SXModmFsMSwgdmFsMikgOiB0cnVlO1xuICB9XG5cbiAgLy8gQ2hlY2sgbW9yZSBjbG9zZWx5IGlmIHZhbDEgYW5kIHZhbDIgYXJlIGVxdWFsLlxuICBpZiAoc3RyaWN0KSB7XG4gICAgaWYgKF90eXBlb2YodmFsMSkgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbDEgPT09ICdudW1iZXInICYmIG51bWJlcklzTmFOKHZhbDEpICYmIG51bWJlcklzTmFOKHZhbDIpO1xuICAgIH1cbiAgICBpZiAoX3R5cGVvZih2YWwyKSAhPT0gJ29iamVjdCcgfHwgdmFsMSA9PT0gbnVsbCB8fCB2YWwyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsMSkgIT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsMSA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDEpICE9PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHZhbDIgPT09IG51bGwgfHwgX3R5cGVvZih2YWwyKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICByZXR1cm4gdmFsMSA9PSB2YWwyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsMiA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB2YXIgdmFsMVRhZyA9IG9iamVjdFRvU3RyaW5nKHZhbDEpO1xuICB2YXIgdmFsMlRhZyA9IG9iamVjdFRvU3RyaW5nKHZhbDIpO1xuICBpZiAodmFsMVRhZyAhPT0gdmFsMlRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwxKSkge1xuICAgIC8vIENoZWNrIGZvciBzcGFyc2UgYXJyYXlzIGFuZCBnZW5lcmFsIGZhc3QgcGF0aFxuICAgIGlmICh2YWwxLmxlbmd0aCAhPT0gdmFsMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGtleXMxID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDEsIE9OTFlfRU5VTUVSQUJMRSk7XG4gICAgdmFyIGtleXMyID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDIsIE9OTFlfRU5VTUVSQUJMRSk7XG4gICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNBcnJheSwga2V5czEpO1xuICB9XG4gIC8vIFticm93c2VyaWZ5XSBUaGlzIHRyaWdnZXJzIG9uIGNlcnRhaW4gdHlwZXMgaW4gSUUgKE1hcC9TZXQpIHNvIHdlIGRvbid0XG4gIC8vIHdhbid0IHRvIGVhcmx5IHJldHVybiBvdXQgb2YgdGhlIHJlc3Qgb2YgdGhlIGNoZWNrcy4gSG93ZXZlciB3ZSBjYW4gY2hlY2tcbiAgLy8gaWYgdGhlIHNlY29uZCB2YWx1ZSBpcyBvbmUgb2YgdGhlc2UgdmFsdWVzIGFuZCB0aGUgZmlyc3QgaXNuJ3QuXG4gIGlmICh2YWwxVGFnID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIC8vIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvcik7XG4gICAgaWYgKCFpc01hcCh2YWwxKSAmJiBpc01hcCh2YWwyKSB8fCAhaXNTZXQodmFsMSkgJiYgaXNTZXQodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRGF0ZSh2YWwxKSkge1xuICAgIGlmICghaXNEYXRlKHZhbDIpIHx8IERhdGUucHJvdG90eXBlLmdldFRpbWUuY2FsbCh2YWwxKSAhPT0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZS5jYWxsKHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHZhbDEpKSB7XG4gICAgaWYgKCFpc1JlZ0V4cCh2YWwyKSB8fCAhYXJlU2ltaWxhclJlZ0V4cHModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNOYXRpdmVFcnJvcih2YWwxKSB8fCB2YWwxIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAvLyBEbyBub3QgY29tcGFyZSB0aGUgc3RhY2sgYXMgaXQgbWlnaHQgZGlmZmVyIGV2ZW4gdGhvdWdoIHRoZSBlcnJvciBpdHNlbGZcbiAgICAvLyBpcyBvdGhlcndpc2UgaWRlbnRpY2FsLlxuICAgIGlmICh2YWwxLm1lc3NhZ2UgIT09IHZhbDIubWVzc2FnZSB8fCB2YWwxLm5hbWUgIT09IHZhbDIubmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0FycmF5QnVmZmVyVmlldyh2YWwxKSkge1xuICAgIGlmICghc3RyaWN0ICYmIChpc0Zsb2F0MzJBcnJheSh2YWwxKSB8fCBpc0Zsb2F0NjRBcnJheSh2YWwxKSkpIHtcbiAgICAgIGlmICghYXJlU2ltaWxhckZsb2F0QXJyYXlzKHZhbDEsIHZhbDIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhcmVTaW1pbGFyVHlwZWRBcnJheXModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQnVmZmVyLmNvbXBhcmUgcmV0dXJucyB0cnVlLCBzbyB2YWwxLmxlbmd0aCA9PT0gdmFsMi5sZW5ndGguIElmIHRoZXkgYm90aFxuICAgIC8vIG9ubHkgY29udGFpbiBudW1lcmljIGtleXMsIHdlIGRvbid0IG5lZWQgdG8gZXhhbSBmdXJ0aGVyIHRoYW4gY2hlY2tpbmdcbiAgICAvLyB0aGUgc3ltYm9scy5cbiAgICB2YXIgX2tleXMgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMSwgT05MWV9FTlVNRVJBQkxFKTtcbiAgICB2YXIgX2tleXMyID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDIsIE9OTFlfRU5VTUVSQUJMRSk7XG4gICAgaWYgKF9rZXlzLmxlbmd0aCAhPT0gX2tleXMyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga05vSXRlcmF0b3IsIF9rZXlzKTtcbiAgfSBlbHNlIGlmIChpc1NldCh2YWwxKSkge1xuICAgIGlmICghaXNTZXQodmFsMikgfHwgdmFsMS5zaXplICE9PSB2YWwyLnNpemUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc1NldCk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsMSkpIHtcbiAgICBpZiAoIWlzTWFwKHZhbDIpIHx8IHZhbDEuc2l6ZSAhPT0gdmFsMi5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNNYXApO1xuICB9IGVsc2UgaWYgKGlzQW55QXJyYXlCdWZmZXIodmFsMSkpIHtcbiAgICBpZiAoIWFyZUVxdWFsQXJyYXlCdWZmZXJzKHZhbDEsIHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQm94ZWRQcmltaXRpdmUodmFsMSkgJiYgIWlzRXF1YWxCb3hlZFByaW1pdGl2ZSh2YWwxLCB2YWwyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga05vSXRlcmF0b3IpO1xufVxuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZXModmFsLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwsIGspO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGl0ZXJhdGlvblR5cGUsIGFLZXlzKSB7XG4gIC8vIEZvciBhbGwgcmVtYWluaW5nIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5LCBvYmplY3RzIGFuZCBNYXBzLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5IGhhdmluZzpcbiAgLy8gYSkgVGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAvLyBiKSBUaGUgc2FtZSBzZXQgb2Yga2V5cy9pbmRleGVzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpXG4gIC8vIGMpIEVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleS9pbmRleFxuICAvLyBkKSBGb3IgU2V0cyBhbmQgTWFwcywgZXF1YWwgY29udGVudHNcbiAgLy8gTm90ZTogdGhpcyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDUpIHtcbiAgICBhS2V5cyA9IE9iamVjdC5rZXlzKHZhbDEpO1xuICAgIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKHZhbDIpO1xuXG4gICAgLy8gVGhlIHBhaXIgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzLlxuICAgIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIENoZWFwIGtleSB0ZXN0XG4gIHZhciBpID0gMDtcbiAgZm9yICg7IGkgPCBhS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkodmFsMiwgYUtleXNbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChzdHJpY3QgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgIHZhciBzeW1ib2xLZXlzQSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwxKTtcbiAgICBpZiAoc3ltYm9sS2V5c0EubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHN5bWJvbEtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBzeW1ib2xLZXlzQVtpXTtcbiAgICAgICAgaWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDEsIGtleSkpIHtcbiAgICAgICAgICBpZiAoIXByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDIsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYUtleXMucHVzaChrZXkpO1xuICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJc0VudW1lcmFibGUodmFsMiwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHN5bWJvbEtleXNCID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbDIpO1xuICAgICAgaWYgKHN5bWJvbEtleXNBLmxlbmd0aCAhPT0gc3ltYm9sS2V5c0IubGVuZ3RoICYmIGdldEVudW1lcmFibGVzKHZhbDIsIHN5bWJvbEtleXNCKS5sZW5ndGggIT09IGNvdW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9zeW1ib2xLZXlzQiA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwyKTtcbiAgICAgIGlmIChfc3ltYm9sS2V5c0IubGVuZ3RoICE9PSAwICYmIGdldEVudW1lcmFibGVzKHZhbDIsIF9zeW1ib2xLZXlzQikubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGFLZXlzLmxlbmd0aCA9PT0gMCAmJiAoaXRlcmF0aW9uVHlwZSA9PT0ga05vSXRlcmF0b3IgfHwgaXRlcmF0aW9uVHlwZSA9PT0ga0lzQXJyYXkgJiYgdmFsMS5sZW5ndGggPT09IDAgfHwgdmFsMS5zaXplID09PSAwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gVXNlIG1lbW9zIHRvIGhhbmRsZSBjeWNsZXMuXG4gIGlmIChtZW1vcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWVtb3MgPSB7XG4gICAgICB2YWwxOiBuZXcgTWFwKCksXG4gICAgICB2YWwyOiBuZXcgTWFwKCksXG4gICAgICBwb3NpdGlvbjogMFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgcHJldmVudCB1cCB0byB0d28gbWFwLmhhcyh4KSBjYWxscyBieSBkaXJlY3RseSByZXRyaWV2aW5nIHRoZSB2YWx1ZVxuICAgIC8vIGFuZCBjaGVja2luZyBmb3IgdW5kZWZpbmVkLiBUaGUgbWFwIGNhbiBvbmx5IGNvbnRhaW4gbnVtYmVycywgc28gaXQgaXNcbiAgICAvLyBzYWZlIHRvIGNoZWNrIGZvciB1bmRlZmluZWQgb25seS5cbiAgICB2YXIgdmFsMk1lbW9BID0gbWVtb3MudmFsMS5nZXQodmFsMSk7XG4gICAgaWYgKHZhbDJNZW1vQSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgdmFsMk1lbW9CID0gbWVtb3MudmFsMi5nZXQodmFsMik7XG4gICAgICBpZiAodmFsMk1lbW9CICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbDJNZW1vQSA9PT0gdmFsMk1lbW9CO1xuICAgICAgfVxuICAgIH1cbiAgICBtZW1vcy5wb3NpdGlvbisrO1xuICB9XG4gIG1lbW9zLnZhbDEuc2V0KHZhbDEsIG1lbW9zLnBvc2l0aW9uKTtcbiAgbWVtb3MudmFsMi5zZXQodmFsMiwgbWVtb3MucG9zaXRpb24pO1xuICB2YXIgYXJlRXEgPSBvYmpFcXVpdih2YWwxLCB2YWwyLCBzdHJpY3QsIGFLZXlzLCBtZW1vcywgaXRlcmF0aW9uVHlwZSk7XG4gIG1lbW9zLnZhbDEuZGVsZXRlKHZhbDEpO1xuICBtZW1vcy52YWwyLmRlbGV0ZSh2YWwyKTtcbiAgcmV0dXJuIGFyZUVxO1xufVxuZnVuY3Rpb24gc2V0SGFzRXF1YWxFbGVtZW50KHNldCwgdmFsMSwgc3RyaWN0LCBtZW1vKSB7XG4gIC8vIEdvIGxvb2tpbmcuXG4gIHZhciBzZXRWYWx1ZXMgPSBhcnJheUZyb21TZXQoc2V0KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsMiA9IHNldFZhbHVlc1tpXTtcbiAgICBpZiAoaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBtYXRjaGluZyBlbGVtZW50IHRvIG1ha2Ugc3VyZSB3ZSBkbyBub3QgY2hlY2sgdGhhdCBhZ2Fpbi5cbiAgICAgIHNldC5kZWxldGUodmFsMik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9FcXVhbGl0eV9jb21wYXJpc29uc19hbmRfc2FtZW5lc3MjTG9vc2VfZXF1YWxpdHlfdXNpbmdcbi8vIFNhZGx5IGl0IGlzIG5vdCBwb3NzaWJsZSB0byBkZXRlY3QgY29ycmVzcG9uZGluZyB2YWx1ZXMgcHJvcGVybHkgaW4gY2FzZSB0aGVcbi8vIHR5cGUgaXMgYSBzdHJpbmcsIG51bWJlciwgYmlnaW50IG9yIGJvb2xlYW4uIFRoZSByZWFzb24gaXMgdGhhdCB0aG9zZSB2YWx1ZXNcbi8vIGNhbiBtYXRjaCBsb3RzIG9mIGRpZmZlcmVudCBzdHJpbmcgdmFsdWVzIChlLmcuLCAxbiA9PSAnKzAwMDAxJykuXG5mdW5jdGlvbiBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSkge1xuICBzd2l0Y2ggKF90eXBlb2YocHJpbSkpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIC8vIE9ubHkgcGFzcyBpbiBudWxsIGFzIG9iamVjdCFcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcHJpbSA9ICtwcmltO1xuICAgIC8vIExvb3NlIGVxdWFsIGVudHJpZXMgZXhpc3Qgb25seSBpZiB0aGUgc3RyaW5nIGlzIHBvc3NpYmxlIHRvIGNvbnZlcnQgdG9cbiAgICAvLyBhIHJlZ3VsYXIgbnVtYmVyIGFuZCBub3QgTmFOLlxuICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBpZiAobnVtYmVySXNOYU4ocHJpbSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2V0TWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIHByaW0pIHtcbiAgdmFyIGFsdFZhbHVlID0gZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzKHByaW0pO1xuICBpZiAoYWx0VmFsdWUgIT0gbnVsbCkgcmV0dXJuIGFsdFZhbHVlO1xuICByZXR1cm4gYi5oYXMoYWx0VmFsdWUpICYmICFhLmhhcyhhbHRWYWx1ZSk7XG59XG5mdW5jdGlvbiBtYXBNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgcHJpbSwgaXRlbSwgbWVtbykge1xuICB2YXIgYWx0VmFsdWUgPSBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSk7XG4gIGlmIChhbHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGFsdFZhbHVlO1xuICB9XG4gIHZhciBjdXJCID0gYi5nZXQoYWx0VmFsdWUpO1xuICBpZiAoY3VyQiA9PT0gdW5kZWZpbmVkICYmICFiLmhhcyhhbHRWYWx1ZSkgfHwgIWlubmVyRGVlcEVxdWFsKGl0ZW0sIGN1ckIsIGZhbHNlLCBtZW1vKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gIWEuaGFzKGFsdFZhbHVlKSAmJiBpbm5lckRlZXBFcXVhbChpdGVtLCBjdXJCLCBmYWxzZSwgbWVtbyk7XG59XG5mdW5jdGlvbiBzZXRFcXVpdihhLCBiLCBzdHJpY3QsIG1lbW8pIHtcbiAgLy8gVGhpcyBpcyBhIGxhemlseSBpbml0aWF0ZWQgU2V0IG9mIGVudHJpZXMgd2hpY2ggaGF2ZSB0byBiZSBjb21wYXJlZFxuICAvLyBwYWlyd2lzZS5cbiAgdmFyIHNldCA9IG51bGw7XG4gIHZhciBhVmFsdWVzID0gYXJyYXlGcm9tU2V0KGEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsID0gYVZhbHVlc1tpXTtcbiAgICAvLyBOb3RlOiBDaGVja2luZyBmb3IgdGhlIG9iamVjdHMgZmlyc3QgaW1wcm92ZXMgdGhlIHBlcmZvcm1hbmNlIGZvciBvYmplY3RcbiAgICAvLyBoZWF2eSBzZXRzIGJ1dCBpdCBpcyBhIG1pbm9yIHNsb3cgZG93biBmb3IgcHJpbWl0aXZlcy4gQXMgdGhleSBhcmUgZmFzdFxuICAgIC8vIHRvIGNoZWNrIHRoaXMgaW1wcm92ZXMgdGhlIHdvcnN0IGNhc2Ugc2NlbmFyaW8gaW5zdGVhZC5cbiAgICBpZiAoX3R5cGVvZih2YWwpID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfVxuICAgICAgLy8gSWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBkb2Vzbid0IGV4aXN0IGluIHRoZSBzZWNvbmQgc2V0IGl0cyBhbiBub3QgbnVsbFxuICAgICAgLy8gb2JqZWN0IChvciBub24gc3RyaWN0IG9ubHk6IGEgbm90IG1hdGNoaW5nIHByaW1pdGl2ZSkgd2UnbGwgbmVlZCB0byBnb1xuICAgICAgLy8gaHVudGluZyBmb3Igc29tZXRoaW5nIHRoYXRzIGRlZXAtKHN0cmljdC0pZXF1YWwgdG8gaXQuIFRvIG1ha2UgdGhpc1xuICAgICAgLy8gTyhuIGxvZyBuKSBjb21wbGV4aXR5IHdlIGhhdmUgdG8gY29weSB0aGVzZSB2YWx1ZXMgaW4gYSBuZXcgc2V0IGZpcnN0LlxuICAgICAgc2V0LmFkZCh2YWwpO1xuICAgIH0gZWxzZSBpZiAoIWIuaGFzKHZhbCkpIHtcbiAgICAgIGlmIChzdHJpY3QpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gRmFzdCBwYXRoIHRvIGRldGVjdCBtaXNzaW5nIHN0cmluZywgc3ltYm9sLCB1bmRlZmluZWQgYW5kIG51bGwgdmFsdWVzLlxuICAgICAgaWYgKCFzZXRNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgdmFsKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgIH1cbiAgICAgIHNldC5hZGQodmFsKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNldCAhPT0gbnVsbCkge1xuICAgIHZhciBiVmFsdWVzID0gYXJyYXlGcm9tU2V0KGIpO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBiVmFsdWVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF92YWwgPSBiVmFsdWVzW19pXTtcbiAgICAgIC8vIFdlIGhhdmUgdG8gY2hlY2sgaWYgYSBwcmltaXRpdmUgdmFsdWUgaXMgYWxyZWFkeVxuICAgICAgLy8gbWF0Y2hpbmcgYW5kIG9ubHkgaWYgaXQncyBub3QsIGdvIGh1bnRpbmcgZm9yIGl0LlxuICAgICAgaWYgKF90eXBlb2YoX3ZhbCkgPT09ICdvYmplY3QnICYmIF92YWwgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCBfdmFsLCBzdHJpY3QsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgIWEuaGFzKF92YWwpICYmICFzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCBfdmFsLCBzdHJpY3QsIG1lbW8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNldC5zaXplID09PSAwO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbWFwSGFzRXF1YWxFbnRyeShzZXQsIG1hcCwga2V5MSwgaXRlbTEsIHN0cmljdCwgbWVtbykge1xuICAvLyBUbyBiZSBhYmxlIHRvIGhhbmRsZSBjYXNlcyBsaWtlOlxuICAvLyAgIE1hcChbW3t9LCAnYSddLCBbe30sICdiJ11dKSB2cyBNYXAoW1t7fSwgJ2InXSwgW3t9LCAnYSddXSlcbiAgLy8gLi4uIHdlIG5lZWQgdG8gY29uc2lkZXIgKmFsbCogbWF0Y2hpbmcga2V5cywgbm90IGp1c3QgdGhlIGZpcnN0IHdlIGZpbmQuXG4gIHZhciBzZXRWYWx1ZXMgPSBhcnJheUZyb21TZXQoc2V0KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5MiA9IHNldFZhbHVlc1tpXTtcbiAgICBpZiAoaW5uZXJEZWVwRXF1YWwoa2V5MSwga2V5Miwgc3RyaWN0LCBtZW1vKSAmJiBpbm5lckRlZXBFcXVhbChpdGVtMSwgbWFwLmdldChrZXkyKSwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgc2V0LmRlbGV0ZShrZXkyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBtYXBFcXVpdihhLCBiLCBzdHJpY3QsIG1lbW8pIHtcbiAgdmFyIHNldCA9IG51bGw7XG4gIHZhciBhRW50cmllcyA9IGFycmF5RnJvbU1hcChhKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfYUVudHJpZXMkaSA9IF9zbGljZWRUb0FycmF5KGFFbnRyaWVzW2ldLCAyKSxcbiAgICAgIGtleSA9IF9hRW50cmllcyRpWzBdLFxuICAgICAgaXRlbTEgPSBfYUVudHJpZXMkaVsxXTtcbiAgICBpZiAoX3R5cGVvZihrZXkpID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfVxuICAgICAgc2V0LmFkZChrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCeSBkaXJlY3RseSByZXRyaWV2aW5nIHRoZSB2YWx1ZSB3ZSBwcmV2ZW50IGFub3RoZXIgYi5oYXMoa2V5KSBjaGVjayBpblxuICAgICAgLy8gYWxtb3N0IGFsbCBwb3NzaWJsZSBjYXNlcy5cbiAgICAgIHZhciBpdGVtMiA9IGIuZ2V0KGtleSk7XG4gICAgICBpZiAoaXRlbTIgPT09IHVuZGVmaW5lZCAmJiAhYi5oYXMoa2V5KSB8fCAhaW5uZXJEZWVwRXF1YWwoaXRlbTEsIGl0ZW0yLCBzdHJpY3QsIG1lbW8pKSB7XG4gICAgICAgIGlmIChzdHJpY3QpIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gRmFzdCBwYXRoIHRvIGRldGVjdCBtaXNzaW5nIHN0cmluZywgc3ltYm9sLCB1bmRlZmluZWQgYW5kIG51bGxcbiAgICAgICAgLy8ga2V5cy5cbiAgICAgICAgaWYgKCFtYXBNaWdodEhhdmVMb29zZVByaW0oYSwgYiwga2V5LCBpdGVtMSwgbWVtbykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBzZXQuYWRkKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChzZXQgIT09IG51bGwpIHtcbiAgICB2YXIgYkVudHJpZXMgPSBhcnJheUZyb21NYXAoYik7XG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgYkVudHJpZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgdmFyIF9iRW50cmllcyRfaSA9IF9zbGljZWRUb0FycmF5KGJFbnRyaWVzW19pMl0sIDIpLFxuICAgICAgICBfa2V5ID0gX2JFbnRyaWVzJF9pWzBdLFxuICAgICAgICBpdGVtID0gX2JFbnRyaWVzJF9pWzFdO1xuICAgICAgaWYgKF90eXBlb2YoX2tleSkgPT09ICdvYmplY3QnICYmIF9rZXkgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFtYXBIYXNFcXVhbEVudHJ5KHNldCwgYSwgX2tleSwgaXRlbSwgc3RyaWN0LCBtZW1vKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmICghYS5oYXMoX2tleSkgfHwgIWlubmVyRGVlcEVxdWFsKGEuZ2V0KF9rZXkpLCBpdGVtLCBmYWxzZSwgbWVtbykpICYmICFtYXBIYXNFcXVhbEVudHJ5KHNldCwgYSwgX2tleSwgaXRlbSwgZmFsc2UsIG1lbW8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNldC5zaXplID09PSAwO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgc3RyaWN0LCBrZXlzLCBtZW1vcywgaXRlcmF0aW9uVHlwZSkge1xuICAvLyBTZXRzIGFuZCBtYXBzIGRvbid0IGhhdmUgdGhlaXIgZW50cmllcyBhY2Nlc3NpYmxlIHZpYSBub3JtYWwgb2JqZWN0XG4gIC8vIHByb3BlcnRpZXMuXG4gIHZhciBpID0gMDtcbiAgaWYgKGl0ZXJhdGlvblR5cGUgPT09IGtJc1NldCkge1xuICAgIGlmICghc2V0RXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzTWFwKSB7XG4gICAgaWYgKCFtYXBFcXVpdihhLCBiLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpdGVyYXRpb25UeXBlID09PSBrSXNBcnJheSkge1xuICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGEsIGkpKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkoYiwgaSkgfHwgIWlubmVyRGVlcEVxdWFsKGFbaV0sIGJbaV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KGIsIGkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFycmF5IGlzIHNwYXJzZS5cbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIGZvciAoOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c0FbaV07XG4gICAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShiLCBrZXkpIHx8ICFpbm5lckRlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleXNBLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRoZSBwYWlyIG11c3QgaGF2ZSBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXkuXG4gIC8vIFBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3Q6XG4gIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9rZXkyID0ga2V5c1tpXTtcbiAgICBpZiAoIWlubmVyRGVlcEVxdWFsKGFbX2tleTJdLCBiW19rZXkyXSwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpc0RlZXBFcXVhbCh2YWwxLCB2YWwyKSB7XG4gIHJldHVybiBpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBrTG9vc2UpO1xufVxuZnVuY3Rpb24gaXNEZWVwU3RyaWN0RXF1YWwodmFsMSwgdmFsMikge1xuICByZXR1cm4gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwga1N0cmljdCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNEZWVwRXF1YWw6IGlzRGVlcEVxdWFsLFxuICBpc0RlZXBTdHJpY3RFcXVhbDogaXNEZWVwU3RyaWN0RXF1YWxcbn07IiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxuY29uc3QgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuY29uc3QgY3VzdG9tSW5zcGVjdFN5bWJvbCA9XG4gICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2xbJ2ZvciddID09PSAnZnVuY3Rpb24nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgID8gU3ltYm9sWydmb3InXSgnbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIDogbnVsbFxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbmNvbnN0IEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgY29uc3QgcHJvdG8gPSB7IGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyLCBwcm90bylcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5Vmlldyh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICBjb25zdCB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBjb25zdCBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsIFVpbnQ4QXJyYXkpXG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIGxldCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIGNvbnN0IGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5VmlldyAoYXJyYXlWaWV3KSB7XG4gIGlmIChpc0luc3RhbmNlKGFycmF5VmlldywgVWludDhBcnJheSkpIHtcbiAgICBjb25zdCBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlWaWV3KVxuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIoY29weS5idWZmZXIsIGNvcHkuYnl0ZU9mZnNldCwgY29weS5ieXRlTGVuZ3RoKVxuICB9XG4gIHJldHVybiBmcm9tQXJyYXlMaWtlKGFycmF5Vmlldylcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGxldCBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgY29uc3QgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgbGV0IHggPSBhLmxlbmd0aFxuICBsZXQgeSA9IGIubGVuZ3RoXG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICBsZXQgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIGxldCBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBpZiAocG9zICsgYnVmLmxlbmd0aCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICBidWYsXG4gICAgICAgICAgcG9zXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgfVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgY29uc3QgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBjb25zdCBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcmNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICBjb25zdCBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICBsZXQgc3RyID0gJydcbiAgY29uc3QgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cbmlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBCdWZmZXIucHJvdG90eXBlLmluc3BlY3Rcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgbGV0IHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIGxldCB5ID0gZW5kIC0gc3RhcnRcbiAgY29uc3QgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICBjb25zdCB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICBjb25zdCB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgbGV0IGluZGV4U2l6ZSA9IDFcbiAgbGV0IGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgbGV0IHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGRpcikge1xuICAgIGxldCBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGxldCBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgY29uc3QgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICBjb25zdCByZXMgPSBbXVxuXG4gIGxldCBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICBsZXQgY29kZVBvaW50ID0gbnVsbFxuICAgIGxldCBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpXG4gICAgICA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpXG4gICAgICAgICAgPyAzXG4gICAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRilcbiAgICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgbGV0IHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxuY29uc3QgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIGNvbnN0IGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIGxldCBvdXQgPSAnJ1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIGxldCByZXMgPSAnJ1xuICAvLyBJZiBieXRlcy5sZW5ndGggaXMgb2RkLCB0aGUgbGFzdCA4IGJpdHMgbXVzdCBiZSBpZ25vcmVkIChzYW1lIGFzIG5vZGUuanMpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIGNvbnN0IG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgbGV0IG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBsbyA9IGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjRcblxuICBjb25zdCBoaSA9IHRoaXNbKytvZmZzZXRdICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICBsYXN0ICogMiAqKiAyNFxuXG4gIHJldHVybiBCaWdJbnQobG8pICsgKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGhpID0gZmlyc3QgKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIGNvbnN0IGxvID0gdGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0XG5cbiAgcmV0dXJuIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KGxvKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aFxuICBsZXQgbXVsID0gMVxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyA0XSArXG4gICAgdGhpc1tvZmZzZXQgKyA1XSAqIDIgKiogOCArXG4gICAgdGhpc1tvZmZzZXQgKyA2XSAqIDIgKiogMTYgK1xuICAgIChsYXN0IDw8IDI0KSAvLyBPdmVyZmxvd1xuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludChmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IChmaXJzdCA8PCAyNCkgKyAvLyBPdmVyZmxvd1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0TEUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgcmV0dXJuIG9mZnNldFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRCRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgN10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDZdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA1XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNF0gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDNdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAyXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMV0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldF0gPSBoaVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IDBcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgbGV0IGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gQ1VTVE9NIEVSUk9SU1xuLy8gPT09PT09PT09PT09PVxuXG4vLyBTaW1wbGlmaWVkIHZlcnNpb25zIGZyb20gTm9kZSwgY2hhbmdlZCBmb3IgQnVmZmVyLW9ubHkgdXNhZ2VcbmNvbnN0IGVycm9ycyA9IHt9XG5mdW5jdGlvbiBFIChzeW0sIGdldE1lc3NhZ2UsIEJhc2UpIHtcbiAgZXJyb3JzW3N5bV0gPSBjbGFzcyBOb2RlRXJyb3IgZXh0ZW5kcyBCYXNlIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICBzdXBlcigpXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWVzc2FnZScsIHtcbiAgICAgICAgdmFsdWU6IGdldE1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSlcblxuICAgICAgLy8gQWRkIHRoZSBlcnJvciBjb2RlIHRvIHRoZSBuYW1lIHRvIGluY2x1ZGUgaXQgaW4gdGhlIHN0YWNrIHRyYWNlLlxuICAgICAgdGhpcy5uYW1lID0gYCR7dGhpcy5uYW1lfSBbJHtzeW19XWBcbiAgICAgIC8vIEFjY2VzcyB0aGUgc3RhY2sgdG8gZ2VuZXJhdGUgdGhlIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBlcnJvciBjb2RlXG4gICAgICAvLyBmcm9tIHRoZSBuYW1lLlxuICAgICAgdGhpcy5zdGFjayAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgLy8gUmVzZXQgdGhlIG5hbWUgdG8gdGhlIGFjdHVhbCBuYW1lLlxuICAgICAgZGVsZXRlIHRoaXMubmFtZVxuICAgIH1cblxuICAgIGdldCBjb2RlICgpIHtcbiAgICAgIHJldHVybiBzeW1cbiAgICB9XG5cbiAgICBzZXQgY29kZSAodmFsdWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29kZScsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIGAke3RoaXMubmFtZX0gWyR7c3ltfV06ICR7dGhpcy5tZXNzYWdlfWBcbiAgICB9XG4gIH1cbn1cblxuRSgnRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTJyxcbiAgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuIGAke25hbWV9IGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2BcbiAgICB9XG5cbiAgICByZXR1cm4gJ0F0dGVtcHQgdG8gYWNjZXNzIG1lbW9yeSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnXG4gIH0sIFJhbmdlRXJyb3IpXG5FKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsXG4gIGZ1bmN0aW9uIChuYW1lLCBhY3R1YWwpIHtcbiAgICByZXR1cm4gYFRoZSBcIiR7bmFtZX1cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH1gXG4gIH0sIFR5cGVFcnJvcilcbkUoJ0VSUl9PVVRfT0ZfUkFOR0UnLFxuICBmdW5jdGlvbiAoc3RyLCByYW5nZSwgaW5wdXQpIHtcbiAgICBsZXQgbXNnID0gYFRoZSB2YWx1ZSBvZiBcIiR7c3RyfVwiIGlzIG91dCBvZiByYW5nZS5gXG4gICAgbGV0IHJlY2VpdmVkID0gaW5wdXRcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkgJiYgTWF0aC5hYnMoaW5wdXQpID4gMiAqKiAzMikge1xuICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IoU3RyaW5nKGlucHV0KSlcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIHJlY2VpdmVkID0gU3RyaW5nKGlucHV0KVxuICAgICAgaWYgKGlucHV0ID4gQmlnSW50KDIpICoqIEJpZ0ludCgzMikgfHwgaW5wdXQgPCAtKEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpKSkge1xuICAgICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihyZWNlaXZlZClcbiAgICAgIH1cbiAgICAgIHJlY2VpdmVkICs9ICduJ1xuICAgIH1cbiAgICBtc2cgKz0gYCBJdCBtdXN0IGJlICR7cmFuZ2V9LiBSZWNlaXZlZCAke3JlY2VpdmVkfWBcbiAgICByZXR1cm4gbXNnXG4gIH0sIFJhbmdlRXJyb3IpXG5cbmZ1bmN0aW9uIGFkZE51bWVyaWNhbFNlcGFyYXRvciAodmFsKSB7XG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IHZhbC5sZW5ndGhcbiAgY29uc3Qgc3RhcnQgPSB2YWxbMF0gPT09ICctJyA/IDEgOiAwXG4gIGZvciAoOyBpID49IHN0YXJ0ICsgNDsgaSAtPSAzKSB7XG4gICAgcmVzID0gYF8ke3ZhbC5zbGljZShpIC0gMywgaSl9JHtyZXN9YFxuICB9XG4gIHJldHVybiBgJHt2YWwuc2xpY2UoMCwgaSl9JHtyZXN9YFxufVxuXG4vLyBDSEVDSyBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBjaGVja0JvdW5kcyAoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgaWYgKGJ1ZltvZmZzZXRdID09PSB1bmRlZmluZWQgfHwgYnVmW29mZnNldCArIGJ5dGVMZW5ndGhdID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIGJ1Zi5sZW5ndGggLSAoYnl0ZUxlbmd0aCArIDEpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50QkkgKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB7XG4gICAgY29uc3QgbiA9IHR5cGVvZiBtaW4gPT09ICdiaWdpbnQnID8gJ24nIDogJydcbiAgICBsZXQgcmFuZ2VcbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDMpIHtcbiAgICAgIGlmIChtaW4gPT09IDAgfHwgbWluID09PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gMCR7bn0gYW5kIDwgMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOH0ke259YFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gLSgyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259KSBhbmQgPCAyICoqIGAgK1xuICAgICAgICAgICAgICAgIGAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259YFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZSA9IGA+PSAke21pbn0ke259IGFuZCA8PSAke21heH0ke259YFxuICAgIH1cbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UoJ3ZhbHVlJywgcmFuZ2UsIHZhbHVlKVxuICB9XG4gIGNoZWNrQm91bmRzKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlciAodmFsdWUsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdudW1iZXInLCB2YWx1ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBib3VuZHNFcnJvciAodmFsdWUsIGxlbmd0aCwgdHlwZSkge1xuICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7XG4gICAgdmFsaWRhdGVOdW1iZXIodmFsdWUsIHR5cGUpXG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsICdhbiBpbnRlZ2VyJywgdmFsdWUpXG4gIH1cblxuICBpZiAobGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTKClcbiAgfVxuXG4gIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYD49ICR7dHlwZSA/IDEgOiAwfSBhbmQgPD0gJHtsZW5ndGh9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlKVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbmNvbnN0IElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICBsZXQgY29kZVBvaW50XG4gIGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgbGV0IGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIGNvbnN0IGJ5dGVzID0gW11cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICBsZXQgYywgaGksIGxvXG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbmNvbnN0IGhleFNsaWNlTG9va3VwVGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICBjb25zdCBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xuICBjb25zdCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIGNvbnN0IGkxNiA9IGkgKiAxNlxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdXG4gICAgfVxuICB9XG4gIHJldHVybiB0YWJsZVxufSkoKVxuXG4vLyBSZXR1cm4gbm90IGZ1bmN0aW9uIHdpdGggRXJyb3IgaWYgQmlnSW50IG5vdCBzdXBwb3J0ZWRcbmZ1bmN0aW9uIGRlZmluZUJpZ0ludE1ldGhvZCAoZm4pIHtcbiAgcmV0dXJuIHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCA6IGZuXG59XG5cbmZ1bmN0aW9uIEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0JpZ0ludCBub3Qgc3VwcG9ydGVkJylcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG5cbnZhciAkYXBwbHkgPSByZXF1aXJlKCcuL2Z1bmN0aW9uQXBwbHknKTtcbnZhciAkY2FsbCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25DYWxsJyk7XG52YXIgJHJlZmxlY3RBcHBseSA9IHJlcXVpcmUoJy4vcmVmbGVjdEFwcGx5Jyk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2FjdHVhbEFwcGx5Jyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9ICRyZWZsZWN0QXBwbHkgfHwgYmluZC5jYWxsKCRjYWxsLCAkYXBwbHkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcbnZhciAkYXBwbHkgPSByZXF1aXJlKCcuL2Z1bmN0aW9uQXBwbHknKTtcbnZhciBhY3R1YWxBcHBseSA9IHJlcXVpcmUoJy4vYWN0dWFsQXBwbHknKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vYXBwbHlCaW5kJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwcGx5QmluZCgpIHtcblx0cmV0dXJuIGFjdHVhbEFwcGx5KGJpbmQsICRhcHBseSwgYXJndW1lbnRzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2Z1bmN0aW9uQXBwbHknKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9mdW5jdGlvbkNhbGwnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyICRUeXBlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvdHlwZScpO1xuXG52YXIgJGNhbGwgPSByZXF1aXJlKCcuL2Z1bmN0aW9uQ2FsbCcpO1xudmFyICRhY3R1YWxBcHBseSA9IHJlcXVpcmUoJy4vYWN0dWFsQXBwbHknKTtcblxuLyoqIEB0eXBlIHsoYXJnczogW0Z1bmN0aW9uLCB0aGlzQXJnPzogdW5rbm93biwgLi4uYXJnczogdW5rbm93bltdXSkgPT4gRnVuY3Rpb259IFRPRE8gRklYTUUsIGZpbmQgYSB3YXkgdG8gdXNlIGltcG9ydCgnLicpICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCaW5kQmFzaWMoYXJncykge1xuXHRpZiAoYXJncy5sZW5ndGggPCAxIHx8IHR5cGVvZiBhcmdzWzBdICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2EgZnVuY3Rpb24gaXMgcmVxdWlyZWQnKTtcblx0fVxuXHRyZXR1cm4gJGFjdHVhbEFwcGx5KGJpbmQsICRjYWxsLCBhcmdzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3JlZmxlY3RBcHBseScpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgUmVmbGVjdCAmJiBSZWZsZWN0LmFwcGx5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCcuLycpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzZXRGdW5jdGlvbkxlbmd0aCA9IHJlcXVpcmUoJ3NldC1mdW5jdGlvbi1sZW5ndGgnKTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJ2VzLWRlZmluZS1wcm9wZXJ0eScpO1xuXG52YXIgY2FsbEJpbmRCYXNpYyA9IHJlcXVpcmUoJ2NhbGwtYmluZC1hcHBseS1oZWxwZXJzJyk7XG52YXIgYXBwbHlCaW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kLWFwcGx5LWhlbHBlcnMvYXBwbHlCaW5kJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJpbmQob3JpZ2luYWxGdW5jdGlvbikge1xuXHR2YXIgZnVuYyA9IGNhbGxCaW5kQmFzaWMoYXJndW1lbnRzKTtcblx0dmFyIGFkanVzdGVkTGVuZ3RoID0gb3JpZ2luYWxGdW5jdGlvbi5sZW5ndGggLSAoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuXHRyZXR1cm4gc2V0RnVuY3Rpb25MZW5ndGgoXG5cdFx0ZnVuYyxcblx0XHQxICsgKGFkanVzdGVkTGVuZ3RoID4gMCA/IGFkanVzdGVkTGVuZ3RoIDogMCksXG5cdFx0dHJ1ZVxuXHQpO1xufTtcblxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHQkZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICdhcHBseScsIHsgdmFsdWU6IGFwcGx5QmluZCB9KTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzLmFwcGx5ID0gYXBwbHlCaW5kO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgY2FsbEJpbmRCYXNpYyA9IHJlcXVpcmUoJ2NhbGwtYmluZC1hcHBseS1oZWxwZXJzJyk7XG5cbi8qKiBAdHlwZSB7KHRoaXNBcmc6IHN0cmluZywgc2VhcmNoU3RyaW5nOiBzdHJpbmcsIHBvc2l0aW9uPzogbnVtYmVyKSA9PiBudW1iZXJ9ICovXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZEJhc2ljKFtHZXRJbnRyaW5zaWMoJyVTdHJpbmcucHJvdG90eXBlLmluZGV4T2YlJyldKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJvdW5kSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHQvKiBlc2xpbnQgbm8tZXh0cmEtcGFyZW5zOiAwICovXG5cblx0dmFyIGludHJpbnNpYyA9IC8qKiBAdHlwZSB7KHRoaXM6IHVua25vd24sIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdW5rbm93bn0gKi8gKEdldEludHJpbnNpYyhuYW1lLCAhIWFsbG93TWlzc2luZykpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kQmFzaWMoLyoqIEB0eXBlIHtjb25zdH0gKi8gKFtpbnRyaW5zaWNdKSk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG4iLCIvKmdsb2JhbCB3aW5kb3csIGdsb2JhbCovXG52YXIgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpXG52YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKVxuZnVuY3Rpb24gbm93KCkgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgfVxuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2VcbnZhciBjb25zb2xlXG52YXIgdGltZXMgPSB7fVxuXG5pZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY29uc29sZSkge1xuICAgIGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZVxufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5jb25zb2xlKSB7XG4gICAgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlXG59IGVsc2Uge1xuICAgIGNvbnNvbGUgPSB7fVxufVxuXG52YXIgZnVuY3Rpb25zID0gW1xuICAgIFtsb2csIFwibG9nXCJdLFxuICAgIFtpbmZvLCBcImluZm9cIl0sXG4gICAgW3dhcm4sIFwid2FyblwiXSxcbiAgICBbZXJyb3IsIFwiZXJyb3JcIl0sXG4gICAgW3RpbWUsIFwidGltZVwiXSxcbiAgICBbdGltZUVuZCwgXCJ0aW1lRW5kXCJdLFxuICAgIFt0cmFjZSwgXCJ0cmFjZVwiXSxcbiAgICBbZGlyLCBcImRpclwiXSxcbiAgICBbY29uc29sZUFzc2VydCwgXCJhc3NlcnRcIl1cbl1cblxuZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHVwbGUgPSBmdW5jdGlvbnNbaV1cbiAgICB2YXIgZiA9IHR1cGxlWzBdXG4gICAgdmFyIG5hbWUgPSB0dXBsZVsxXVxuXG4gICAgaWYgKCFjb25zb2xlW25hbWVdKSB7XG4gICAgICAgIGNvbnNvbGVbbmFtZV0gPSBmXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnNvbGVcblxuZnVuY3Rpb24gbG9nKCkge31cblxuZnVuY3Rpb24gaW5mbygpIHtcbiAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG59XG5cbmZ1bmN0aW9uIHdhcm4oKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiBlcnJvcigpIHtcbiAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiB0aW1lKGxhYmVsKSB7XG4gICAgdGltZXNbbGFiZWxdID0gbm93KClcbn1cblxuZnVuY3Rpb24gdGltZUVuZChsYWJlbCkge1xuICAgIHZhciB0aW1lID0gdGltZXNbbGFiZWxdXG4gICAgaWYgKCF0aW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN1Y2ggbGFiZWw6IFwiICsgbGFiZWwpXG4gICAgfVxuXG4gICAgZGVsZXRlIHRpbWVzW2xhYmVsXVxuICAgIHZhciBkdXJhdGlvbiA9IG5vdygpIC0gdGltZVxuICAgIGNvbnNvbGUubG9nKGxhYmVsICsgXCI6IFwiICsgZHVyYXRpb24gKyBcIm1zXCIpXG59XG5cbmZ1bmN0aW9uIHRyYWNlKCkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKVxuICAgIGVyci5uYW1lID0gXCJUcmFjZVwiXG4gICAgZXJyLm1lc3NhZ2UgPSB1dGlsLmZvcm1hdC5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2spXG59XG5cbmZ1bmN0aW9uIGRpcihvYmplY3QpIHtcbiAgICBjb25zb2xlLmxvZyh1dGlsLmluc3BlY3Qob2JqZWN0KSArIFwiXFxuXCIpXG59XG5cbmZ1bmN0aW9uIGNvbnNvbGVBc3NlcnQoZXhwcmVzc2lvbikge1xuICAgIGlmICghZXhwcmVzc2lvbikge1xuICAgICAgICB2YXIgYXJyID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgICAgIGFzc2VydC5vayhmYWxzZSwgdXRpbC5mb3JtYXQuYXBwbHkobnVsbCwgYXJyKSlcbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCdlcy1kZWZpbmUtcHJvcGVydHknKTtcblxudmFyICRTeW50YXhFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy9zeW50YXgnKTtcbnZhciAkVHlwZUVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3R5cGUnKTtcblxudmFyIGdvcGQgPSByZXF1aXJlKCdnb3BkJyk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZURhdGFQcm9wZXJ0eShcblx0b2JqLFxuXHRwcm9wZXJ0eSxcblx0dmFsdWVcbikge1xuXHRpZiAoIW9iaiB8fCAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJykpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYG9iamAgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbmAnKTtcblx0fVxuXHRpZiAodHlwZW9mIHByb3BlcnR5ICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcHJvcGVydHkgIT09ICdzeW1ib2wnKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Bwcm9wZXJ0eWAgbXVzdCBiZSBhIHN0cmluZyBvciBhIHN5bWJvbGAnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGFyZ3VtZW50c1szXSAhPT0gJ2Jvb2xlYW4nICYmIGFyZ3VtZW50c1szXSAhPT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbm9uRW51bWVyYWJsZWAsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbiBvciBudWxsJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIHR5cGVvZiBhcmd1bWVudHNbNF0gIT09ICdib29sZWFuJyAmJiBhcmd1bWVudHNbNF0gIT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYG5vbldyaXRhYmxlYCwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBib29sZWFuIG9yIG51bGwnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgdHlwZW9mIGFyZ3VtZW50c1s1XSAhPT0gJ2Jvb2xlYW4nICYmIGFyZ3VtZW50c1s1XSAhPT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbm9uQ29uZmlndXJhYmxlYCwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBib29sZWFuIG9yIG51bGwnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgdHlwZW9mIGFyZ3VtZW50c1s2XSAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Bsb29zZWAsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXHR9XG5cblx0dmFyIG5vbkVudW1lcmFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cdHZhciBub25Xcml0YWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogbnVsbDtcblx0dmFyIG5vbkNvbmZpZ3VyYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ID8gYXJndW1lbnRzWzVdIDogbnVsbDtcblx0dmFyIGxvb3NlID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgPyBhcmd1bWVudHNbNl0gOiBmYWxzZTtcblxuXHQvKiBAdHlwZSB7ZmFsc2UgfCBUeXBlZFByb3BlcnR5RGVzY3JpcHRvcjx1bmtub3duPn0gKi9cblx0dmFyIGRlc2MgPSAhIWdvcGQgJiYgZ29wZChvYmosIHByb3BlcnR5KTtcblxuXHRpZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcGVydHksIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogbm9uQ29uZmlndXJhYmxlID09PSBudWxsICYmIGRlc2MgPyBkZXNjLmNvbmZpZ3VyYWJsZSA6ICFub25Db25maWd1cmFibGUsXG5cdFx0XHRlbnVtZXJhYmxlOiBub25FbnVtZXJhYmxlID09PSBudWxsICYmIGRlc2MgPyBkZXNjLmVudW1lcmFibGUgOiAhbm9uRW51bWVyYWJsZSxcblx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdHdyaXRhYmxlOiBub25Xcml0YWJsZSA9PT0gbnVsbCAmJiBkZXNjID8gZGVzYy53cml0YWJsZSA6ICFub25Xcml0YWJsZVxuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGxvb3NlIHx8ICghbm9uRW51bWVyYWJsZSAmJiAhbm9uV3JpdGFibGUgJiYgIW5vbkNvbmZpZ3VyYWJsZSkpIHtcblx0XHQvLyBtdXN0IGZhbGwgYmFjayB0byBbW1NldF1dLCBhbmQgd2FzIG5vdCBleHBsaWNpdGx5IGFza2VkIHRvIG1ha2Ugbm9uLWVudW1lcmFibGUsIG5vbi13cml0YWJsZSwgb3Igbm9uLWNvbmZpZ3VyYWJsZVxuXHRcdG9ialtwcm9wZXJ0eV0gPSB2YWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBkZWZpbmluZyBhIHByb3BlcnR5IGFzIG5vbi1jb25maWd1cmFibGUsIG5vbi13cml0YWJsZSwgb3Igbm9uLWVudW1lcmFibGUuJyk7XG5cdH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBrZXlzID0gcmVxdWlyZSgnb2JqZWN0LWtleXMnKTtcbnZhciBoYXNTeW1ib2xzID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sKCdmb28nKSA9PT0gJ3N5bWJvbCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcbnZhciBkZWZpbmVEYXRhUHJvcGVydHkgPSByZXF1aXJlKCdkZWZpbmUtZGF0YS1wcm9wZXJ0eScpO1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuXHRyZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHRvU3RyLmNhbGwoZm4pID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIHN1cHBvcnRzRGVzY3JpcHRvcnMgPSByZXF1aXJlKCdoYXMtcHJvcGVydHktZGVzY3JpcHRvcnMnKSgpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCB2YWx1ZSwgcHJlZGljYXRlKSB7XG5cdGlmIChuYW1lIGluIG9iamVjdCkge1xuXHRcdGlmIChwcmVkaWNhdGUgPT09IHRydWUpIHtcblx0XHRcdGlmIChvYmplY3RbbmFtZV0gPT09IHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKCFpc0Z1bmN0aW9uKHByZWRpY2F0ZSkgfHwgIXByZWRpY2F0ZSgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cblx0aWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcblx0XHRkZWZpbmVEYXRhUHJvcGVydHkob2JqZWN0LCBuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG5cdH0gZWxzZSB7XG5cdFx0ZGVmaW5lRGF0YVByb3BlcnR5KG9iamVjdCwgbmFtZSwgdmFsdWUpO1xuXHR9XG59O1xuXG52YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmplY3QsIG1hcCkge1xuXHR2YXIgcHJlZGljYXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDoge307XG5cdHZhciBwcm9wcyA9IGtleXMobWFwKTtcblx0aWYgKGhhc1N5bWJvbHMpIHtcblx0XHRwcm9wcyA9IGNvbmNhdC5jYWxsKHByb3BzLCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG1hcCkpO1xuXHR9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRkZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BzW2ldLCBtYXBbcHJvcHNbaV1dLCBwcmVkaWNhdGVzW3Byb3BzW2ldXSk7XG5cdH1cbn07XG5cbmRlZmluZVByb3BlcnRpZXMuc3VwcG9ydHNEZXNjcmlwdG9ycyA9ICEhc3VwcG9ydHNEZXNjcmlwdG9ycztcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0aWVzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCdjYWxsLWJpbmQtYXBwbHktaGVscGVycycpO1xudmFyIGdPUEQgPSByZXF1aXJlKCdnb3BkJyk7XG5cbnZhciBoYXNQcm90b0FjY2Vzc29yO1xudHJ5IHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVucywgbm8tcHJvdG9cblx0aGFzUHJvdG9BY2Nlc3NvciA9IC8qKiBAdHlwZSB7eyBfX3Byb3RvX18/OiB0eXBlb2YgQXJyYXkucHJvdG90eXBlIH19ICovIChbXSkuX19wcm90b19fID09PSBBcnJheS5wcm90b3R5cGU7XG59IGNhdGNoIChlKSB7XG5cdGlmICghZSB8fCB0eXBlb2YgZSAhPT0gJ29iamVjdCcgfHwgISgnY29kZScgaW4gZSkgfHwgZS5jb2RlICE9PSAnRVJSX1BST1RPX0FDQ0VTUycpIHtcblx0XHR0aHJvdyBlO1xuXHR9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcbnZhciBkZXNjID0gISFoYXNQcm90b0FjY2Vzc29yICYmIGdPUEQgJiYgZ09QRChPYmplY3QucHJvdG90eXBlLCAvKiogQHR5cGUge2tleW9mIHR5cGVvZiBPYmplY3QucHJvdG90eXBlfSAqLyAoJ19fcHJvdG9fXycpKTtcblxudmFyICRPYmplY3QgPSBPYmplY3Q7XG52YXIgJGdldFByb3RvdHlwZU9mID0gJE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vZ2V0Jyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGRlc2MgJiYgdHlwZW9mIGRlc2MuZ2V0ID09PSAnZnVuY3Rpb24nXG5cdD8gY2FsbEJpbmQoW2Rlc2MuZ2V0XSlcblx0OiB0eXBlb2YgJGdldFByb3RvdHlwZU9mID09PSAnZnVuY3Rpb24nXG5cdFx0PyAvKiogQHR5cGUge2ltcG9ydCgnLi9nZXQnKX0gKi8gZnVuY3Rpb24gZ2V0RHVuZGVyKHZhbHVlKSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRyZXR1cm4gJGdldFByb3RvdHlwZU9mKHZhbHVlID09IG51bGwgPyB2YWx1ZSA6ICRPYmplY3QodmFsdWUpKTtcblx0XHR9XG5cdFx0OiBmYWxzZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZmFsc2U7XG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gJGRlZmluZVByb3BlcnR5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9ldmFsJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IEV2YWxFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3JhbmdlJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3JlZicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBSZWZlcmVuY2VFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vc3ludGF4Jyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRheEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGVFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vdXJpJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFVSSUVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnaXMtY2FsbGFibGUnKTtcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKiBAdHlwZSB7PFRoaXMsIEEgZXh0ZW5kcyByZWFkb25seSB1bmtub3duW10+KGFycjogQSwgaXRlcmF0b3I6ICh0aGlzOiBUaGlzIHwgdm9pZCwgdmFsdWU6IEFbbnVtYmVyXSwgaW5kZXg6IG51bWJlciwgYXJyOiBBKSA9PiB2b2lkLCByZWNlaXZlcjogVGhpcyB8IHVuZGVmaW5lZCkgPT4gdm9pZH0gKi9cbnZhciBmb3JFYWNoQXJyYXkgPSBmdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaSkpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IoYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKiBAdHlwZSB7PFRoaXMsIFMgZXh0ZW5kcyBzdHJpbmc+KHN0cmluZzogUywgaXRlcmF0b3I6ICh0aGlzOiBUaGlzIHwgdm9pZCwgdmFsdWU6IFNbbnVtYmVyXSwgaW5kZXg6IG51bWJlciwgc3RyaW5nOiBTKSA9PiB2b2lkLCByZWNlaXZlcjogVGhpcyB8IHVuZGVmaW5lZCkgPT4gdm9pZH0gKi9cbnZhciBmb3JFYWNoU3RyaW5nID0gZnVuY3Rpb24gZm9yRWFjaFN0cmluZyhzdHJpbmcsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKiBAdHlwZSB7PFRoaXMsIE8+KG9iajogTywgaXRlcmF0b3I6ICh0aGlzOiBUaGlzIHwgdm9pZCwgdmFsdWU6IE9ba2V5b2YgT10sIGluZGV4OiBrZXlvZiBPLCBvYmo6IE8pID0+IHZvaWQsIHJlY2VpdmVyOiBUaGlzIHwgdW5kZWZpbmVkKSA9PiB2b2lkfSAqL1xudmFyIGZvckVhY2hPYmplY3QgPSBmdW5jdGlvbiBmb3JFYWNoT2JqZWN0KG9iamVjdCwgaXRlcmF0b3IsIHJlY2VpdmVyKSB7XG4gICAgZm9yICh2YXIgayBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrKSkge1xuICAgICAgICAgICAgaWYgKHJlY2VpdmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvcihvYmplY3Rba10sIGssIG9iamVjdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwocmVjZWl2ZXIsIG9iamVjdFtrXSwgaywgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKiBAdHlwZSB7KHg6IHVua25vd24pID0+IHggaXMgcmVhZG9ubHkgdW5rbm93bltdfSAqL1xuZnVuY3Rpb24gaXNBcnJheSh4KSB7XG4gICAgcmV0dXJuIHRvU3RyLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJykuX2ludGVybmFsfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JFYWNoKGxpc3QsIGl0ZXJhdG9yLCB0aGlzQXJnKSB7XG4gICAgaWYgKCFpc0NhbGxhYmxlKGl0ZXJhdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICB2YXIgcmVjZWl2ZXI7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykge1xuICAgICAgICByZWNlaXZlciA9IHRoaXNBcmc7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkobGlzdCkpIHtcbiAgICAgICAgZm9yRWFjaEFycmF5KGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9yRWFjaFN0cmluZyhsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvckVhY2hPYmplY3QobGlzdCwgaXRlcmF0b3IsIHJlY2VpdmVyKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAxICovXG5cbnZhciBFUlJPUl9NRVNTQUdFID0gJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJztcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG52YXIgY29uY2F0dHkgPSBmdW5jdGlvbiBjb25jYXR0eShhLCBiKSB7XG4gICAgdmFyIGFyciA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV07XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYi5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBhcnJbaiArIGEubGVuZ3RoXSA9IGJbal07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjtcbn07XG5cbnZhciBzbGljeSA9IGZ1bmN0aW9uIHNsaWN5KGFyckxpa2UsIG9mZnNldCkge1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gb2Zmc2V0IHx8IDAsIGogPSAwOyBpIDwgYXJyTGlrZS5sZW5ndGg7IGkgKz0gMSwgaiArPSAxKSB7XG4gICAgICAgIGFycltqXSA9IGFyckxpa2VbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59O1xuXG52YXIgam9pbnkgPSBmdW5jdGlvbiAoYXJyLCBqb2luZXIpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgc3RyICs9IGFycltpXTtcbiAgICAgICAgaWYgKGkgKyAxIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RyICs9IGpvaW5lcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0b1N0ci5hcHBseSh0YXJnZXQpICE9PSBmdW5jVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUk9SX01FU1NBR0UgKyB0YXJnZXQpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IHNsaWN5KGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgYm91bmQ7XG4gICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGNvbmNhdHR5KGFyZ3MsIGFyZ3VtZW50cylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgIGNvbmNhdHR5KGFyZ3MsIGFyZ3VtZW50cylcbiAgICAgICAgKTtcblxuICAgIH07XG5cbiAgICB2YXIgYm91bmRMZW5ndGggPSBtYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcbiAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJvdW5kQXJnc1tpXSA9ICckJyArIGk7XG4gICAgfVxuXG4gICAgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGpvaW55KGJvdW5kQXJncywgJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnMsIG5vLWVtcHR5LWZ1bmN0aW9uXG5jb25zdCBjYWNoZWQgPSAvKiogQHR5cGUge0dlbmVyYXRvckZ1bmN0aW9uQ29uc3RydWN0b3J9ICovIChmdW5jdGlvbiogKCkge30uY29uc3RydWN0b3IpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSAoKSA9PiBjYWNoZWQ7XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHVuZGVmaW5lZDtcblxudmFyICRPYmplY3QgPSByZXF1aXJlKCdlcy1vYmplY3QtYXRvbXMnKTtcblxudmFyICRFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycycpO1xudmFyICRFdmFsRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvZXZhbCcpO1xudmFyICRSYW5nZUVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3JhbmdlJyk7XG52YXIgJFJlZmVyZW5jZUVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3JlZicpO1xudmFyICRTeW50YXhFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy9zeW50YXgnKTtcbnZhciAkVHlwZUVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3R5cGUnKTtcbnZhciAkVVJJRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvdXJpJyk7XG5cbnZhciBhYnMgPSByZXF1aXJlKCdtYXRoLWludHJpbnNpY3MvYWJzJyk7XG52YXIgZmxvb3IgPSByZXF1aXJlKCdtYXRoLWludHJpbnNpY3MvZmxvb3InKTtcbnZhciBtYXggPSByZXF1aXJlKCdtYXRoLWludHJpbnNpY3MvbWF4Jyk7XG52YXIgbWluID0gcmVxdWlyZSgnbWF0aC1pbnRyaW5zaWNzL21pbicpO1xudmFyIHBvdyA9IHJlcXVpcmUoJ21hdGgtaW50cmluc2ljcy9wb3cnKTtcbnZhciByb3VuZCA9IHJlcXVpcmUoJ21hdGgtaW50cmluc2ljcy9yb3VuZCcpO1xudmFyIHNpZ24gPSByZXF1aXJlKCdtYXRoLWludHJpbnNpY3Mvc2lnbicpO1xuXG52YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxudmFyIGdldEV2YWxsZWRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChleHByZXNzaW9uU3ludGF4KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuICRGdW5jdGlvbignXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJyArIGV4cHJlc3Npb25TeW50YXggKyAnKS5jb25zdHJ1Y3RvcjsnKSgpO1xuXHR9IGNhdGNoIChlKSB7fVxufTtcblxudmFyICRnT1BEID0gcmVxdWlyZSgnZ29wZCcpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJ2VzLWRlZmluZS1wcm9wZXJ0eScpO1xuXG52YXIgdGhyb3dUeXBlRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdHRocm93IG5ldyAkVHlwZUVycm9yKCk7XG59O1xudmFyIFRocm93VHlwZUVycm9yID0gJGdPUERcblx0PyAoZnVuY3Rpb24gKCkge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zLCBuby1jYWxsZXIsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuXHRcdFx0YXJndW1lbnRzLmNhbGxlZTsgLy8gSUUgOCBkb2VzIG5vdCB0aHJvdyBoZXJlXG5cdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0fSBjYXRjaCAoY2FsbGVlVGhyb3dzKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBJRSA4IHRocm93cyBvbiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFyZ3VtZW50cywgJycpXG5cdFx0XHRcdHJldHVybiAkZ09QRChhcmd1bWVudHMsICdjYWxsZWUnKS5nZXQ7XG5cdFx0XHR9IGNhdGNoIChnT1BEdGhyb3dzKSB7XG5cdFx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH0oKSlcblx0OiB0aHJvd1R5cGVFcnJvcjtcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scycpKCk7XG5cbnZhciBnZXRQcm90byA9IHJlcXVpcmUoJ2dldC1wcm90bycpO1xudmFyICRPYmplY3RHUE8gPSByZXF1aXJlKCdnZXQtcHJvdG8vT2JqZWN0LmdldFByb3RvdHlwZU9mJyk7XG52YXIgJFJlZmxlY3RHUE8gPSByZXF1aXJlKCdnZXQtcHJvdG8vUmVmbGVjdC5nZXRQcm90b3R5cGVPZicpO1xuXG52YXIgJGFwcGx5ID0gcmVxdWlyZSgnY2FsbC1iaW5kLWFwcGx5LWhlbHBlcnMvZnVuY3Rpb25BcHBseScpO1xudmFyICRjYWxsID0gcmVxdWlyZSgnY2FsbC1iaW5kLWFwcGx5LWhlbHBlcnMvZnVuY3Rpb25DYWxsJyk7XG5cbnZhciBuZWVkc0V2YWwgPSB7fTtcblxudmFyIFR5cGVkQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgfHwgIWdldFByb3RvID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8oVWludDhBcnJheSk7XG5cbnZhciBJTlRSSU5TSUNTID0ge1xuXHRfX3Byb3RvX186IG51bGwsXG5cdCclQWdncmVnYXRlRXJyb3IlJzogdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFnZ3JlZ2F0ZUVycm9yLFxuXHQnJUFycmF5JSc6IEFycmF5LFxuXHQnJUFycmF5QnVmZmVyJSc6IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBcnJheUJ1ZmZlcixcblx0JyVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogbmVlZHNFdmFsLFxuXHQnJUF0b21pY3MlJzogdHlwZW9mIEF0b21pY3MgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXRvbWljcyxcblx0JyVCaWdJbnQlJzogdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQsXG5cdCclQmlnSW50NjRBcnJheSUnOiB0eXBlb2YgQmlnSW50NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQ2NEFycmF5LFxuXHQnJUJpZ1VpbnQ2NEFycmF5JSc6IHR5cGVvZiBCaWdVaW50NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdVaW50NjRBcnJheSxcblx0JyVCb29sZWFuJSc6IEJvb2xlYW4sXG5cdCclRGF0YVZpZXclJzogdHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IERhdGFWaWV3LFxuXHQnJURhdGUlJzogRGF0ZSxcblx0JyVkZWNvZGVVUkklJzogZGVjb2RlVVJJLFxuXHQnJWRlY29kZVVSSUNvbXBvbmVudCUnOiBkZWNvZGVVUklDb21wb25lbnQsXG5cdCclZW5jb2RlVVJJJSc6IGVuY29kZVVSSSxcblx0JyVlbmNvZGVVUklDb21wb25lbnQlJzogZW5jb2RlVVJJQ29tcG9uZW50LFxuXHQnJUVycm9yJSc6ICRFcnJvcixcblx0JyVldmFsJSc6IGV2YWwsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxuXHQnJUV2YWxFcnJvciUnOiAkRXZhbEVycm9yLFxuXHQnJUZsb2F0MTZBcnJheSUnOiB0eXBlb2YgRmxvYXQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0MTZBcnJheSxcblx0JyVGbG9hdDMyQXJyYXklJzogdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDMyQXJyYXksXG5cdCclRmxvYXQ2NEFycmF5JSc6IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQ2NEFycmF5LFxuXHQnJUZpbmFsaXphdGlvblJlZ2lzdHJ5JSc6IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGaW5hbGl6YXRpb25SZWdpc3RyeSxcblx0JyVGdW5jdGlvbiUnOiAkRnVuY3Rpb24sXG5cdCclR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUludDhBcnJheSUnOiB0eXBlb2YgSW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDhBcnJheSxcblx0JyVJbnQxNkFycmF5JSc6IHR5cGVvZiBJbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDE2QXJyYXksXG5cdCclSW50MzJBcnJheSUnOiB0eXBlb2YgSW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQzMkFycmF5LFxuXHQnJWlzRmluaXRlJSc6IGlzRmluaXRlLFxuXHQnJWlzTmFOJSc6IGlzTmFOLFxuXHQnJUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90byhnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKSA6IHVuZGVmaW5lZCxcblx0JyVKU09OJSc6IHR5cGVvZiBKU09OID09PSAnb2JqZWN0JyA/IEpTT04gOiB1bmRlZmluZWQsXG5cdCclTWFwJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTWFwLFxuXHQnJU1hcEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBNYXAoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJU1hdGglJzogTWF0aCxcblx0JyVOdW1iZXIlJzogTnVtYmVyLFxuXHQnJU9iamVjdCUnOiAkT2JqZWN0LFxuXHQnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJzogJGdPUEQsXG5cdCclcGFyc2VGbG9hdCUnOiBwYXJzZUZsb2F0LFxuXHQnJXBhcnNlSW50JSc6IHBhcnNlSW50LFxuXHQnJVByb21pc2UlJzogdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJvbWlzZSxcblx0JyVQcm94eSUnOiB0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJveHksXG5cdCclUmFuZ2VFcnJvciUnOiAkUmFuZ2VFcnJvcixcblx0JyVSZWZlcmVuY2VFcnJvciUnOiAkUmVmZXJlbmNlRXJyb3IsXG5cdCclUmVmbGVjdCUnOiB0eXBlb2YgUmVmbGVjdCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBSZWZsZWN0LFxuXHQnJVJlZ0V4cCUnOiBSZWdFeHAsXG5cdCclU2V0JSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2V0LFxuXHQnJVNldEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBTZXQoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyJSc6IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTaGFyZWRBcnJheUJ1ZmZlcixcblx0JyVTdHJpbmclJzogU3RyaW5nLFxuXHQnJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90bygnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJVN5bWJvbCUnOiBoYXNTeW1ib2xzID8gU3ltYm9sIDogdW5kZWZpbmVkLFxuXHQnJVN5bnRheEVycm9yJSc6ICRTeW50YXhFcnJvcixcblx0JyVUaHJvd1R5cGVFcnJvciUnOiBUaHJvd1R5cGVFcnJvcixcblx0JyVUeXBlZEFycmF5JSc6IFR5cGVkQXJyYXksXG5cdCclVHlwZUVycm9yJSc6ICRUeXBlRXJyb3IsXG5cdCclVWludDhBcnJheSUnOiB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OEFycmF5LFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5JSc6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OENsYW1wZWRBcnJheSxcblx0JyVVaW50MTZBcnJheSUnOiB0eXBlb2YgVWludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDE2QXJyYXksXG5cdCclVWludDMyQXJyYXklJzogdHlwZW9mIFVpbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQzMkFycmF5LFxuXHQnJVVSSUVycm9yJSc6ICRVUklFcnJvcixcblx0JyVXZWFrTWFwJSc6IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtNYXAsXG5cdCclV2Vha1JlZiUnOiB0eXBlb2YgV2Vha1JlZiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrUmVmLFxuXHQnJVdlYWtTZXQlJzogdHlwZW9mIFdlYWtTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1NldCxcblxuXHQnJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJSc6ICRjYWxsLFxuXHQnJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSUnOiAkYXBwbHksXG5cdCclT2JqZWN0LmRlZmluZVByb3BlcnR5JSc6ICRkZWZpbmVQcm9wZXJ0eSxcblx0JyVPYmplY3QuZ2V0UHJvdG90eXBlT2YlJzogJE9iamVjdEdQTyxcblx0JyVNYXRoLmFicyUnOiBhYnMsXG5cdCclTWF0aC5mbG9vciUnOiBmbG9vcixcblx0JyVNYXRoLm1heCUnOiBtYXgsXG5cdCclTWF0aC5taW4lJzogbWluLFxuXHQnJU1hdGgucG93JSc6IHBvdyxcblx0JyVNYXRoLnJvdW5kJSc6IHJvdW5kLFxuXHQnJU1hdGguc2lnbiUnOiBzaWduLFxuXHQnJVJlZmxlY3QuZ2V0UHJvdG90eXBlT2YlJzogJFJlZmxlY3RHUE9cbn07XG5cbmlmIChnZXRQcm90bykge1xuXHR0cnkge1xuXHRcdG51bGwuZXJyb3I7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zaGFkb3dyZWFsbS9wdWxsLzM4NCNpc3N1ZWNvbW1lbnQtMTM2NDI2NDIyOVxuXHRcdHZhciBlcnJvclByb3RvID0gZ2V0UHJvdG8oZ2V0UHJvdG8oZSkpO1xuXHRcdElOVFJJTlNJQ1NbJyVFcnJvci5wcm90b3R5cGUlJ10gPSBlcnJvclByb3RvO1xuXHR9XG59XG5cbnZhciBkb0V2YWwgPSBmdW5jdGlvbiBkb0V2YWwobmFtZSkge1xuXHR2YXIgdmFsdWU7XG5cdGlmIChuYW1lID09PSAnJUFzeW5jRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yJScpIHtcblx0XHR2YXIgZm4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpO1xuXHRcdGlmIChmbikge1xuXHRcdFx0dmFsdWUgPSBmbi5wcm90b3R5cGU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnKSB7XG5cdFx0dmFyIGdlbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yJScpO1xuXHRcdGlmIChnZW4gJiYgZ2V0UHJvdG8pIHtcblx0XHRcdHZhbHVlID0gZ2V0UHJvdG8oZ2VuLnByb3RvdHlwZSk7XG5cdFx0fVxuXHR9XG5cblx0SU5UUklOU0lDU1tuYW1lXSA9IHZhbHVlO1xuXG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBMRUdBQ1lfQUxJQVNFUyA9IHtcblx0X19wcm90b19fOiBudWxsLFxuXHQnJUFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b3R5cGUlJzogWydBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvX2VudHJpZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZW50cmllcyddLFxuXHQnJUFycmF5UHJvdG9fZm9yRWFjaCUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdmb3JFYWNoJ10sXG5cdCclQXJyYXlQcm90b19rZXlzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2tleXMnXSxcblx0JyVBcnJheVByb3RvX3ZhbHVlcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICd2YWx1ZXMnXSxcblx0JyVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJSc6IFsnQXN5bmNGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVCb29sZWFuUHJvdG90eXBlJSc6IFsnQm9vbGVhbicsICdwcm90b3R5cGUnXSxcblx0JyVEYXRhVmlld1Byb3RvdHlwZSUnOiBbJ0RhdGFWaWV3JywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGVQcm90b3R5cGUlJzogWydEYXRlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUVycm9yUHJvdG90eXBlJSc6IFsnRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRXZhbEVycm9yUHJvdG90eXBlJSc6IFsnRXZhbEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0MzJBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDY0QXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDY0QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRnVuY3Rpb25Qcm90b3R5cGUlJzogWydGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3IlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3JQcm90b3R5cGUlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclSW50OEFycmF5UHJvdG90eXBlJSc6IFsnSW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDE2QXJyYXlQcm90b3R5cGUlJzogWydJbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDMyQXJyYXlQcm90b3R5cGUlJzogWydJbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUpTT05QYXJzZSUnOiBbJ0pTT04nLCAncGFyc2UnXSxcblx0JyVKU09OU3RyaW5naWZ5JSc6IFsnSlNPTicsICdzdHJpbmdpZnknXSxcblx0JyVNYXBQcm90b3R5cGUlJzogWydNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclTnVtYmVyUHJvdG90eXBlJSc6IFsnTnVtYmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJU9iamVjdFByb3RvdHlwZSUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnXSxcblx0JyVPYmpQcm90b190b1N0cmluZyUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndG9TdHJpbmcnXSxcblx0JyVPYmpQcm90b192YWx1ZU9mJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd2YWx1ZU9mJ10sXG5cdCclUHJvbWlzZVByb3RvdHlwZSUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJ10sXG5cdCclUHJvbWlzZVByb3RvX3RoZW4lJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZScsICd0aGVuJ10sXG5cdCclUHJvbWlzZV9hbGwlJzogWydQcm9taXNlJywgJ2FsbCddLFxuXHQnJVByb21pc2VfcmVqZWN0JSc6IFsnUHJvbWlzZScsICdyZWplY3QnXSxcblx0JyVQcm9taXNlX3Jlc29sdmUlJzogWydQcm9taXNlJywgJ3Jlc29sdmUnXSxcblx0JyVSYW5nZUVycm9yUHJvdG90eXBlJSc6IFsnUmFuZ2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSUnOiBbJ1JlZmVyZW5jZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZ0V4cFByb3RvdHlwZSUnOiBbJ1JlZ0V4cCcsICdwcm90b3R5cGUnXSxcblx0JyVTZXRQcm90b3R5cGUlJzogWydTZXQnLCAncHJvdG90eXBlJ10sXG5cdCclU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydTaGFyZWRBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVTdHJpbmdQcm90b3R5cGUlJzogWydTdHJpbmcnLCAncHJvdG90eXBlJ10sXG5cdCclU3ltYm9sUHJvdG90eXBlJSc6IFsnU3ltYm9sJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFsnU3ludGF4RXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZWRBcnJheVByb3RvdHlwZSUnOiBbJ1R5cGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZUVycm9yUHJvdG90eXBlJSc6IFsnVHlwZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4QXJyYXlQcm90b3R5cGUlJzogWydVaW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhDbGFtcGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDE2QXJyYXlQcm90b3R5cGUlJzogWydVaW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVSSUVycm9yUHJvdG90eXBlJSc6IFsnVVJJRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha01hcFByb3RvdHlwZSUnOiBbJ1dlYWtNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha1NldFByb3RvdHlwZSUnOiBbJ1dlYWtTZXQnLCAncHJvdG90eXBlJ11cbn07XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJ2hhc293bicpO1xudmFyICRjb25jYXQgPSBiaW5kLmNhbGwoJGNhbGwsIEFycmF5LnByb3RvdHlwZS5jb25jYXQpO1xudmFyICRzcGxpY2VBcHBseSA9IGJpbmQuY2FsbCgkYXBwbHksIEFycmF5LnByb3RvdHlwZS5zcGxpY2UpO1xudmFyICRyZXBsYWNlID0gYmluZC5jYWxsKCRjYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyICRzdHJTbGljZSA9IGJpbmQuY2FsbCgkY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5zbGljZSk7XG52YXIgJGV4ZWMgPSBiaW5kLmNhbGwoJGNhbGwsIFJlZ0V4cC5wcm90b3R5cGUuZXhlYyk7XG5cbi8qIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iLzQuMTcuMTUvZGlzdC9sb2Rhc2guanMjTDY3MzUtTDY3NDQgKi9cbnZhciByZVByb3BOYW1lID0gL1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7XG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7IC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IGZ1bmN0aW9uIHN0cmluZ1RvUGF0aChzdHJpbmcpIHtcblx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHN0cmluZywgMCwgMSk7XG5cdHZhciBsYXN0ID0gJHN0clNsaWNlKHN0cmluZywgLTEpO1xuXHRpZiAoZmlyc3QgPT09ICclJyAmJiBsYXN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIGNsb3NpbmcgYCVgJyk7XG5cdH0gZWxzZSBpZiAobGFzdCA9PT0gJyUnICYmIGZpcnN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgJyk7XG5cdH1cblx0dmFyIHJlc3VsdCA9IFtdO1xuXHQkcmVwbGFjZShzdHJpbmcsIHJlUHJvcE5hbWUsIGZ1bmN0aW9uIChtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG5cdFx0cmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gcXVvdGUgPyAkcmVwbGFjZShzdWJTdHJpbmcsIHJlRXNjYXBlQ2hhciwgJyQxJykgOiBudW1iZXIgfHwgbWF0Y2g7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcbi8qIGVuZCBhZGFwdGF0aW9uICovXG5cbnZhciBnZXRCYXNlSW50cmluc2ljID0gZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpY05hbWUgPSBuYW1lO1xuXHR2YXIgYWxpYXM7XG5cdGlmIChoYXNPd24oTEVHQUNZX0FMSUFTRVMsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0YWxpYXMgPSBMRUdBQ1lfQUxJQVNFU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpbnRyaW5zaWNOYW1lID0gJyUnICsgYWxpYXNbMF0gKyAnJSc7XG5cdH1cblxuXHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0dmFyIHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpZiAodmFsdWUgPT09IG5lZWRzRXZhbCkge1xuXHRcdFx0dmFsdWUgPSBkb0V2YWwoaW50cmluc2ljTmFtZSk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmICFhbGxvd01pc3NpbmcpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIScpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhbGlhczogYWxpYXMsXG5cdFx0XHRuYW1lOiBpbnRyaW5zaWNOYW1lLFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fTtcblx0fVxuXG5cdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QhJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEdldEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYWxsb3dNaXNzaW5nICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXHR9XG5cblx0aWYgKCRleGVjKC9eJT9bXiVdKiU/JC8sIG5hbWUpID09PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignYCVgIG1heSBub3QgYmUgcHJlc2VudCBhbnl3aGVyZSBidXQgYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoZSBpbnRyaW5zaWMgbmFtZScpO1xuXHR9XG5cdHZhciBwYXJ0cyA9IHN0cmluZ1RvUGF0aChuYW1lKTtcblx0dmFyIGludHJpbnNpY0Jhc2VOYW1lID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzWzBdIDogJyc7XG5cblx0dmFyIGludHJpbnNpYyA9IGdldEJhc2VJbnRyaW5zaWMoJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJScsIGFsbG93TWlzc2luZyk7XG5cdHZhciBpbnRyaW5zaWNSZWFsTmFtZSA9IGludHJpbnNpYy5uYW1lO1xuXHR2YXIgdmFsdWUgPSBpbnRyaW5zaWMudmFsdWU7XG5cdHZhciBza2lwRnVydGhlckNhY2hpbmcgPSBmYWxzZTtcblxuXHR2YXIgYWxpYXMgPSBpbnRyaW5zaWMuYWxpYXM7XG5cdGlmIChhbGlhcykge1xuXHRcdGludHJpbnNpY0Jhc2VOYW1lID0gYWxpYXNbMF07XG5cdFx0JHNwbGljZUFwcGx5KHBhcnRzLCAkY29uY2F0KFswLCAxXSwgYWxpYXMpKTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAxLCBpc093biA9IHRydWU7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHNbaV07XG5cdFx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHBhcnQsIDAsIDEpO1xuXHRcdHZhciBsYXN0ID0gJHN0clNsaWNlKHBhcnQsIC0xKTtcblx0XHRpZiAoXG5cdFx0XHQoXG5cdFx0XHRcdChmaXJzdCA9PT0gJ1wiJyB8fCBmaXJzdCA9PT0gXCInXCIgfHwgZmlyc3QgPT09ICdgJylcblx0XHRcdFx0fHwgKGxhc3QgPT09ICdcIicgfHwgbGFzdCA9PT0gXCInXCIgfHwgbGFzdCA9PT0gJ2AnKVxuXHRcdFx0KVxuXHRcdFx0JiYgZmlyc3QgIT09IGxhc3Rcblx0XHQpIHtcblx0XHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ3Byb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXMnKTtcblx0XHR9XG5cdFx0aWYgKHBhcnQgPT09ICdjb25zdHJ1Y3RvcicgfHwgIWlzT3duKSB7XG5cdFx0XHRza2lwRnVydGhlckNhY2hpbmcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGludHJpbnNpY0Jhc2VOYW1lICs9ICcuJyArIHBhcnQ7XG5cdFx0aW50cmluc2ljUmVhbE5hbWUgPSAnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJztcblxuXHRcdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljUmVhbE5hbWUpKSB7XG5cdFx0XHR2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0aWYgKCEocGFydCBpbiB2YWx1ZSkpIHtcblx0XHRcdFx0aWYgKCFhbGxvd01pc3NpbmcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYmFzZSBpbnRyaW5zaWMgZm9yICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCB0aGUgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdm9pZCB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoJGdPUEQgJiYgKGkgKyAxKSA+PSBwYXJ0cy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGRlc2MgPSAkZ09QRCh2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdGlzT3duID0gISFkZXNjO1xuXG5cdFx0XHRcdC8vIEJ5IGNvbnZlbnRpb24sIHdoZW4gYSBkYXRhIHByb3BlcnR5IGlzIGNvbnZlcnRlZCB0byBhbiBhY2Nlc3NvclxuXHRcdFx0XHQvLyBwcm9wZXJ0eSB0byBlbXVsYXRlIGEgZGF0YSBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IHN1ZmZlciBmcm9tXG5cdFx0XHRcdC8vIHRoZSBvdmVycmlkZSBtaXN0YWtlLCB0aGF0IGFjY2Vzc29yJ3MgZ2V0dGVyIGlzIG1hcmtlZCB3aXRoXG5cdFx0XHRcdC8vIGFuIGBvcmlnaW5hbFZhbHVlYCBwcm9wZXJ0eS4gSGVyZSwgd2hlbiB3ZSBkZXRlY3QgdGhpcywgd2Vcblx0XHRcdFx0Ly8gdXBob2xkIHRoZSBpbGx1c2lvbiBieSBwcmV0ZW5kaW5nIHRvIHNlZSB0aGF0IG9yaWdpbmFsIGRhdGFcblx0XHRcdFx0Ly8gcHJvcGVydHksIGkuZS4sIHJldHVybmluZyB0aGUgdmFsdWUgcmF0aGVyIHRoYW4gdGhlIGdldHRlclxuXHRcdFx0XHQvLyBpdHNlbGYuXG5cdFx0XHRcdGlmIChpc093biAmJiAnZ2V0JyBpbiBkZXNjICYmICEoJ29yaWdpbmFsVmFsdWUnIGluIGRlc2MuZ2V0KSkge1xuXHRcdFx0XHRcdHZhbHVlID0gZGVzYy5nZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aXNPd24gPSBoYXNPd24odmFsdWUsIHBhcnQpO1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNPd24gJiYgIXNraXBGdXJ0aGVyQ2FjaGluZykge1xuXHRcdFx0XHRJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJ2VzLW9iamVjdC1hdG9tcycpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9PYmplY3QuZ2V0UHJvdG90eXBlT2YnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gJE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBudWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9SZWZsZWN0LmdldFByb3RvdHlwZU9mJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9ICh0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgUmVmbGVjdC5nZXRQcm90b3R5cGVPZikgfHwgbnVsbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlZmxlY3RHZXRQcm90byA9IHJlcXVpcmUoJy4vUmVmbGVjdC5nZXRQcm90b3R5cGVPZicpO1xudmFyIG9yaWdpbmFsR2V0UHJvdG8gPSByZXF1aXJlKCcuL09iamVjdC5nZXRQcm90b3R5cGVPZicpO1xuXG52YXIgZ2V0RHVuZGVyUHJvdG8gPSByZXF1aXJlKCdkdW5kZXItcHJvdG8vZ2V0Jyk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IHJlZmxlY3RHZXRQcm90b1xuXHQ/IGZ1bmN0aW9uIGdldFByb3RvKE8pIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGNhbid0IG5hcnJvdyBpbnNpZGUgYSBjbG9zdXJlLCBmb3Igc29tZSByZWFzb25cblx0XHRyZXR1cm4gcmVmbGVjdEdldFByb3RvKE8pO1xuXHR9XG5cdDogb3JpZ2luYWxHZXRQcm90b1xuXHRcdD8gZnVuY3Rpb24gZ2V0UHJvdG8oTykge1xuXHRcdFx0aWYgKCFPIHx8ICh0eXBlb2YgTyAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIE8gIT09ICdmdW5jdGlvbicpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2dldFByb3RvOiBub3QgYW4gb2JqZWN0Jyk7XG5cdFx0XHR9XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGNhbid0IG5hcnJvdyBpbnNpZGUgYSBjbG9zdXJlLCBmb3Igc29tZSByZWFzb25cblx0XHRcdHJldHVybiBvcmlnaW5hbEdldFByb3RvKE8pO1xuXHRcdH1cblx0XHQ6IGdldER1bmRlclByb3RvXG5cdFx0XHQ/IGZ1bmN0aW9uIGdldFByb3RvKE8pIHtcblx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBUUyBjYW4ndCBuYXJyb3cgaW5zaWRlIGEgY2xvc3VyZSwgZm9yIHNvbWUgcmVhc29uXG5cdFx0XHRcdHJldHVybiBnZXREdW5kZXJQcm90byhPKTtcblx0XHRcdH1cblx0XHRcdDogbnVsbDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vZ09QRCcpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xudmFyICRnT1BEID0gcmVxdWlyZSgnLi9nT1BEJyk7XG5cbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKFtdLCAnbGVuZ3RoJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBnT1BEXG5cdFx0JGdPUEQgPSBudWxsO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gJGdPUEQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCdlcy1kZWZpbmUtcHJvcGVydHknKTtcblxudmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMgPSBmdW5jdGlvbiBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzKCkge1xuXHRyZXR1cm4gISEkZGVmaW5lUHJvcGVydHk7XG59O1xuXG5oYXNQcm9wZXJ0eURlc2NyaXB0b3JzLmhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnID0gZnVuY3Rpb24gaGFzQXJyYXlMZW5ndGhEZWZpbmVCdWcoKSB7XG5cdC8vIG5vZGUgdjAuNiBoYXMgYSBidWcgd2hlcmUgYXJyYXkgbGVuZ3RocyBjYW4gYmUgU2V0IGJ1dCBub3QgRGVmaW5lZFxuXHRpZiAoISRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHRyeSB7XG5cdFx0cmV0dXJuICRkZWZpbmVQcm9wZXJ0eShbXSwgJ2xlbmd0aCcsIHsgdmFsdWU6IDEgfSkubGVuZ3RoICE9PSAxO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSW4gRmlyZWZveCA0LTIyLCBkZWZpbmluZyBsZW5ndGggb24gYW4gYXJyYXkgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb3JpZ1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbDtcbnZhciBoYXNTeW1ib2xTaGFtID0gcmVxdWlyZSgnLi9zaGFtcycpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2woJ2ZvbycpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2woJ2JhcicpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRyZXR1cm4gaGFzU3ltYm9sU2hhbSgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vc2hhbXMnKX0gKi9cbi8qIGVzbGludCBjb21wbGV4aXR5OiBbMiwgMThdLCBtYXgtc3RhdGVtZW50czogWzIsIDMzXSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7IHJldHVybiB0cnVlOyB9XG5cblx0LyoqIEB0eXBlIHt7IFtrIGluIHN5bWJvbF0/OiB1bmtub3duIH19ICovXG5cdHZhciBvYmogPSB7fTtcblx0dmFyIHN5bSA9IFN5bWJvbCgndGVzdCcpO1xuXHR2YXIgc3ltT2JqID0gT2JqZWN0KHN5bSk7XG5cdGlmICh0eXBlb2Ygc3ltID09PSAnc3RyaW5nJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bU9iaikgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvb2JqZWN0LmFzc2lnbi9pc3N1ZXMvMTdcblx0Ly8gaWYgKHN5bSBpbnN0YW5jZW9mIFN5bWJvbCkgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzL2lzc3Vlcy80XG5cdC8vIGlmICghKHN5bU9iaiBpbnN0YW5jZW9mIFN5bWJvbCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gaWYgKHR5cGVvZiBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyBpZiAoU3RyaW5nKHN5bSkgIT09IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1WYWwgPSA0Mjtcblx0b2JqW3N5bV0gPSBzeW1WYWw7XG5cdGZvciAodmFyIF8gaW4gb2JqKSB7IHJldHVybiBmYWxzZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby11bnJlYWNoYWJsZS1sb29wXG5cdGlmICh0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcblx0aWYgKHN5bXMubGVuZ3RoICE9PSAxIHx8IHN5bXNbMF0gIT09IHN5bSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xuXHRcdHZhciBkZXNjcmlwdG9yID0gLyoqIEB0eXBlIHtQcm9wZXJ0eURlc2NyaXB0b3J9ICovIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKSk7XG5cdFx0aWYgKGRlc2NyaXB0b3IudmFsdWUgIT09IHN5bVZhbCB8fCBkZXNjcmlwdG9yLmVudW1lcmFibGUgIT09IHRydWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMvc2hhbXMnKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzVG9TdHJpbmdUYWdTaGFtcygpIHtcblx0cmV0dXJuIGhhc1N5bWJvbHMoKSAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG52YXIgJGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gYmluZC5jYWxsKGNhbGwsICRoYXNPd24pO1xuIiwiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbnZhciBpc1N0YW5kYXJkQXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKFxuXHRcdGhhc1RvU3RyaW5nVGFnXG5cdFx0JiYgdmFsdWVcblx0XHQmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG5cdFx0JiYgU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlXG5cdCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gJHRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xudmFyIGlzTGVnYWN5QXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGlzU3RhbmRhcmRBcmd1bWVudHModmFsdWUpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIHZhbHVlICE9PSBudWxsXG5cdFx0JiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xuXHRcdCYmICdsZW5ndGgnIGluIHZhbHVlXG5cdFx0JiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcidcblx0XHQmJiB2YWx1ZS5sZW5ndGggPj0gMFxuXHRcdCYmICR0b1N0cmluZyh2YWx1ZSkgIT09ICdbb2JqZWN0IEFycmF5XSdcblx0XHQmJiAnY2FsbGVlJyBpbiB2YWx1ZVxuXHRcdCYmICR0b1N0cmluZyh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gaXNTdGFuZGFyZEFyZ3VtZW50cyhhcmd1bWVudHMpO1xufSgpKTtcblxuLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPIG1ha2UgdGhpcyBub3QgZXJyb3JcbmlzU3RhbmRhcmRBcmd1bWVudHMuaXNMZWdhY3lBcmd1bWVudHMgPSBpc0xlZ2FjeUFyZ3VtZW50czsgLy8gZm9yIHRlc3RzXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPyBpc1N0YW5kYXJkQXJndW1lbnRzIDogaXNMZWdhY3lBcmd1bWVudHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHJlZmxlY3RBcHBseSA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0ICE9PSBudWxsICYmIFJlZmxlY3QuYXBwbHk7XG52YXIgYmFkQXJyYXlMaWtlO1xudmFyIGlzQ2FsbGFibGVNYXJrZXI7XG5pZiAodHlwZW9mIHJlZmxlY3RBcHBseSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG5cdHRyeSB7XG5cdFx0YmFkQXJyYXlMaWtlID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnbGVuZ3RoJywge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRocm93IGlzQ2FsbGFibGVNYXJrZXI7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0aXNDYWxsYWJsZU1hcmtlciA9IHt9O1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG5cdFx0cmVmbGVjdEFwcGx5KGZ1bmN0aW9uICgpIHsgdGhyb3cgNDI7IH0sIG51bGwsIGJhZEFycmF5TGlrZSk7XG5cdH0gY2F0Y2ggKF8pIHtcblx0XHRpZiAoXyAhPT0gaXNDYWxsYWJsZU1hcmtlcikge1xuXHRcdFx0cmVmbGVjdEFwcGx5ID0gbnVsbDtcblx0XHR9XG5cdH1cbn0gZWxzZSB7XG5cdHJlZmxlY3RBcHBseSA9IG51bGw7XG59XG5cbnZhciBjb25zdHJ1Y3RvclJlZ2V4ID0gL15cXHMqY2xhc3NcXGIvO1xudmFyIGlzRVM2Q2xhc3NGbiA9IGZ1bmN0aW9uIGlzRVM2Q2xhc3NGdW5jdGlvbih2YWx1ZSkge1xuXHR0cnkge1xuXHRcdHZhciBmblN0ciA9IGZuVG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIGNvbnN0cnVjdG9yUmVnZXgudGVzdChmblN0cik7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7IC8vIG5vdCBhIGZ1bmN0aW9uXG5cdH1cbn07XG5cbnZhciB0cnlGdW5jdGlvbk9iamVjdCA9IGZ1bmN0aW9uIHRyeUZ1bmN0aW9uVG9TdHIodmFsdWUpIHtcblx0dHJ5IHtcblx0XHRpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRmblRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBvYmplY3RDbGFzcyA9ICdbb2JqZWN0IE9iamVjdF0nO1xudmFyIGZuQ2xhc3MgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xudmFyIGdlbkNsYXNzID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcbnZhciBkZGFDbGFzcyA9ICdbb2JqZWN0IEhUTUxBbGxDb2xsZWN0aW9uXSc7IC8vIElFIDExXG52YXIgZGRhQ2xhc3MyID0gJ1tvYmplY3QgSFRNTCBkb2N1bWVudC5hbGwgY2xhc3NdJztcbnZhciBkZGFDbGFzczMgPSAnW29iamVjdCBIVE1MQ29sbGVjdGlvbl0nOyAvLyBJRSA5LTEwXG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmICEhU3ltYm9sLnRvU3RyaW5nVGFnOyAvLyBiZXR0ZXI6IHVzZSBgaGFzLXRvc3RyaW5ndGFnYFxuXG52YXIgaXNJRTY4ID0gISgwIGluIFssXSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc3BhcnNlLWFycmF5cywgY29tbWEtc3BhY2luZ1xuXG52YXIgaXNEREEgPSBmdW5jdGlvbiBpc0RvY3VtZW50RG90QWxsKCkgeyByZXR1cm4gZmFsc2U7IH07XG5pZiAodHlwZW9mIGRvY3VtZW50ID09PSAnb2JqZWN0Jykge1xuXHQvLyBGaXJlZm94IDMgY2Fub25pY2FsaXplcyBEREEgdG8gdW5kZWZpbmVkIHdoZW4gaXQncyBub3QgYWNjZXNzZWQgZGlyZWN0bHlcblx0dmFyIGFsbCA9IGRvY3VtZW50LmFsbDtcblx0aWYgKHRvU3RyLmNhbGwoYWxsKSA9PT0gdG9TdHIuY2FsbChkb2N1bWVudC5hbGwpKSB7XG5cdFx0aXNEREEgPSBmdW5jdGlvbiBpc0RvY3VtZW50RG90QWxsKHZhbHVlKSB7XG5cdFx0XHQvKiBnbG9iYWxzIGRvY3VtZW50OiBmYWxzZSAqL1xuXHRcdFx0Ly8gaW4gSUUgNi04LCB0eXBlb2YgZG9jdW1lbnQuYWxsIGlzIFwib2JqZWN0XCIgYW5kIGl0J3MgdHJ1dGh5XG5cdFx0XHRpZiAoKGlzSUU2OCB8fCAhdmFsdWUpICYmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dmFyIHN0ciA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHRzdHIgPT09IGRkYUNsYXNzXG5cdFx0XHRcdFx0XHR8fCBzdHIgPT09IGRkYUNsYXNzMlxuXHRcdFx0XHRcdFx0fHwgc3RyID09PSBkZGFDbGFzczMgLy8gb3BlcmEgMTIuMTZcblx0XHRcdFx0XHRcdHx8IHN0ciA9PT0gb2JqZWN0Q2xhc3MgLy8gSUUgNi04XG5cdFx0XHRcdFx0KSAmJiB2YWx1ZSgnJykgPT0gbnVsbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcblx0XHRcdFx0fSBjYXRjaCAoZSkgeyAvKiovIH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVmbGVjdEFwcGx5XG5cdD8gZnVuY3Rpb24gaXNDYWxsYWJsZSh2YWx1ZSkge1xuXHRcdGlmIChpc0REQSh2YWx1ZSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRpZiAoIXZhbHVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR0cnkge1xuXHRcdFx0cmVmbGVjdEFwcGx5KHZhbHVlLCBudWxsLCBiYWRBcnJheUxpa2UpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGlmIChlICE9PSBpc0NhbGxhYmxlTWFya2VyKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gIWlzRVM2Q2xhc3NGbih2YWx1ZSkgJiYgdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpO1xuXHR9XG5cdDogZnVuY3Rpb24gaXNDYWxsYWJsZSh2YWx1ZSkge1xuXHRcdGlmIChpc0REQSh2YWx1ZSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRpZiAoIXZhbHVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAoaGFzVG9TdHJpbmdUYWcpIHsgcmV0dXJuIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTsgfVxuXHRcdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHZhciBzdHJDbGFzcyA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdGlmIChzdHJDbGFzcyAhPT0gZm5DbGFzcyAmJiBzdHJDbGFzcyAhPT0gZ2VuQ2xhc3MgJiYgISgvXlxcW29iamVjdCBIVE1MLykudGVzdChzdHJDbGFzcykpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0cmV0dXJuIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTtcblx0fTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYm91bmQnKTtcbnZhciBzYWZlUmVnZXhUZXN0ID0gcmVxdWlyZSgnc2FmZS1yZWdleC10ZXN0Jyk7XG52YXIgaXNGblJlZ2V4ID0gc2FmZVJlZ2V4VGVzdCgvXlxccyooPzpmdW5jdGlvbik/XFwqLyk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xudmFyIGdldFByb3RvID0gcmVxdWlyZSgnZ2V0LXByb3RvJyk7XG5cbnZhciB0b1N0ciA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGZuVG9TdHIgPSBjYWxsQm91bmQoJ0Z1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZycpO1xuXG52YXIgZ2V0R2VuZXJhdG9yRnVuY3Rpb24gPSByZXF1aXJlKCdnZW5lcmF0b3ItZnVuY3Rpb24nKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihmbikge1xuXHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmIChpc0ZuUmVnZXgoZm5Ub1N0cihmbikpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciBzdHIgPSB0b1N0cihmbik7XG5cdFx0cmV0dXJuIHN0ciA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblx0fVxuXHRpZiAoIWdldFByb3RvKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHZhciBHZW5lcmF0b3JGdW5jdGlvbiA9IGdldEdlbmVyYXRvckZ1bmN0aW9uKCk7XG5cdHJldHVybiBHZW5lcmF0b3JGdW5jdGlvbiAmJiBnZXRQcm90byhmbikgPT09IEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIHNoaW0gPSByZXF1aXJlKCcuL3NoaW0nKTtcblxudmFyIHBvbHlmaWxsID0gY2FsbEJpbmQoZ2V0UG9seWZpbGwoKSwgTnVtYmVyKTtcblxuLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG5kZWZpbmUocG9seWZpbGwsIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdGlmIChOdW1iZXIuaXNOYU4gJiYgTnVtYmVyLmlzTmFOKE5hTikgJiYgIU51bWJlci5pc05hTignYScpKSB7XG5cdFx0cmV0dXJuIE51bWJlci5pc05hTjtcblx0fVxuXHRyZXR1cm4gaW1wbGVtZW50YXRpb247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcblxuLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1OdW1iZXJJc05hTigpIHtcblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0ZGVmaW5lKE51bWJlciwgeyBpc05hTjogcG9seWZpbGwgfSwge1xuXHRcdGlzTmFOOiBmdW5jdGlvbiB0ZXN0SXNOYU4oKSB7XG5cdFx0XHRyZXR1cm4gTnVtYmVyLmlzTmFOICE9PSBwb2x5ZmlsbDtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcG9seWZpbGw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1ib3VuZCcpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCdoYXNvd24nKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnZ29wZCcpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xudmFyIGZuO1xuXG5pZiAoaGFzVG9TdHJpbmdUYWcpIHtcblx0LyoqIEB0eXBlIHsocmVjZWl2ZXI6IFRoaXNQYXJhbWV0ZXJUeXBlPHR5cGVvZiBSZWdFeHAucHJvdG90eXBlLmV4ZWM+LCAuLi5hcmdzOiBQYXJhbWV0ZXJzPHR5cGVvZiBSZWdFeHAucHJvdG90eXBlLmV4ZWM+KSA9PiBSZXR1cm5UeXBlPHR5cGVvZiBSZWdFeHAucHJvdG90eXBlLmV4ZWM+fSAqL1xuXHR2YXIgJGV4ZWMgPSBjYWxsQm91bmQoJ1JlZ0V4cC5wcm90b3R5cGUuZXhlYycpO1xuXHQvKiogQHR5cGUge29iamVjdH0gKi9cblx0dmFyIGlzUmVnZXhNYXJrZXIgPSB7fTtcblxuXHR2YXIgdGhyb3dSZWdleE1hcmtlciA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aHJvdyBpc1JlZ2V4TWFya2VyO1xuXHR9O1xuXHQvKiogQHR5cGUge3sgdG9TdHJpbmcoKTogbmV2ZXIsIHZhbHVlT2YoKTogbmV2ZXIsIFtTeW1ib2wudG9QcmltaXRpdmVdPygpOiBuZXZlciB9fSAqL1xuXHR2YXIgYmFkU3RyaW5naWZpZXIgPSB7XG5cdFx0dG9TdHJpbmc6IHRocm93UmVnZXhNYXJrZXIsXG5cdFx0dmFsdWVPZjogdGhyb3dSZWdleE1hcmtlclxuXHR9O1xuXG5cdGlmICh0eXBlb2YgU3ltYm9sLnRvUHJpbWl0aXZlID09PSAnc3ltYm9sJykge1xuXHRcdGJhZFN0cmluZ2lmaWVyW1N5bWJvbC50b1ByaW1pdGl2ZV0gPSB0aHJvd1JlZ2V4TWFya2VyO1xuXHR9XG5cblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cblx0Ly8gQHRzLWV4cGVjdC1lcnJvciBUUyBjYW4ndCBmaWd1cmUgb3V0IHRoYXQgdGhlICRleGVjIGNhbGwgYWx3YXlzIHRocm93c1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblx0Zm4gPSBmdW5jdGlvbiBpc1JlZ2V4KHZhbHVlKSB7XG5cdFx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xuXHRcdHZhciBkZXNjcmlwdG9yID0gLyoqIEB0eXBlIHtOb25OdWxsYWJsZTx0eXBlb2YgZ09QRD59ICovIChnT1BEKSgvKiogQHR5cGUge3sgbGFzdEluZGV4PzogdW5rbm93biB9fSAqLyAodmFsdWUpLCAnbGFzdEluZGV4Jyk7XG5cdFx0dmFyIGhhc0xhc3RJbmRleERhdGFQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgaGFzT3duKGRlc2NyaXB0b3IsICd2YWx1ZScpO1xuXHRcdGlmICghaGFzTGFzdEluZGV4RGF0YVByb3BlcnR5KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcblx0XHRcdCRleGVjKHZhbHVlLCAvKiogQHR5cGUge3N0cmluZ30gKi8gKC8qKiBAdHlwZSB7dW5rbm93bn0gKi8gKGJhZFN0cmluZ2lmaWVyKSkpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBlID09PSBpc1JlZ2V4TWFya2VyO1xuXHRcdH1cblx0fTtcbn0gZWxzZSB7XG5cdC8qKiBAdHlwZSB7KHJlY2VpdmVyOiBUaGlzUGFyYW1ldGVyVHlwZTx0eXBlb2YgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZz4sIC4uLmFyZ3M6IFBhcmFtZXRlcnM8dHlwZW9mIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc+KSA9PiBSZXR1cm5UeXBlPHR5cGVvZiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nPn0gKi9cblx0dmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xuXHQvKiogQGNvbnN0IEB0eXBlIHsnW29iamVjdCBSZWdFeHBdJ30gKi9cblx0dmFyIHJlZ2V4Q2xhc3MgPSAnW29iamVjdCBSZWdFeHBdJztcblxuXHQvKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xuXHRmbiA9IGZ1bmN0aW9uIGlzUmVnZXgodmFsdWUpIHtcblx0XHQvLyBJbiBvbGRlciBicm93c2VycywgdHlwZW9mIHJlZ2V4IGluY29ycmVjdGx5IHJldHVybnMgJ2Z1bmN0aW9uJ1xuXHRcdGlmICghdmFsdWUgfHwgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiAkdG9TdHJpbmcodmFsdWUpID09PSByZWdleENsYXNzO1xuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2hpY2hUeXBlZEFycmF5ID0gcmVxdWlyZSgnd2hpY2gtdHlwZWQtYXJyYXknKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG5cdHJldHVybiAhIXdoaWNoVHlwZWRBcnJheSh2YWx1ZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9hYnMnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gTWF0aC5hYnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2Zsb29yJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguZmxvb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2lzTmFOJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBpc05hTihhKSB7XG5cdHJldHVybiBhICE9PSBhO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vbWF4Jyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgubWF4O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9taW4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gTWF0aC5taW47XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3BvdycpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnBvdztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vcm91bmQnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gTWF0aC5yb3VuZDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyICRpc05hTiA9IHJlcXVpcmUoJy4vaXNOYU4nKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vc2lnbicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaWduKG51bWJlcikge1xuXHRpZiAoJGlzTmFOKG51bWJlcikgfHwgbnVtYmVyID09PSAwKSB7XG5cdFx0cmV0dXJuIG51bWJlcjtcblx0fVxuXHRyZXR1cm4gbnVtYmVyIDwgMCA/IC0xIDogKzE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbnVtYmVySXNOYU4gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXMoYSwgYikge1xuXHRpZiAoYSA9PT0gMCAmJiBiID09PSAwKSB7XG5cdFx0cmV0dXJuIDEgLyBhID09PSAxIC8gYjtcblx0fVxuXHRpZiAoYSA9PT0gYikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmIChudW1iZXJJc05hTihhKSAmJiBudW1iZXJJc05hTihiKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCdjYWxsLWJpbmQnKTtcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIHNoaW0gPSByZXF1aXJlKCcuL3NoaW0nKTtcblxudmFyIHBvbHlmaWxsID0gY2FsbEJpbmQoZ2V0UG9seWZpbGwoKSwgT2JqZWN0KTtcblxuZGVmaW5lKHBvbHlmaWxsLCB7XG5cdGdldFBvbHlmaWxsOiBnZXRQb2x5ZmlsbCxcblx0aW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uLFxuXHRzaGltOiBzaGltXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwb2x5ZmlsbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRyZXR1cm4gdHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGltcGxlbWVudGF0aW9uO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbU9iamVjdElzKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoT2JqZWN0LCB7IGlzOiBwb2x5ZmlsbCB9LCB7XG5cdFx0aXM6IGZ1bmN0aW9uIHRlc3RPYmplY3RJcygpIHtcblx0XHRcdHJldHVybiBPYmplY3QuaXMgIT09IHBvbHlmaWxsO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBrZXlzU2hpbTtcbmlmICghT2JqZWN0LmtleXMpIHtcblx0Ly8gbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cblx0dmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cdHZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdHZhciBpc0FyZ3MgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ2xvYmFsLXJlcXVpcmVcblx0dmFyIGlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cdHZhciBoYXNEb250RW51bUJ1ZyA9ICFpc0VudW1lcmFibGUuY2FsbCh7IHRvU3RyaW5nOiBudWxsIH0sICd0b1N0cmluZycpO1xuXHR2YXIgaGFzUHJvdG9FbnVtQnVnID0gaXNFbnVtZXJhYmxlLmNhbGwoZnVuY3Rpb24gKCkge30sICdwcm90b3R5cGUnKTtcblx0dmFyIGRvbnRFbnVtcyA9IFtcblx0XHQndG9TdHJpbmcnLFxuXHRcdCd0b0xvY2FsZVN0cmluZycsXG5cdFx0J3ZhbHVlT2YnLFxuXHRcdCdoYXNPd25Qcm9wZXJ0eScsXG5cdFx0J2lzUHJvdG90eXBlT2YnLFxuXHRcdCdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG5cdFx0J2NvbnN0cnVjdG9yJ1xuXHRdO1xuXHR2YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUgPSBmdW5jdGlvbiAobykge1xuXHRcdHZhciBjdG9yID0gby5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gY3RvciAmJiBjdG9yLnByb3RvdHlwZSA9PT0gbztcblx0fTtcblx0dmFyIGV4Y2x1ZGVkS2V5cyA9IHtcblx0XHQkYXBwbGljYXRpb25DYWNoZTogdHJ1ZSxcblx0XHQkY29uc29sZTogdHJ1ZSxcblx0XHQkZXh0ZXJuYWw6IHRydWUsXG5cdFx0JGZyYW1lOiB0cnVlLFxuXHRcdCRmcmFtZUVsZW1lbnQ6IHRydWUsXG5cdFx0JGZyYW1lczogdHJ1ZSxcblx0XHQkaW5uZXJIZWlnaHQ6IHRydWUsXG5cdFx0JGlubmVyV2lkdGg6IHRydWUsXG5cdFx0JG9ubW96ZnVsbHNjcmVlbmNoYW5nZTogdHJ1ZSxcblx0XHQkb25tb3pmdWxsc2NyZWVuZXJyb3I6IHRydWUsXG5cdFx0JG91dGVySGVpZ2h0OiB0cnVlLFxuXHRcdCRvdXRlcldpZHRoOiB0cnVlLFxuXHRcdCRwYWdlWE9mZnNldDogdHJ1ZSxcblx0XHQkcGFnZVlPZmZzZXQ6IHRydWUsXG5cdFx0JHBhcmVudDogdHJ1ZSxcblx0XHQkc2Nyb2xsTGVmdDogdHJ1ZSxcblx0XHQkc2Nyb2xsVG9wOiB0cnVlLFxuXHRcdCRzY3JvbGxYOiB0cnVlLFxuXHRcdCRzY3JvbGxZOiB0cnVlLFxuXHRcdCRzZWxmOiB0cnVlLFxuXHRcdCR3ZWJraXRJbmRleGVkREI6IHRydWUsXG5cdFx0JHdlYmtpdFN0b3JhZ2VJbmZvOiB0cnVlLFxuXHRcdCR3aW5kb3c6IHRydWVcblx0fTtcblx0dmFyIGhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0LyogZ2xvYmFsIHdpbmRvdyAqL1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRmb3IgKHZhciBrIGluIHdpbmRvdykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKCFleGNsdWRlZEtleXNbJyQnICsga10gJiYgaGFzLmNhbGwod2luZG93LCBrKSAmJiB3aW5kb3dba10gIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvd1trXSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0ZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUod2luZG93W2tdKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSgpKTtcblx0dmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneSA9IGZ1bmN0aW9uIChvKSB7XG5cdFx0LyogZ2xvYmFsIHdpbmRvdyAqL1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnKSB7XG5cdFx0XHRyZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHRrZXlzU2hpbSA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG5cdFx0dmFyIGlzT2JqZWN0ID0gb2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnO1xuXHRcdHZhciBpc0Z1bmN0aW9uID0gdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHRcdHZhciBpc0FyZ3VtZW50cyA9IGlzQXJncyhvYmplY3QpO1xuXHRcdHZhciBpc1N0cmluZyA9IGlzT2JqZWN0ICYmIHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cdFx0dmFyIHRoZUtleXMgPSBbXTtcblxuXHRcdGlmICghaXNPYmplY3QgJiYgIWlzRnVuY3Rpb24gJiYgIWlzQXJndW1lbnRzKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0Jyk7XG5cdFx0fVxuXG5cdFx0dmFyIHNraXBQcm90byA9IGhhc1Byb3RvRW51bUJ1ZyAmJiBpc0Z1bmN0aW9uO1xuXHRcdGlmIChpc1N0cmluZyAmJiBvYmplY3QubGVuZ3RoID4gMCAmJiAhaGFzLmNhbGwob2JqZWN0LCAwKSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhpKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGlzQXJndW1lbnRzICYmIG9iamVjdC5sZW5ndGggPiAwKSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IG9iamVjdC5sZW5ndGg7ICsraikge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGopKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcblx0XHRcdFx0aWYgKCEoc2tpcFByb3RvICYmIG5hbWUgPT09ICdwcm90b3R5cGUnKSAmJiBoYXMuY2FsbChvYmplY3QsIG5hbWUpKSB7XG5cdFx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhuYW1lKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaGFzRG9udEVudW1CdWcpIHtcblx0XHRcdHZhciBza2lwQ29uc3RydWN0b3IgPSBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kob2JqZWN0KTtcblxuXHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBkb250RW51bXMubGVuZ3RoOyArK2spIHtcblx0XHRcdFx0aWYgKCEoc2tpcENvbnN0cnVjdG9yICYmIGRvbnRFbnVtc1trXSA9PT0gJ2NvbnN0cnVjdG9yJykgJiYgaGFzLmNhbGwob2JqZWN0LCBkb250RW51bXNba10pKSB7XG5cdFx0XHRcdFx0dGhlS2V5cy5wdXNoKGRvbnRFbnVtc1trXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoZUtleXM7XG5cdH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaXNBcmdzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpO1xuXG52YXIgb3JpZ0tleXMgPSBPYmplY3Qua2V5cztcbnZhciBrZXlzU2hpbSA9IG9yaWdLZXlzID8gZnVuY3Rpb24ga2V5cyhvKSB7IHJldHVybiBvcmlnS2V5cyhvKTsgfSA6IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxudmFyIG9yaWdpbmFsS2V5cyA9IE9iamVjdC5rZXlzO1xuXG5rZXlzU2hpbS5zaGltID0gZnVuY3Rpb24gc2hpbU9iamVjdEtleXMoKSB7XG5cdGlmIChPYmplY3Qua2V5cykge1xuXHRcdHZhciBrZXlzV29ya3NXaXRoQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIFNhZmFyaSA1LjAgYnVnXG5cdFx0XHR2YXIgYXJncyA9IE9iamVjdC5rZXlzKGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gYXJncyAmJiBhcmdzLmxlbmd0aCA9PT0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHR9KDEsIDIpKTtcblx0XHRpZiAoIWtleXNXb3Jrc1dpdGhBcmd1bWVudHMpIHtcblx0XHRcdE9iamVjdC5rZXlzID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcblx0XHRcdFx0aWYgKGlzQXJncyhvYmplY3QpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhzbGljZS5jYWxsKG9iamVjdCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMob2JqZWN0KTtcblx0XHRcdH07XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdE9iamVjdC5rZXlzID0ga2V5c1NoaW07XG5cdH1cblx0cmV0dXJuIE9iamVjdC5rZXlzIHx8IGtleXNTaGltO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHR2YXIgc3RyID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdHZhciBpc0FyZ3MgPSBzdHIgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXHRpZiAoIWlzQXJncykge1xuXHRcdGlzQXJncyA9IHN0ciAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdFx0dmFsdWUgIT09IG51bGwgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdFx0dG9TdHIuY2FsbCh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHR9XG5cdHJldHVybiBpc0FyZ3M7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczYtc2hpbVxudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCdvYmplY3Qta2V5cycpO1xudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scy9zaGFtcycpKCk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1ib3VuZCcpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCdlcy1vYmplY3QtYXRvbXMnKTtcbnZhciAkcHVzaCA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLnB1c2gnKTtcbnZhciAkcHJvcElzRW51bWVyYWJsZSA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZScpO1xudmFyIG9yaWdpbmFsR2V0U3ltYm9scyA9IGhhc1N5bWJvbHMgPyAkT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA6IG51bGw7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UxKSB7XG5cdGlmICh0YXJnZXQgPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCd0YXJnZXQgbXVzdCBiZSBhbiBvYmplY3QnKTsgfVxuXHR2YXIgdG8gPSAkT2JqZWN0KHRhcmdldCk7IC8vIHN0ZXAgMVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdHJldHVybiB0bzsgLy8gc3RlcCAyXG5cdH1cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyArK3MpIHtcblx0XHR2YXIgZnJvbSA9ICRPYmplY3QoYXJndW1lbnRzW3NdKTsgLy8gc3RlcCAzLmEuaVxuXG5cdFx0Ly8gc3RlcCAzLmEuaWk6XG5cdFx0dmFyIGtleXMgPSBvYmplY3RLZXlzKGZyb20pO1xuXHRcdHZhciBnZXRTeW1ib2xzID0gaGFzU3ltYm9scyAmJiAoJE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgfHwgb3JpZ2luYWxHZXRTeW1ib2xzKTtcblx0XHRpZiAoZ2V0U3ltYm9scykge1xuXHRcdFx0dmFyIHN5bXMgPSBnZXRTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzeW1zLmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdHZhciBrZXkgPSBzeW1zW2pdO1xuXHRcdFx0XHRpZiAoJHByb3BJc0VudW1lcmFibGUoZnJvbSwga2V5KSkge1xuXHRcdFx0XHRcdCRwdXNoKGtleXMsIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzdGVwIDMuYS5paWk6XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHR2YXIgbmV4dEtleSA9IGtleXNbaV07XG5cdFx0XHRpZiAoJHByb3BJc0VudW1lcmFibGUoZnJvbSwgbmV4dEtleSkpIHsgLy8gc3RlcCAzLmEuaWlpLjJcblx0XHRcdFx0dmFyIHByb3BWYWx1ZSA9IGZyb21bbmV4dEtleV07IC8vIHN0ZXAgMy5hLmlpaS4yLmFcblx0XHRcdFx0dG9bbmV4dEtleV0gPSBwcm9wVmFsdWU7IC8vIHN0ZXAgMy5hLmlpaS4yLmJcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87IC8vIHN0ZXAgNFxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG52YXIgbGFja3NQcm9wZXJFbnVtZXJhdGlvbk9yZGVyID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0Lypcblx0ICogdjgsIHNwZWNpZmljYWxseSBpbiBub2RlIDQueCwgaGFzIGEgYnVnIHdpdGggaW5jb3JyZWN0IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyXG5cdCAqIG5vdGU6IHRoaXMgZG9lcyBub3QgZGV0ZWN0IHRoZSBidWcgdW5sZXNzIHRoZXJlJ3MgMjAgY2hhcmFjdGVyc1xuXHQgKi9cblx0dmFyIHN0ciA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG5cdHZhciBsZXR0ZXJzID0gc3RyLnNwbGl0KCcnKTtcblx0dmFyIG1hcCA9IHt9O1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxldHRlcnMubGVuZ3RoOyArK2kpIHtcblx0XHRtYXBbbGV0dGVyc1tpXV0gPSBsZXR0ZXJzW2ldO1xuXHR9XG5cdHZhciBvYmogPSBPYmplY3QuYXNzaWduKHt9LCBtYXApO1xuXHR2YXIgYWN0dWFsID0gJyc7XG5cdGZvciAodmFyIGsgaW4gb2JqKSB7XG5cdFx0YWN0dWFsICs9IGs7XG5cdH1cblx0cmV0dXJuIHN0ciAhPT0gYWN0dWFsO1xufTtcblxudmFyIGFzc2lnbkhhc1BlbmRpbmdFeGNlcHRpb25zID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoIU9iamVjdC5hc3NpZ24gfHwgIU9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHQvKlxuXHQgKiBGaXJlZm94IDM3IHN0aWxsIGhhcyBcInBlbmRpbmcgZXhjZXB0aW9uXCIgbG9naWMgaW4gaXRzIE9iamVjdC5hc3NpZ24gaW1wbGVtZW50YXRpb24sXG5cdCAqIHdoaWNoIGlzIDcyJSBzbG93ZXIgdGhhbiBvdXIgc2hpbSwgYW5kIEZpcmVmb3ggNDAncyBuYXRpdmUgaW1wbGVtZW50YXRpb24uXG5cdCAqL1xuXHR2YXIgdGhyb3dlciA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7IDE6IDIgfSk7XG5cdHRyeSB7XG5cdFx0T2JqZWN0LmFzc2lnbih0aHJvd2VyLCAneHknKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiB0aHJvd2VyWzFdID09PSAneSc7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xuXHR9XG5cdGlmIChsYWNrc1Byb3BlckVudW1lcmF0aW9uT3JkZXIoKSkge1xuXHRcdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcblx0fVxuXHRpZiAoYXNzaWduSGFzUGVuZGluZ0V4Y2VwdGlvbnMoKSkge1xuXHRcdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmFzc2lnbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFtcblx0J0Zsb2F0MTZBcnJheScsXG5cdCdGbG9hdDMyQXJyYXknLFxuXHQnRmxvYXQ2NEFycmF5Jyxcblx0J0ludDhBcnJheScsXG5cdCdJbnQxNkFycmF5Jyxcblx0J0ludDMyQXJyYXknLFxuXHQnVWludDhBcnJheScsXG5cdCdVaW50OENsYW1wZWRBcnJheScsXG5cdCdVaW50MTZBcnJheScsXG5cdCdVaW50MzJBcnJheScsXG5cdCdCaWdJbnQ2NEFycmF5Jyxcblx0J0JpZ1VpbnQ2NEFycmF5J1xuXTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJvdW5kJyk7XG52YXIgaXNSZWdleCA9IHJlcXVpcmUoJ2lzLXJlZ2V4Jyk7XG5cbnZhciAkZXhlYyA9IGNhbGxCb3VuZCgnUmVnRXhwLnByb3RvdHlwZS5leGVjJyk7XG52YXIgJFR5cGVFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy90eXBlJyk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlZ2V4VGVzdGVyKHJlZ2V4KSB7XG5cdGlmICghaXNSZWdleChyZWdleCkpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYHJlZ2V4YCBtdXN0IGJlIGEgUmVnRXhwJyk7XG5cdH1cblx0cmV0dXJuIGZ1bmN0aW9uIHRlc3Qocykge1xuXHRcdHJldHVybiAkZXhlYyhyZWdleCwgcykgIT09IG51bGw7XG5cdH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1kYXRhLXByb3BlcnR5Jyk7XG52YXIgaGFzRGVzY3JpcHRvcnMgPSByZXF1aXJlKCdoYXMtcHJvcGVydHktZGVzY3JpcHRvcnMnKSgpO1xudmFyIGdPUEQgPSByZXF1aXJlKCdnb3BkJyk7XG5cbnZhciAkVHlwZUVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3R5cGUnKTtcbnZhciAkZmxvb3IgPSBHZXRJbnRyaW5zaWMoJyVNYXRoLmZsb29yJScpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXRGdW5jdGlvbkxlbmd0aChmbiwgbGVuZ3RoKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYGZuYCBpcyBub3QgYSBmdW5jdGlvbicpO1xuXHR9XG5cdGlmICh0eXBlb2YgbGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBsZW5ndGggPCAwIHx8IGxlbmd0aCA+IDB4RkZGRkZGRkYgfHwgJGZsb29yKGxlbmd0aCkgIT09IGxlbmd0aCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbGVuZ3RoYCBtdXN0IGJlIGEgcG9zaXRpdmUgMzItYml0IGludGVnZXInKTtcblx0fVxuXG5cdHZhciBsb29zZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmICEhYXJndW1lbnRzWzJdO1xuXG5cdHZhciBmdW5jdGlvbkxlbmd0aElzQ29uZmlndXJhYmxlID0gdHJ1ZTtcblx0dmFyIGZ1bmN0aW9uTGVuZ3RoSXNXcml0YWJsZSA9IHRydWU7XG5cdGlmICgnbGVuZ3RoJyBpbiBmbiAmJiBnT1BEKSB7XG5cdFx0dmFyIGRlc2MgPSBnT1BEKGZuLCAnbGVuZ3RoJyk7XG5cdFx0aWYgKGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlKSB7XG5cdFx0XHRmdW5jdGlvbkxlbmd0aElzQ29uZmlndXJhYmxlID0gZmFsc2U7XG5cdFx0fVxuXHRcdGlmIChkZXNjICYmICFkZXNjLndyaXRhYmxlKSB7XG5cdFx0XHRmdW5jdGlvbkxlbmd0aElzV3JpdGFibGUgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRpZiAoZnVuY3Rpb25MZW5ndGhJc0NvbmZpZ3VyYWJsZSB8fCBmdW5jdGlvbkxlbmd0aElzV3JpdGFibGUgfHwgIWxvb3NlKSB7XG5cdFx0aWYgKGhhc0Rlc2NyaXB0b3JzKSB7XG5cdFx0XHRkZWZpbmUoLyoqIEB0eXBlIHtQYXJhbWV0ZXJzPGRlZmluZT5bMF19ICovIChmbiksICdsZW5ndGgnLCBsZW5ndGgsIHRydWUsIHRydWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWZpbmUoLyoqIEB0eXBlIHtQYXJhbWV0ZXJzPGRlZmluZT5bMF19ICovIChmbiksICdsZW5ndGgnLCBsZW5ndGgpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZm47XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvdXRpbC90eXBlcy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8xMTJjYzdjMjc1NTEyNTRhYTJiMTcwOThmYjc3NDg2N2YwNWVkMGQ5XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJndW1lbnRzT2JqZWN0ID0gcmVxdWlyZSgnaXMtYXJndW1lbnRzJyk7XG52YXIgaXNHZW5lcmF0b3JGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWdlbmVyYXRvci1mdW5jdGlvbicpO1xudmFyIHdoaWNoVHlwZWRBcnJheSA9IHJlcXVpcmUoJ3doaWNoLXR5cGVkLWFycmF5Jyk7XG52YXIgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnaXMtdHlwZWQtYXJyYXknKTtcblxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZi5jYWxsLmJpbmQoZik7XG59XG5cbnZhciBCaWdJbnRTdXBwb3J0ZWQgPSB0eXBlb2YgQmlnSW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBTeW1ib2xTdXBwb3J0ZWQgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcblxudmFyIE9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbnZhciBudW1iZXJWYWx1ZSA9IHVuY3VycnlUaGlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZik7XG52YXIgc3RyaW5nVmFsdWUgPSB1bmN1cnJ5VGhpcyhTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIGJvb2xlYW5WYWx1ZSA9IHVuY3VycnlUaGlzKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YpO1xuXG5pZiAoQmlnSW50U3VwcG9ydGVkKSB7XG4gIHZhciBiaWdJbnRWYWx1ZSA9IHVuY3VycnlUaGlzKEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmlmIChTeW1ib2xTdXBwb3J0ZWQpIHtcbiAgdmFyIHN5bWJvbFZhbHVlID0gdW5jdXJyeVRoaXMoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgcHJvdG90eXBlVmFsdWVPZikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIHByb3RvdHlwZVZhbHVlT2YodmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0cy5pc0FyZ3VtZW50c09iamVjdCA9IGlzQXJndW1lbnRzT2JqZWN0O1xuZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gaXNHZW5lcmF0b3JGdW5jdGlvbjtcbmV4cG9ydHMuaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuXG4vLyBUYWtlbiBmcm9tIGhlcmUgYW5kIG1vZGlmaWVkIGZvciBiZXR0ZXIgYnJvd3NlciBzdXBwb3J0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3AtaXMtcHJvbWlzZS9ibG9iL2NkYTM1YTUxM2JkYTAzZjk3N2FkNWNkZTNhMDc5ZDIzN2U4MmQ3ZWYvaW5kZXguanNcbmZ1bmN0aW9uIGlzUHJvbWlzZShpbnB1dCkge1xuXHRyZXR1cm4gKFxuXHRcdChcblx0XHRcdHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdFx0aW5wdXQgaW5zdGFuY2VvZiBQcm9taXNlXG5cdFx0KSB8fFxuXHRcdChcblx0XHRcdGlucHV0ICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LmNhdGNoID09PSAnZnVuY3Rpb24nXG5cdFx0KVxuXHQpO1xufVxuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEFycmF5QnVmZmVyLmlzVmlldykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBpc1R5cGVkQXJyYXkodmFsdWUpIHx8XG4gICAgaXNEYXRhVmlldyh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlclZpZXcgPSBpc0FycmF5QnVmZmVyVmlldztcblxuXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OEFycmF5ID0gaXNVaW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhDbGFtcGVkQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQ4Q2xhbXBlZEFycmF5ID0gaXNVaW50OENsYW1wZWRBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50MTZBcnJheSA9IGlzVWludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MzJBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDMyQXJyYXkgPSBpc1VpbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDhBcnJheSc7XG59XG5leHBvcnRzLmlzSW50OEFycmF5ID0gaXNJbnQ4QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDE2QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDE2QXJyYXkgPSBpc0ludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDMyQXJyYXkgPSBpc0ludDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDMyQXJyYXkgPSBpc0Zsb2F0MzJBcnJheTtcblxuZnVuY3Rpb24gaXNGbG9hdDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0Zsb2F0NjRBcnJheSA9IGlzRmxvYXQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ0ludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdJbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdJbnQ2NEFycmF5ID0gaXNCaWdJbnQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnVWludDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0JpZ1VpbnQ2NEFycmF5ID0gaXNCaWdVaW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNNYXBUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXBdJztcbn1cbmlzTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNNYXBUb1N0cmluZyhuZXcgTWFwKCkpXG4pO1xuXG5mdW5jdGlvbiBpc01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNNYXBUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBNYXA7XG59XG5leHBvcnRzLmlzTWFwID0gaXNNYXA7XG5cbmZ1bmN0aW9uIGlzU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0XSc7XG59XG5pc1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzU2V0VG9TdHJpbmcobmV3IFNldCgpKVxuKTtcbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1NldFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzU2V0VG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNldDtcbn1cbmV4cG9ydHMuaXNTZXQgPSBpc1NldDtcblxuZnVuY3Rpb24gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha01hcF0nO1xufVxuaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha01hcFRvU3RyaW5nKG5ldyBXZWFrTWFwKCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFdlYWtNYXA7XG59XG5leHBvcnRzLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcblxuZnVuY3Rpb24gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha1NldF0nO1xufVxuaXNXZWFrU2V0VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha1NldFRvU3RyaW5nKG5ldyBXZWFrU2V0KCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSk7XG59XG5leHBvcnRzLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5pc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0FycmF5QnVmZmVyVG9TdHJpbmcobmV3IEFycmF5QnVmZmVyKCkpXG4pO1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBEYXRhVmlld10nO1xufVxuaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIERhdGFWaWV3ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0RhdGFWaWV3VG9TdHJpbmcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSwgMCwgMSkpXG4pO1xuZnVuY3Rpb24gaXNEYXRhVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBEYXRhVmlldztcbn1cbmV4cG9ydHMuaXNEYXRhVmlldyA9IGlzRGF0YVZpZXc7XG5cbi8vIFN0b3JlIGEgY29weSBvZiBTaGFyZWRBcnJheUJ1ZmZlciBpbiBjYXNlIGl0J3MgZGVsZXRlZCBlbHNld2hlcmVcbnZhciBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPSB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnID8gU2hhcmVkQXJyYXlCdWZmZXIgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdJztcbn1cbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgU2hhcmVkQXJyYXlCdWZmZXJDb3B5KCkpO1xuICB9XG5cbiAgcmV0dXJuIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyQ29weTtcbn1cbmV4cG9ydHMuaXNTaGFyZWRBcnJheUJ1ZmZlciA9IGlzU2hhcmVkQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzQXN5bmNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc7XG59XG5leHBvcnRzLmlzQXN5bmNGdW5jdGlvbiA9IGlzQXN5bmNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNNYXBJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXAgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNNYXBJdGVyYXRvciA9IGlzTWFwSXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzU2V0SXRlcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0IEl0ZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzU2V0SXRlcmF0b3IgPSBpc1NldEl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBpc0dlbmVyYXRvck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBHZW5lcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNHZW5lcmF0b3JPYmplY3QgPSBpc0dlbmVyYXRvck9iamVjdDtcblxuZnVuY3Rpb24gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYkFzc2VtYmx5Lk1vZHVsZV0nO1xufVxuZXhwb3J0cy5pc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUgPSBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGU7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBudW1iZXJWYWx1ZSk7XG59XG5leHBvcnRzLmlzTnVtYmVyT2JqZWN0ID0gaXNOdW1iZXJPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzdHJpbmdWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3RyaW5nT2JqZWN0ID0gaXNTdHJpbmdPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYm9vbGVhblZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCb29sZWFuT2JqZWN0ID0gaXNCb29sZWFuT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0JpZ0ludE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gQmlnSW50U3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJpZ0ludFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCaWdJbnRPYmplY3QgPSBpc0JpZ0ludE9iamVjdDtcblxuZnVuY3Rpb24gaXNTeW1ib2xPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIFN5bWJvbFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzeW1ib2xWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3ltYm9sT2JqZWN0ID0gaXNTeW1ib2xPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm94ZWRQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICBpc051bWJlck9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N0cmluZ09iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHx8XG4gICAgaXNCaWdJbnRPYmplY3QodmFsdWUpIHx8XG4gICAgaXNTeW1ib2xPYmplY3QodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQm94ZWRQcmltaXRpdmUgPSBpc0JveGVkUHJpbWl0aXZlO1xuXG5mdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzQXJyYXlCdWZmZXIodmFsdWUpIHx8XG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBbnlBcnJheUJ1ZmZlciA9IGlzQW55QXJyYXlCdWZmZXI7XG5cblsnaXNQcm94eScsICdpc0V4dGVybmFsJywgJ2lzTW9kdWxlTmFtZXNwYWNlT2JqZWN0J10uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG1ldGhvZCwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdXNlcmxhbmQnKTtcbiAgICB9XG4gIH0pO1xufSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fFxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52UmVnZXggPSAvXiQvO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykge1xuICB2YXIgZGVidWdFbnYgPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHO1xuICBkZWJ1Z0VudiA9IGRlYnVnRW52LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrPy5dL2csICdcXFxcJCYnKVxuICAgIC5yZXBsYWNlKC9cXCovZywgJy4qJylcbiAgICAucmVwbGFjZSgvLC9nLCAnJHxeJylcbiAgICAudG9VcHBlckNhc2UoKTtcbiAgZGVidWdFbnZSZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgZGVidWdFbnYgKyAnJCcsICdpJyk7XG59XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKGRlYnVnRW52UmVnZXgudGVzdChzZXQpKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnNsaWNlKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmV4cG9ydHMudHlwZXMgPSByZXF1aXJlKCcuL3N1cHBvcnQvdHlwZXMnKTtcblxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbmV4cG9ydHMudHlwZXMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5leHBvcnRzLnR5cGVzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuZXhwb3J0cy50eXBlcy5pc05hdGl2ZUVycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxudmFyIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sKCd1dGlsLnByb21pc2lmeS5jdXN0b20nKSA6IHVuZGVmaW5lZDtcblxuZXhwb3J0cy5wcm9taXNpZnkgPSBmdW5jdGlvbiBwcm9taXNpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgJiYgb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXSkge1xuICAgIHZhciBmbiA9IG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF07XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZuKCkge1xuICAgIHZhciBwcm9taXNlUmVzb2x2ZSwgcHJvbWlzZVJlamVjdDtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHByb21pc2VSZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VSZXNvbHZlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihmbiwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgIGZuLFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpXG4gICk7XG59XG5cbmV4cG9ydHMucHJvbWlzaWZ5LmN1c3RvbSA9IGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbFxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocmVhc29uLCBjYikge1xuICAvLyBgIXJlYXNvbmAgZ3VhcmQgaW5zcGlyZWQgYnkgYmx1ZWJpcmQgKFJlZjogaHR0cHM6Ly9nb28uZ2wvdDVJUzZNKS5cbiAgLy8gQmVjYXVzZSBgbnVsbGAgaXMgYSBzcGVjaWFsIGVycm9yIHZhbHVlIGluIGNhbGxiYWNrcyB3aGljaCBtZWFucyBcIm5vIGVycm9yXG4gIC8vIG9jY3VycmVkXCIsIHdlIGVycm9yLXdyYXAgc28gdGhlIGNhbGxiYWNrIGNvbnN1bWVyIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gIC8vIFwidGhlIHByb21pc2UgcmVqZWN0ZWQgd2l0aCBudWxsXCIgb3IgXCJ0aGUgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB1bmRlZmluZWRcIi5cbiAgaWYgKCFyZWFzb24pIHtcbiAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKCdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWUnKTtcbiAgICBuZXdSZWFzb24ucmVhc29uID0gcmVhc29uO1xuICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgfVxuICByZXR1cm4gY2IocmVhc29uKTtcbn1cblxuZnVuY3Rpb24gY2FsbGJhY2tpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gIH1cblxuICAvLyBXZSBETyBOT1QgcmV0dXJuIHRoZSBwcm9taXNlIGFzIGl0IGdpdmVzIHRoZSB1c2VyIGEgZmFsc2Ugc2Vuc2UgdGhhdFxuICAvLyB0aGUgcHJvbWlzZSBpcyBhY3R1YWxseSBzb21laG93IHJlbGF0ZWQgdG8gdGhlIGNhbGxiYWNrJ3MgZXhlY3V0aW9uXG4gIC8vIGFuZCB0aGF0IHRoZSBjYWxsYmFjayB0aHJvd2luZyB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgZnVuY3Rpb24gY2FsbGJhY2tpZmllZCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVDYiA9IGFyZ3MucG9wKCk7XG4gICAgaWYgKHR5cGVvZiBtYXliZUNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGFzdCBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG1heWJlQ2IuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8vIEluIHRydWUgbm9kZSBzdHlsZSB3ZSBwcm9jZXNzIHRoZSBjYWxsYmFjayBvbiBgbmV4dFRpY2tgIHdpdGggYWxsIHRoZVxuICAgIC8vIGltcGxpY2F0aW9ucyAoc3RhY2ssIGB1bmNhdWdodEV4Y2VwdGlvbmAsIGBhc3luY19ob29rc2ApXG4gICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJldCkgeyBwcm9jZXNzLm5leHRUaWNrKGNiLmJpbmQobnVsbCwgbnVsbCwgcmV0KSkgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlaikgeyBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNraWZ5T25SZWplY3RlZC5iaW5kKG51bGwsIHJlaiwgY2IpKSB9KTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihjYWxsYmFja2lmaWVkLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FsbGJhY2tpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbCkpO1xuICByZXR1cm4gY2FsbGJhY2tpZmllZDtcbn1cbmV4cG9ydHMuY2FsbGJhY2tpZnkgPSBjYWxsYmFja2lmeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSByZXF1aXJlKCdmb3ItZWFjaCcpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gcmVxdWlyZSgnYXZhaWxhYmxlLXR5cGVkLWFycmF5cycpO1xudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1ib3VuZCcpO1xudmFyIGdPUEQgPSByZXF1aXJlKCdnb3BkJyk7XG52YXIgZ2V0UHJvdG8gPSByZXF1aXJlKCdnZXQtcHJvdG8nKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xudmFyIHR5cGVkQXJyYXlzID0gYXZhaWxhYmxlVHlwZWRBcnJheXMoKTtcblxudmFyICRzbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpO1xuXG4vKiogQHR5cGUgezxUID0gdW5rbm93bj4oYXJyYXk6IHJlYWRvbmx5IFRbXSwgdmFsdWU6IHVua25vd24pID0+IG51bWJlcn0gKi9cbnZhciAkaW5kZXhPZiA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLmluZGV4T2YnLCB0cnVlKSB8fCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn07XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzJykuR2V0dGVyfSBHZXR0ZXIgKi9cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGVzJykuQ2FjaGV9ICovXG52YXIgY2FjaGUgPSB7IF9fcHJvdG9fXzogbnVsbCB9O1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG8pIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHR2YXIgYXJyID0gbmV3IGdbdHlwZWRBcnJheV0oKTtcblx0XHRpZiAoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGFyciAmJiBnZXRQcm90bykge1xuXHRcdFx0dmFyIHByb3RvID0gZ2V0UHJvdG8oYXJyKTtcblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgd29uJ3QgbmFycm93IGluc2lkZSBhIGNsb3N1cmVcblx0XHRcdHZhciBkZXNjcmlwdG9yID0gZ09QRChwcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdGlmICghZGVzY3JpcHRvciAmJiBwcm90bykge1xuXHRcdFx0XHR2YXIgc3VwZXJQcm90byA9IGdldFByb3RvKHByb3RvKTtcblx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBUUyB3b24ndCBuYXJyb3cgaW5zaWRlIGEgY2xvc3VyZVxuXHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5nZXQpIHtcblx0XHRcdFx0dmFyIGJvdW5kID0gY2FsbEJpbmQoZGVzY3JpcHRvci5nZXQpO1xuXHRcdFx0XHRjYWNoZVtcblx0XHRcdFx0XHQvKiogQHR5cGUge2AkJHtpbXBvcnQoJy4nKS5UeXBlZEFycmF5TmFtZX1gfSAqLyAoJyQnICsgdHlwZWRBcnJheSlcblx0XHRcdFx0XSA9IGJvdW5kO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59IGVsc2Uge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdHZhciBmbiA9IGFyci5zbGljZSB8fCBhcnIuc2V0O1xuXHRcdGlmIChmbikge1xuXHRcdFx0dmFyIGJvdW5kID0gLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZXMnKS5Cb3VuZFNsaWNlIHwgaW1wb3J0KCcuL3R5cGVzJykuQm91bmRTZXR9ICovIChcblx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBUT0RPIEZJWE1FXG5cdFx0XHRcdGNhbGxCaW5kKGZuKVxuXHRcdFx0KTtcblx0XHRcdGNhY2hlW1xuXHRcdFx0XHQvKiogQHR5cGUge2AkJHtpbXBvcnQoJy4nKS5UeXBlZEFycmF5TmFtZX1gfSAqLyAoJyQnICsgdHlwZWRBcnJheSlcblx0XHRcdF0gPSBib3VuZDtcblx0XHR9XG5cdH0pO1xufVxuXG4vKiogQHR5cGUgeyh2YWx1ZTogb2JqZWN0KSA9PiBmYWxzZSB8IGltcG9ydCgnLicpLlR5cGVkQXJyYXlOYW1lfSAqL1xudmFyIHRyeVR5cGVkQXJyYXlzID0gZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXModmFsdWUpIHtcblx0LyoqIEB0eXBlIHtSZXR1cm5UeXBlPHR5cGVvZiB0cnlBbGxUeXBlZEFycmF5cz59ICovIHZhciBmb3VuZCA9IGZhbHNlO1xuXHRmb3JFYWNoKFxuXHRcdC8qKiBAdHlwZSB7UmVjb3JkPGBcXCQke2ltcG9ydCgnLicpLlR5cGVkQXJyYXlOYW1lfWAsIEdldHRlcj59ICovIChjYWNoZSksXG5cdFx0LyoqIEB0eXBlIHsoZ2V0dGVyOiBHZXR0ZXIsIG5hbWU6IGBcXCQke2ltcG9ydCgnLicpLlR5cGVkQXJyYXlOYW1lfWApID0+IHZvaWR9ICovXG5cdFx0ZnVuY3Rpb24gKGdldHRlciwgdHlwZWRBcnJheSkge1xuXHRcdFx0aWYgKCFmb3VuZCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgYSB0aHJvdyBpcyBmaW5lIGhlcmVcblx0XHRcdFx0XHRpZiAoJyQnICsgZ2V0dGVyKHZhbHVlKSA9PT0gdHlwZWRBcnJheSkge1xuXHRcdFx0XHRcdFx0Zm91bmQgPSAvKiogQHR5cGUge2ltcG9ydCgnLicpLlR5cGVkQXJyYXlOYW1lfSAqLyAoJHNsaWNlKHR5cGVkQXJyYXksIDEpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xuXHRyZXR1cm4gZm91bmQ7XG59O1xuXG4vKiogQHR5cGUgeyh2YWx1ZTogb2JqZWN0KSA9PiBmYWxzZSB8IGltcG9ydCgnLicpLlR5cGVkQXJyYXlOYW1lfSAqL1xudmFyIHRyeVNsaWNlcyA9IGZ1bmN0aW9uIHRyeUFsbFNsaWNlcyh2YWx1ZSkge1xuXHQvKiogQHR5cGUge1JldHVyblR5cGU8dHlwZW9mIHRyeUFsbFNsaWNlcz59ICovIHZhciBmb3VuZCA9IGZhbHNlO1xuXHRmb3JFYWNoKFxuXHRcdC8qKiBAdHlwZSB7UmVjb3JkPGBcXCQke2ltcG9ydCgnLicpLlR5cGVkQXJyYXlOYW1lfWAsIEdldHRlcj59ICovKGNhY2hlKSxcblx0XHQvKiogQHR5cGUgeyhnZXR0ZXI6IEdldHRlciwgbmFtZTogYFxcJCR7aW1wb3J0KCcuJykuVHlwZWRBcnJheU5hbWV9YCkgPT4gdm9pZH0gKi8gZnVuY3Rpb24gKGdldHRlciwgbmFtZSkge1xuXHRcdFx0aWYgKCFmb3VuZCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgYSB0aHJvdyBpcyBmaW5lIGhlcmVcblx0XHRcdFx0XHRnZXR0ZXIodmFsdWUpO1xuXHRcdFx0XHRcdGZvdW5kID0gLyoqIEB0eXBlIHtpbXBvcnQoJy4nKS5UeXBlZEFycmF5TmFtZX0gKi8gKCRzbGljZShuYW1lLCAxKSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xuXHRyZXR1cm4gZm91bmQ7XG59O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aGljaFR5cGVkQXJyYXkodmFsdWUpIHtcblx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG5cdFx0LyoqIEB0eXBlIHtzdHJpbmd9ICovXG5cdFx0dmFyIHRhZyA9ICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7XG5cdFx0aWYgKCRpbmRleE9mKHR5cGVkQXJyYXlzLCB0YWcpID4gLTEpIHtcblx0XHRcdHJldHVybiB0YWc7XG5cdFx0fVxuXHRcdGlmICh0YWcgIT09ICdPYmplY3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdC8vIG5vZGUgPCAwLjYgaGl0cyBoZXJlIG9uIHJlYWwgVHlwZWQgQXJyYXlzXG5cdFx0cmV0dXJuIHRyeVNsaWNlcyh2YWx1ZSk7XG5cdH1cblx0aWYgKCFnT1BEKSB7IHJldHVybiBudWxsOyB9IC8vIHVua25vd24gZW5naW5lXG5cdHJldHVybiB0cnlUeXBlZEFycmF5cyh2YWx1ZSk7XG59O1xuIiwiZXhwb3J0IGVudW0gUHJvdG9jb2wge1xuXHQvLyBSb29tLXJlbGF0ZWQgKDEwfjE5KVxuXHRIQU5EU0hBS0UgPSA5LFxuXHRKT0lOX1JPT00gPSAxMCxcblx0RVJST1IgPSAxMSxcblx0TEVBVkVfUk9PTSA9IDEyLFxuXHRST09NX0RBVEEgPSAxMyxcblx0Uk9PTV9TVEFURSA9IDE0LFxuXHRST09NX1NUQVRFX1BBVENIID0gMTUsXG5cdFJPT01fREFUQV9TQ0hFTUEgPSAxNixcblx0Uk9PTV9EQVRBX0JZVEVTID0gMTcsXG59XG5cbmV4cG9ydCBlbnVtIEN1c3RvbU1lc3NhZ2VUeXBlIHtcbiAgICBQb3NpdGlvblVwZGF0ZSA9IDQzLFxuICAgIENoYXQgPSA2MixcbiAgICBVc2VyRGF0YUNoYW5nZWQgPSAzOCxcbiAgICBQaW5nID0gMzAsXG4gICAgUG9uZyA9IDMxLFxuICAgIFNjZW5lTG9hZGVkID0gNjYsXG4gICAgTG9nSW5mbyA9IDM2LFxuICAgIExvZ0Vycm9yID0gNzksXG4gICAgTG9nU3VjY2VzcyA9IDQ2LFxuICAgIExvZ1dhcm5pbmcgPSA4MixcbiAgICBDcm91Y2ggPSA3NSxcbiAgICBQbGFudFNlZWQgPSA1OSxcbiAgICBDb2xsZWN0UGxhbnQgPSA1NixcbiAgICBXYXRlclBsYW50ID0gMzUsXG4gICAgQnV5SXRlbSA9IDg3LFxuICAgIFNlbGxJdGVtID0gNDgsXG4gICAgVXNlSXRlbSA9IDczLFxuICAgIEV4cGFuZEdhcmRlbiA9IDY1LFxuICAgIFJlcXVlc3RIb2xkSXRlbSA9IDg2LFxuICAgIExpa2VHYXJkZW4gPSA2MyxcbiAgICBCdXlFZ2cgPSA0NyxcbiAgICBCdXlUb29sID0gMzMsXG4gICAgUGxhY2VFZ2cgPSA1NCxcbiAgICBPcGVuRWdnID0gNzcsXG4gICAgUmVtb3ZlVHJlZSA9IDM0LFxuICAgIFN3YXBJbnZlbnRvcnlTbG90cyA9IDg5LFxuICAgIFBsYWNlUGV0ID0gODMsXG4gICAgUmVtb3ZlUGV0ID0gNjAsXG4gICAgR3Jvd0FsbCA9IDc4LFxuICAgIFNwaW5XaGVlbCA9IDM5LFxuICAgIEdldFdvcnRoID0gODQsXG4gICAgU2VuZEdpZnQgPSA5MCxcbiAgICBSZXNwb25kVG9HaWZ0ID0gNzIsXG4gICAgUGxhY2VTcHJpbmtsZXIgPSA2MSxcbiAgICBNb3ZlVHJlZSA9IDQ1XG59XG5cblxuIiwiaW1wb3J0IHsgU2NoZW1hLCB0eXBlLCBBcnJheVNjaGVtYSwgTWFwU2NoZW1hIH0gZnJvbSBcIkBjb2x5c2V1cy9zY2hlbWFcIjtcblxuLy8gcmVtZW1iZXIgdG8gdXBkYXRlIGFsb25nc2lkZSB0aGUgZ2FtZVxuXG5jbGFzcyBDb2x5VmVjdG9yMyBleHRlbmRzIFNjaGVtYSB7XG5cdEB0eXBlKFwibnVtYmVyXCIpIHg6IG51bWJlcjtcblx0QHR5cGUoXCJudW1iZXJcIikgeTogbnVtYmVyO1xuXHRAdHlwZShcIm51bWJlclwiKSB6OiBudW1iZXI7XG59XG5cbmNsYXNzIENvbHlSaWdpZCBleHRlbmRzIFNjaGVtYSB7XG5cdEB0eXBlKENvbHlWZWN0b3IzKSBwb3NpdGlvbjogQ29seVZlY3RvcjM7XG5cdEB0eXBlKFwibnVtYmVyXCIpIHJvdGF0aW9uWTogbnVtYmVyO1xuXHRAdHlwZShcImJvb2xlYW5cIikgYWlyOiBib29sZWFuO1xufVxuXG5leHBvcnQgY2xhc3MgSW52ZW50b3J5SXRlbSBleHRlbmRzIFNjaGVtYSB7XG4gICAgQHR5cGUoXCJpbnQ4XCIpIGlkOiBudW1iZXI7XG4gICAgQHR5cGUoXCJzdHJpbmdcIikgdHlwZTogc3RyaW5nO1xuICAgIEB0eXBlKFwibnVtYmVyXCIpIGFtb3VudDogbnVtYmVyO1xuICAgIEB0eXBlKFwibnVtYmVyXCIpIGN1c3RvbVBhcmFtOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBQdWJsaWNVc2VyRGF0YSBleHRlbmRzIFNjaGVtYSB7XG5cdEB0eXBlKFwic3RyaW5nXCIpIGNyZWF0ZWRBdDogc3RyaW5nO1xuXHRAdHlwZShcInN0cmluZ1wiKSBwZnA6IHN0cmluZztcblx0QHR5cGUoXCJzdHJpbmdcIikgdXNlcm5hbWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIFBsYXllciBleHRlbmRzIFNjaGVtYSB7XG4gICAgQHR5cGUoXCJzdHJpbmdcIikgcGxheWVySWQ6IHN0cmluZztcbiAgICBAdHlwZShcInN0cmluZ1wiKSBuaWNrbmFtZTogc3RyaW5nO1xuICAgIEB0eXBlKFwic3RyaW5nXCIpIHVzZXJJZDogc3RyaW5nO1xuICAgIEB0eXBlKFwidWludDY0XCIpIGNvaW5zOiBudW1iZXI7XG4gICAgQHR5cGUoXCJ1aW50MzJcIikgc2NvcmU6IG51bWJlcjtcbiAgICBAdHlwZSh7IG1hcDogSW52ZW50b3J5SXRlbSB9KSBpbnZlbnRvcnkgPSBuZXcgTWFwU2NoZW1hPEludmVudG9yeUl0ZW0+KCk7XG4gICAgQHR5cGUoXCJ1aW50OFwiKSBiYWNrcGFja1NpemU6IG51bWJlcjtcbiAgICBAdHlwZShcImludDMyXCIpIGN1cnJlbnRIb2xkaW5nSXRlbTogbnVtYmVyO1xuICAgIEB0eXBlKHsgbWFwOiBcInVpbnQzMlwiIH0pIHN0b2NrID0gbmV3IE1hcFNjaGVtYTxudW1iZXI+KCk7XG4gICAgQHR5cGUoW1widWludDMyXCJdKSBmcmVlU2VlZFN0b2NrID0gbmV3IEFycmF5U2NoZW1hPG51bWJlcj4oKTtcbiAgICBAdHlwZShcIm51bWJlclwiKSBnZW1zOiBudW1iZXI7XG4gICAgQHR5cGUoXCJpbnQxNlwiKSBza2luOiBudW1iZXI7XG4gICAgQHR5cGUoXCJpbnQxNlwiKSBoYXQ6IG51bWJlcjtcbiAgICBAdHlwZShcImludDE2XCIpIGJhY2s6IG51bWJlcjtcbiAgICBAdHlwZShDb2x5UmlnaWQpIHJpZ2lkOiBDb2x5UmlnaWQ7XG4gICAgQHR5cGUoXCJib29sZWFuXCIpIHNjZW5lTG9hZGVkOiBib29sZWFuO1xuICAgIEB0eXBlKFwiYm9vbGVhblwiKSBjcm91Y2hpbmc6IGJvb2xlYW47XG4gICAgQHR5cGUoXCJzdHJpbmdcIikgcGFydHk6IHN0cmluZztcbiAgICBAdHlwZShQdWJsaWNVc2VyRGF0YSkgdXNlcjogUHVibGljVXNlckRhdGE7XG4gICAgQHR5cGUoXCJudW1iZXJcIikgc3RhcnRQbGF5VGltZTogbnVtYmVyO1xuICAgIEB0eXBlKHsgbWFwOiBcInVpbnQ4XCIgfSkgZWdnU3RvY2sgPSBuZXcgTWFwU2NoZW1hPG51bWJlcj4oKTtcbiAgICBAdHlwZSh7IG1hcDogXCJ1aW50MzJcIiB9KSB0b29sU3RvY2sgPSBuZXcgTWFwU2NoZW1hPG51bWJlcj4oKTtcbiAgICBAdHlwZShcIm51bWJlclwiKSBuZXh0U3BpbkF2YWlsYWJsZTogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgRWdnIGV4dGVuZHMgU2NoZW1hIHtcblx0QHR5cGUoXCJ1aW50MzJcIikgZWdnSWQ6IG51bWJlclxuXHRAdHlwZShcImludDhcIikgaWQ6IG51bWJlclxuXHRAdHlwZShcIm51bWJlclwiKSBwbGFjZWRBdDogbnVtYmVyXG5cdEB0eXBlKFwibnVtYmVyXCIpIHg6IG51bWJlclxuXHRAdHlwZShcIm51bWJlclwiKSB5OiBudW1iZXJcbn1cblxuZXhwb3J0IGNsYXNzIFBldCBleHRlbmRzIFNjaGVtYSB7XG5cdEB0eXBlKFwibnVtYmVyXCIpIGNyZWF0ZWRBdDogbnVtYmVyXG5cdEB0eXBlKFwiaW50OFwiKSBpZDogbnVtYmVyXG5cdEB0eXBlKFwibnVtYmVyXCIpIGxhc3RDb2xsZWN0QXR0ZW1wdDogbnVtYmVyXG5cdEB0eXBlKFwidWludDMyXCIpIHBldElkOiBudW1iZXJcblx0QHR5cGUoXCJudW1iZXJcIikgeDogbnVtYmVyXG5cdEB0eXBlKFwibnVtYmVyXCIpIHk6IG51bWJlclxufVxuXG5leHBvcnQgY2xhc3MgUGxhbnQgZXh0ZW5kcyBTY2hlbWEge1xuICAgIEB0eXBlKFwidWludDMyXCIpIHBsYW50SWQ6IG51bWJlcjtcbiAgICBAdHlwZShcImludDhcIikgc2VlZElkOiBudW1iZXI7XG4gICAgQHR5cGUoXCJudW1iZXJcIikgeDogbnVtYmVyO1xuICAgIEB0eXBlKFwibnVtYmVyXCIpIHk6IG51bWJlcjtcbiAgICBAdHlwZShcIm51bWJlclwiKSBwbGFudGVkQXQ6IG51bWJlcjtcbiAgICBAdHlwZShcInVpbnQxNlwiKSBtdXRhdGlvbjogbnVtYmVyO1xuICAgIEB0eXBlKFwidWludDhcIikgcm90OiBudW1iZXI7XG4gICAgQHR5cGUoXCJudW1iZXJcIikgd2VpZ2h0OiBudW1iZXI7XG4gICAgQHR5cGUoXCJib29sZWFuXCIpIGlzRnJ1aXRUcmVlOiBib29sZWFuO1xuICAgIEB0eXBlKFwiYm9vbGVhblwiKSB0cmVlR3Jvd246IGJvb2xlYW47XG4gICAgQHR5cGUoXCJudW1iZXJcIikgbGFzdEZydWl0U3Bhd246IG51bWJlcjtcbiAgICBAdHlwZSh7IG1hcDogUGxhbnQgfSkgZnJ1aXRzID0gbmV3IE1hcFNjaGVtYTxQbGFudD4oKTtcbn1cblxuZXhwb3J0IGNsYXNzIFNwcmlua2xlciBleHRlbmRzIFNjaGVtYSB7XG4gICAgQHR5cGUoXCJ1aW50MzJcIikgc3ByaW5rbGVySWQ6IG51bWJlcjtcbiAgICBAdHlwZShcImludDE2XCIpIHR5cGVJZDogbnVtYmVyO1xuICAgIEB0eXBlKFwibnVtYmVyXCIpIHg6IG51bWJlcjtcbiAgICBAdHlwZShcIm51bWJlclwiKSB5OiBudW1iZXI7XG4gICAgQHR5cGUoXCJudW1iZXJcIikgcGxhY2VkQXQ6IG51bWJlcjtcbiAgICBAdHlwZShcImludDhcIikgcmFkaXVzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBHYXJkZW4gZXh0ZW5kcyBTY2hlbWEge1xuICAgIEB0eXBlKFwic3RyaW5nXCIpIG93bmVySWQ6IHN0cmluZztcbiAgICBAdHlwZShcImludDhcIikgd2lkdGg6IG51bWJlcjtcbiAgICBAdHlwZShcImludDhcIikgaGVpZ2h0OiBudW1iZXI7XG4gICAgQHR5cGUoXCJpbnQzMlwiKSBsaWtlczogbnVtYmVyO1xuICAgIEB0eXBlKFtQbGFudF0pIHBsYW50cyA9IG5ldyBBcnJheVNjaGVtYTxQbGFudD4oKTtcbiAgICBAdHlwZShbUGV0XSkgcGV0cyA9IG5ldyBBcnJheVNjaGVtYTxQZXQ+KCk7XG4gICAgQHR5cGUoW0VnZ10pIGVnZ3MgPSBuZXcgQXJyYXlTY2hlbWE8RWdnPigpO1xuICAgIEB0eXBlKFtTcHJpbmtsZXJdKSBzcHJpbmtsZXJzID0gbmV3IEFycmF5U2NoZW1hPFNwcmlua2xlcj4oKTtcbiAgICBAdHlwZShcIm51bWJlclwiKSBsYXN0V2F0ZXJlZDogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgTXlSb29tU3RhdGUgZXh0ZW5kcyBTY2hlbWEge1xuICAgIEB0eXBlKHsgbWFwOiBQbGF5ZXIgfSkgcGxheWVycyA9IG5ldyBNYXBTY2hlbWE8UGxheWVyPigpO1xuICAgIEB0eXBlKHsgbWFwOiBHYXJkZW4gfSkgZ2FyZGVucyA9IG5ldyBNYXBTY2hlbWE8R2FyZGVuPigpO1xuICAgIEB0eXBlKFwiaW50OFwiKSByZWdpb246IG51bWJlcjtcbiAgICBAdHlwZShcImludDhcIikgbWF4UGxheWVyczogbnVtYmVyO1xuICAgIEB0eXBlKFwiYm9vbGVhblwiKSBhYm91dFRvU2h1dGRvd246IGJvb2xlYW47XG4gICAgQHR5cGUoXCJpbnQ4XCIpIHdlYXRoZXI6IG51bWJlcjtcbiAgICBAdHlwZShbXCJ1aW50MTZcIl0pIHNlZWRzSW5TdG9jayA9IG5ldyBBcnJheVNjaGVtYTxudW1iZXI+KCk7XG4gICAgQHR5cGUoW1widWludDE2XCJdKSB0b29sc0luU3RvY2sgPSBuZXcgQXJyYXlTY2hlbWE8bnVtYmVyPigpO1xuICAgIEB0eXBlKFwiaW50OFwiKSBjdXJyZW50RXZlbnQ6IG51bWJlcjtcbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciBwb3NzaWJsZU5hbWVzID0gcmVxdWlyZSgncG9zc2libGUtdHlwZWQtYXJyYXktbmFtZXMnKTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdmFpbGFibGVUeXBlZEFycmF5cygpIHtcblx0dmFyIC8qKiBAdHlwZSB7UmV0dXJuVHlwZTx0eXBlb2YgYXZhaWxhYmxlVHlwZWRBcnJheXM+fSAqLyBvdXQgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwb3NzaWJsZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKHR5cGVvZiBnW3Bvc3NpYmxlTmFtZXNbaV1dID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRvdXRbb3V0Lmxlbmd0aF0gPSBwb3NzaWJsZU5hbWVzW2ldO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0O1xufTtcbiIsImV4cG9ydCB7IFBhY2tyLCBFbmNvZGVyLCBhZGRFeHRlbnNpb24sIHBhY2ssIGVuY29kZSwgTkVWRVIsIEFMV0FZUywgREVDSU1BTF9ST1VORCwgREVDSU1BTF9GSVQsIFJFVVNFX0JVRkZFUl9NT0RFLCBSRVNFVF9CVUZGRVJfTU9ERSwgUkVTRVJWRV9TVEFSVF9TUEFDRSB9IGZyb20gJy4vcGFjay5qcydcbmV4cG9ydCB7IFVucGFja3IsIERlY29kZXIsIEMxLCB1bnBhY2ssIHVucGFja011bHRpcGxlLCBkZWNvZGUsIEZMT0FUMzJfT1BUSU9OUywgY2xlYXJTb3VyY2UsIHJvdW5kRmxvYXQzMiwgaXNOYXRpdmVBY2NlbGVyYXRpb25FbmFibGVkIH0gZnJvbSAnLi91bnBhY2suanMnXG5leHBvcnQgeyBkZWNvZGVJdGVyLCBlbmNvZGVJdGVyIH0gZnJvbSAnLi9pdGVyYXRvcnMuanMnXG5leHBvcnQgY29uc3QgdXNlUmVjb3JkcyA9IGZhbHNlXG5leHBvcnQgY29uc3QgbWFwc0FzT2JqZWN0cyA9IHRydWVcbiIsImltcG9ydCB7IFBhY2tyIH0gZnJvbSAnLi9wYWNrLmpzJ1xuaW1wb3J0IHsgVW5wYWNrciB9IGZyb20gJy4vdW5wYWNrLmpzJ1xuXG4vKipcbiAqIEdpdmVuIGFuIEl0ZXJhYmxlIGZpcnN0IGFyZ3VtZW50LCByZXR1cm5zIGFuIEl0ZXJhYmxlIHdoZXJlIGVhY2ggdmFsdWUgaXMgcGFja2VkIGFzIGEgQnVmZmVyXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgb25seSBBc3luYyBJdGVyYWJsZSwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIGFuIEFzeW5jIEl0ZXJhYmxlLlxuICogQHBhcmFtIHtJdGVyYWJsZXxJdGVyYXRvcnxBc3luY0l0ZXJhYmxlfEFzeW5jSXRlcmF0b3J9IG9iamVjdEl0ZXJhdG9yIC0gaXRlcmFibGUgc291cmNlLCBsaWtlIGEgUmVhZGFibGUgb2JqZWN0IHN0cmVhbSwgYW4gYXJyYXksIFNldCwgb3IgY3VzdG9tIG9iamVjdFxuICogQHBhcmFtIHtvcHRpb25zfSBbb3B0aW9uc10gLSBtc2dwYWNrciBwYWNrIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yfFByb21pc2UuPEFzeW5jSXRlcmFibGVJdGVyYXRvcj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWNrSXRlciAob2JqZWN0SXRlcmF0b3IsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoIW9iamVjdEl0ZXJhdG9yIHx8IHR5cGVvZiBvYmplY3RJdGVyYXRvciAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gSXRlcmFibGUsIEFzeW5jIEl0ZXJhYmxlLCBvciBhIFByb21pc2UgZm9yIGFuIEFzeW5jIEl0ZXJhYmxlJylcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0SXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwYWNrSXRlclN5bmMob2JqZWN0SXRlcmF0b3IsIG9wdGlvbnMpXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdEl0ZXJhdG9yLnRoZW4gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9iamVjdEl0ZXJhdG9yW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwYWNrSXRlckFzeW5jKG9iamVjdEl0ZXJhdG9yLCBvcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBJdGVyYWJsZSwgQXN5bmMgSXRlcmFibGUsIEl0ZXJhdG9yLCBBc3luYyBJdGVyYXRvciwgb3IgYSBQcm9taXNlJylcbiAgfVxufVxuXG5mdW5jdGlvbiAqIHBhY2tJdGVyU3luYyAob2JqZWN0SXRlcmF0b3IsIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFja3IgPSBuZXcgUGFja3Iob3B0aW9ucylcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiBvYmplY3RJdGVyYXRvcikge1xuICAgIHlpZWxkIHBhY2tyLnBhY2sodmFsdWUpXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gKiBwYWNrSXRlckFzeW5jIChvYmplY3RJdGVyYXRvciwgb3B0aW9ucykge1xuICBjb25zdCBwYWNrciA9IG5ldyBQYWNrcihvcHRpb25zKVxuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIG9iamVjdEl0ZXJhdG9yKSB7XG4gICAgeWllbGQgcGFja3IucGFjayh2YWx1ZSlcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIEl0ZXJhYmxlL0l0ZXJhdG9yIGlucHV0IHdoaWNoIHlpZWxkcyBidWZmZXJzLCByZXR1cm5zIGFuIEl0ZXJhYmxlSXRlcmF0b3Igd2hpY2ggeWllbGRzIHN5bmMgZGVjb2RlZCBvYmplY3RzXG4gKiBPciwgZ2l2ZW4gYW4gQXN5bmMgSXRlcmFibGUvSXRlcmF0b3Igd2hpY2ggeWllbGRzIHByb21pc2VzIHJlc29sdmluZyBpbiBidWZmZXJzLCByZXR1cm5zIGFuIEFzeW5jSXRlcmFibGVJdGVyYXRvci5cbiAqIEBwYXJhbSB7SXRlcmFibGV8SXRlcmF0b3J8QXN5bmNJdGVyYWJsZXxBc3luY0l0ZXJhYmxlSXRlcmF0b3J9IGJ1ZmZlckl0ZXJhdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gdW5wYWNrciBvcHRpb25zXG4gKiBAcmV0dXJucyB7SXRlcmFibGVJdGVyYXRvcnxQcm9taXNlLjxBc3luY0l0ZXJhYmxlSXRlcmF0b3J9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnBhY2tJdGVyIChidWZmZXJJdGVyYXRvciwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICghYnVmZmVySXRlcmF0b3IgfHwgdHlwZW9mIGJ1ZmZlckl0ZXJhdG9yICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBJdGVyYWJsZSwgQXN5bmMgSXRlcmFibGUsIEl0ZXJhdG9yLCBBc3luYyBJdGVyYXRvciwgb3IgYSBwcm9taXNlJylcbiAgfVxuXG4gIGNvbnN0IHVucGFja3IgPSBuZXcgVW5wYWNrcihvcHRpb25zKVxuICBsZXQgaW5jb21wbGV0ZVxuICBjb25zdCBwYXJzZXIgPSAoY2h1bmspID0+IHtcbiAgICBsZXQgeWllbGRzXG4gICAgLy8gaWYgdGhlcmUncyBpbmNvbXBsZXRlIGRhdGEgZnJvbSBwcmV2aW91cyBjaHVuaywgY29uY2F0aW5hdGUgYW5kIHRyeSBhZ2FpblxuICAgIGlmIChpbmNvbXBsZXRlKSB7XG4gICAgICBjaHVuayA9IEJ1ZmZlci5jb25jYXQoW2luY29tcGxldGUsIGNodW5rXSlcbiAgICAgIGluY29tcGxldGUgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgeWllbGRzID0gdW5wYWNrci51bnBhY2tNdWx0aXBsZShjaHVuaylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIuaW5jb21wbGV0ZSkge1xuICAgICAgICBpbmNvbXBsZXRlID0gY2h1bmsuc2xpY2UoZXJyLmxhc3RQb3NpdGlvbilcbiAgICAgICAgeWllbGRzID0gZXJyLnZhbHVlc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB5aWVsZHNcbiAgfVxuXG4gIGlmICh0eXBlb2YgYnVmZmVySXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiAoZnVuY3Rpb24gKiBpdGVyICgpIHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYnVmZmVySXRlcmF0b3IpIHtcbiAgICAgICAgeWllbGQgKiBwYXJzZXIodmFsdWUpXG4gICAgICB9XG4gICAgfSkoKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBidWZmZXJJdGVyYXRvcltTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gKGFzeW5jIGZ1bmN0aW9uICogaXRlciAoKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGJ1ZmZlckl0ZXJhdG9yKSB7XG4gICAgICAgIHlpZWxkICogcGFyc2VyKHZhbHVlKVxuICAgICAgfVxuICAgIH0pKClcbiAgfVxufVxuZXhwb3J0IGNvbnN0IGRlY29kZUl0ZXIgPSB1bnBhY2tJdGVyXG5leHBvcnQgY29uc3QgZW5jb2RlSXRlciA9IHBhY2tJdGVyIiwiaW1wb3J0IHsgVW5wYWNrciwgbXVsdDEwLCBDMVR5cGUsIHR5cGVkQXJyYXlzLCBhZGRFeHRlbnNpb24gYXMgdW5wYWNrQWRkRXh0ZW5zaW9uIH0gZnJvbSAnLi91bnBhY2suanMnXG5sZXQgdGV4dEVuY29kZXJcbnRyeSB7XG5cdHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcbn0gY2F0Y2ggKGVycm9yKSB7fVxubGV0IGV4dGVuc2lvbnMsIGV4dGVuc2lvbkNsYXNzZXNcbmNvbnN0IGhhc05vZGVCdWZmZXIgPSB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJ1xuY29uc3QgQnl0ZUFycmF5QWxsb2NhdGUgPSBoYXNOb2RlQnVmZmVyID9cblx0ZnVuY3Rpb24obGVuZ3RoKSB7IHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KGxlbmd0aCkgfSA6IFVpbnQ4QXJyYXlcbmNvbnN0IEJ5dGVBcnJheSA9IGhhc05vZGVCdWZmZXIgPyBCdWZmZXIgOiBVaW50OEFycmF5XG5jb25zdCBNQVhfQlVGRkVSX1NJWkUgPSBoYXNOb2RlQnVmZmVyID8gMHgxMDAwMDAwMDAgOiAweDdmZDAwMDAwXG5sZXQgdGFyZ2V0LCBrZXlzVGFyZ2V0XG5sZXQgdGFyZ2V0Vmlld1xubGV0IHBvc2l0aW9uID0gMFxubGV0IHNhZmVFbmRcbmxldCBidW5kbGVkU3RyaW5ncyA9IG51bGxcbmxldCB3cml0ZVN0cnVjdFNsb3RzXG5jb25zdCBNQVhfQlVORExFX1NJWkUgPSAweDU1MDAgLy8gbWF4aW11bSBjaGFyYWN0ZXJzIHN1Y2ggdGhhdCB0aGUgZW5jb2RlZCBieXRlcyBmaXRzIGluIDE2IGJpdHMuXG5jb25zdCBoYXNOb25MYXRpbiA9IC9bXFx1MDA4MC1cXHVGRkZGXS9cbmV4cG9ydCBjb25zdCBSRUNPUkRfU1lNQk9MID0gU3ltYm9sKCdyZWNvcmQtaWQnKVxuZXhwb3J0IGNsYXNzIFBhY2tyIGV4dGVuZHMgVW5wYWNrciB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRzdXBlcihvcHRpb25zKVxuXHRcdHRoaXMub2Zmc2V0ID0gMFxuXHRcdGxldCB0eXBlQnVmZmVyXG5cdFx0bGV0IHN0YXJ0XG5cdFx0bGV0IGhhc1NoYXJlZFVwZGF0ZVxuXHRcdGxldCBzdHJ1Y3R1cmVzXG5cdFx0bGV0IHJlZmVyZW5jZU1hcFxuXHRcdGxldCBlbmNvZGVVdGY4ID0gQnl0ZUFycmF5LnByb3RvdHlwZS51dGY4V3JpdGUgPyBmdW5jdGlvbihzdHJpbmcsIHBvc2l0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0LnV0ZjhXcml0ZShzdHJpbmcsIHBvc2l0aW9uLCB0YXJnZXQuYnl0ZUxlbmd0aCAtIHBvc2l0aW9uKVxuXHRcdH0gOiAodGV4dEVuY29kZXIgJiYgdGV4dEVuY29kZXIuZW5jb2RlSW50bykgP1xuXHRcdFx0ZnVuY3Rpb24oc3RyaW5nLCBwb3NpdGlvbikge1xuXHRcdFx0XHRyZXR1cm4gdGV4dEVuY29kZXIuZW5jb2RlSW50byhzdHJpbmcsIHRhcmdldC5zdWJhcnJheShwb3NpdGlvbikpLndyaXR0ZW5cblx0XHRcdH0gOiBmYWxzZVxuXG5cdFx0bGV0IHBhY2tyID0gdGhpc1xuXHRcdGlmICghb3B0aW9ucylcblx0XHRcdG9wdGlvbnMgPSB7fVxuXHRcdGxldCBpc1NlcXVlbnRpYWwgPSBvcHRpb25zICYmIG9wdGlvbnMuc2VxdWVudGlhbFxuXHRcdGxldCBoYXNTaGFyZWRTdHJ1Y3R1cmVzID0gb3B0aW9ucy5zdHJ1Y3R1cmVzIHx8IG9wdGlvbnMuc2F2ZVN0cnVjdHVyZXNcblx0XHRsZXQgbWF4U2hhcmVkU3RydWN0dXJlcyA9IG9wdGlvbnMubWF4U2hhcmVkU3RydWN0dXJlc1xuXHRcdGlmIChtYXhTaGFyZWRTdHJ1Y3R1cmVzID09IG51bGwpXG5cdFx0XHRtYXhTaGFyZWRTdHJ1Y3R1cmVzID0gaGFzU2hhcmVkU3RydWN0dXJlcyA/IDMyIDogMFxuXHRcdGlmIChtYXhTaGFyZWRTdHJ1Y3R1cmVzID4gODE2MClcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWF4aW11bSBtYXhTaGFyZWRTdHJ1Y3R1cmUgaXMgODE2MCcpXG5cdFx0aWYgKG9wdGlvbnMuc3RydWN0dXJlZENsb25lICYmIG9wdGlvbnMubW9yZVR5cGVzID09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5tb3JlVHlwZXMgPSB0cnVlXG5cdFx0fVxuXHRcdGxldCBtYXhPd25TdHJ1Y3R1cmVzID0gb3B0aW9ucy5tYXhPd25TdHJ1Y3R1cmVzXG5cdFx0aWYgKG1heE93blN0cnVjdHVyZXMgPT0gbnVsbClcblx0XHRcdG1heE93blN0cnVjdHVyZXMgPSBoYXNTaGFyZWRTdHJ1Y3R1cmVzID8gMzIgOiA2NFxuXHRcdGlmICghdGhpcy5zdHJ1Y3R1cmVzICYmIG9wdGlvbnMudXNlUmVjb3JkcyAhPSBmYWxzZSlcblx0XHRcdHRoaXMuc3RydWN0dXJlcyA9IFtdXG5cdFx0Ly8gdHdvIGJ5dGUgcmVjb3JkIGlkcyBmb3Igc2hhcmVkIHN0cnVjdHVyZXNcblx0XHRsZXQgdXNlVHdvQnl0ZVJlY29yZHMgPSBtYXhTaGFyZWRTdHJ1Y3R1cmVzID4gMzIgfHwgKG1heE93blN0cnVjdHVyZXMgKyBtYXhTaGFyZWRTdHJ1Y3R1cmVzID4gNjQpXG5cdFx0bGV0IHNoYXJlZExpbWl0SWQgPSBtYXhTaGFyZWRTdHJ1Y3R1cmVzICsgMHg0MFxuXHRcdGxldCBtYXhTdHJ1Y3R1cmVJZCA9IG1heFNoYXJlZFN0cnVjdHVyZXMgKyBtYXhPd25TdHJ1Y3R1cmVzICsgMHg0MFxuXHRcdGlmIChtYXhTdHJ1Y3R1cmVJZCA+IDgyNTYpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWF4aW11bSBtYXhTaGFyZWRTdHJ1Y3R1cmUgKyBtYXhPd25TdHJ1Y3R1cmUgaXMgODE5MicpXG5cdFx0fVxuXHRcdGxldCByZWNvcmRJZHNUb1JlbW92ZSA9IFtdXG5cdFx0bGV0IHRyYW5zaXRpb25zQ291bnQgPSAwXG5cdFx0bGV0IHNlcmlhbGl6YXRpb25zU2luY2VUcmFuc2l0aW9uUmVidWlsZCA9IDBcblxuXHRcdHRoaXMucGFjayA9IHRoaXMuZW5jb2RlID0gZnVuY3Rpb24odmFsdWUsIGVuY29kZU9wdGlvbnMpIHtcblx0XHRcdGlmICghdGFyZ2V0KSB7XG5cdFx0XHRcdHRhcmdldCA9IG5ldyBCeXRlQXJyYXlBbGxvY2F0ZSg4MTkyKVxuXHRcdFx0XHR0YXJnZXRWaWV3ID0gdGFyZ2V0LmRhdGFWaWV3IHx8ICh0YXJnZXQuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcodGFyZ2V0LmJ1ZmZlciwgMCwgODE5MikpXG5cdFx0XHRcdHBvc2l0aW9uID0gMFxuXHRcdFx0fVxuXHRcdFx0c2FmZUVuZCA9IHRhcmdldC5sZW5ndGggLSAxMFxuXHRcdFx0aWYgKHNhZmVFbmQgLSBwb3NpdGlvbiA8IDB4ODAwKSB7XG5cdFx0XHRcdC8vIGRvbid0IHN0YXJ0IHRvbyBjbG9zZSB0byB0aGUgZW5kLFxuXHRcdFx0XHR0YXJnZXQgPSBuZXcgQnl0ZUFycmF5QWxsb2NhdGUodGFyZ2V0Lmxlbmd0aClcblx0XHRcdFx0dGFyZ2V0VmlldyA9IHRhcmdldC5kYXRhVmlldyB8fCAodGFyZ2V0LmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHRhcmdldC5idWZmZXIsIDAsIHRhcmdldC5sZW5ndGgpKVxuXHRcdFx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwXG5cdFx0XHRcdHBvc2l0aW9uID0gMFxuXHRcdFx0fSBlbHNlXG5cdFx0XHRcdHBvc2l0aW9uID0gKHBvc2l0aW9uICsgNykgJiAweDdmZmZmZmY4IC8vIFdvcmQgYWxpZ24gdG8gbWFrZSBhbnkgZnV0dXJlIGNvcHlpbmcgb2YgdGhpcyBidWZmZXIgZmFzdGVyXG5cdFx0XHRzdGFydCA9IHBvc2l0aW9uXG5cdFx0XHRpZiAoZW5jb2RlT3B0aW9ucyAmIFJFU0VSVkVfU1RBUlRfU1BBQ0UpIHBvc2l0aW9uICs9IChlbmNvZGVPcHRpb25zICYgMHhmZilcblx0XHRcdHJlZmVyZW5jZU1hcCA9IHBhY2tyLnN0cnVjdHVyZWRDbG9uZSA/IG5ldyBNYXAoKSA6IG51bGxcblx0XHRcdGlmIChwYWNrci5idW5kbGVTdHJpbmdzICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0YnVuZGxlZFN0cmluZ3MgPSBbXVxuXHRcdFx0XHRidW5kbGVkU3RyaW5ncy5zaXplID0gSW5maW5pdHkgLy8gZm9yY2UgYSBuZXcgYnVuZGxlIHN0YXJ0IG9uIGZpcnN0IHN0cmluZ1xuXHRcdFx0fSBlbHNlXG5cdFx0XHRcdGJ1bmRsZWRTdHJpbmdzID0gbnVsbFxuXHRcdFx0c3RydWN0dXJlcyA9IHBhY2tyLnN0cnVjdHVyZXNcblx0XHRcdGlmIChzdHJ1Y3R1cmVzKSB7XG5cdFx0XHRcdGlmIChzdHJ1Y3R1cmVzLnVuaW5pdGlhbGl6ZWQpXG5cdFx0XHRcdFx0c3RydWN0dXJlcyA9IHBhY2tyLl9tZXJnZVN0cnVjdHVyZXMocGFja3IuZ2V0U3RydWN0dXJlcygpKVxuXHRcdFx0XHRsZXQgc2hhcmVkTGVuZ3RoID0gc3RydWN0dXJlcy5zaGFyZWRMZW5ndGggfHwgMFxuXHRcdFx0XHRpZiAoc2hhcmVkTGVuZ3RoID4gbWF4U2hhcmVkU3RydWN0dXJlcykge1xuXHRcdFx0XHRcdC8vaWYgKG1heFNoYXJlZFN0cnVjdHVyZXMgPD0gMzIgJiYgc3RydWN0dXJlcy5zaGFyZWRMZW5ndGggPiAzMikgLy8gVE9ETzogY291bGQgc3VwcG9ydCB0aGlzLCBidXQgd291bGQgbmVlZCB0byB1cGRhdGUgdGhlIGxpbWl0IGlkc1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignU2hhcmVkIHN0cnVjdHVyZXMgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSBzaGFyZWQgc3RydWN0dXJlcywgdHJ5IGluY3JlYXNpbmcgbWF4U2hhcmVkU3RydWN0dXJlcyB0byAnICsgc3RydWN0dXJlcy5zaGFyZWRMZW5ndGgpXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zKSB7XG5cdFx0XHRcdFx0Ly8gcmVidWlsZCBvdXIgc3RydWN0dXJlIHRyYW5zaXRpb25zXG5cdFx0XHRcdFx0c3RydWN0dXJlcy50cmFuc2l0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbClcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHNoYXJlZExlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRsZXQga2V5cyA9IHN0cnVjdHVyZXNbaV1cblx0XHRcdFx0XHRcdGlmICgha2V5cylcblx0XHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRcdGxldCBuZXh0VHJhbnNpdGlvbiwgdHJhbnNpdGlvbiA9IHN0cnVjdHVyZXMudHJhbnNpdGlvbnNcblx0XHRcdFx0XHRcdGZvciAobGV0IGogPSAwLCBsID0ga2V5cy5sZW5ndGg7IGogPCBsOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0bGV0IGtleSA9IGtleXNbal1cblx0XHRcdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV1cblx0XHRcdFx0XHRcdFx0aWYgKCFuZXh0VHJhbnNpdGlvbikge1xuXHRcdFx0XHRcdFx0XHRcdG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbltSRUNPUkRfU1lNQk9MXSA9IGkgKyAweDQwXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMubGFzdE5hbWVkU3RydWN0dXJlc0xlbmd0aCA9IHNoYXJlZExlbmd0aFxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaXNTZXF1ZW50aWFsKSB7XG5cdFx0XHRcdFx0c3RydWN0dXJlcy5uZXh0SWQgPSBzaGFyZWRMZW5ndGggKyAweDQwXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChoYXNTaGFyZWRVcGRhdGUpXG5cdFx0XHRcdGhhc1NoYXJlZFVwZGF0ZSA9IGZhbHNlXG5cdFx0XHRsZXQgZW5jb2RpbmdFcnJvcjtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmIChwYWNrci5yYW5kb21BY2Nlc3NTdHJ1Y3R1cmUgJiYgdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdClcblx0XHRcdFx0XHR3cml0ZVN0cnVjdCh2YWx1ZSk7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRwYWNrKHZhbHVlKVxuXHRcdFx0XHRsZXQgbGFzdEJ1bmRsZSA9IGJ1bmRsZWRTdHJpbmdzO1xuXHRcdFx0XHRpZiAoYnVuZGxlZFN0cmluZ3MpXG5cdFx0XHRcdFx0d3JpdGVCdW5kbGVzKHN0YXJ0LCBwYWNrLCAwKVxuXHRcdFx0XHRpZiAocmVmZXJlbmNlTWFwICYmIHJlZmVyZW5jZU1hcC5pZHNUb0luc2VydCkge1xuXHRcdFx0XHRcdGxldCBpZHNUb0luc2VydCA9IHJlZmVyZW5jZU1hcC5pZHNUb0luc2VydC5zb3J0KChhLCBiKSA9PiBhLm9mZnNldCA+IGIub2Zmc2V0ID8gMSA6IC0xKTtcblx0XHRcdFx0XHRsZXQgaSA9IGlkc1RvSW5zZXJ0Lmxlbmd0aDtcblx0XHRcdFx0XHRsZXQgaW5jcmVtZW50UG9zaXRpb24gPSAtMTtcblx0XHRcdFx0XHR3aGlsZSAobGFzdEJ1bmRsZSAmJiBpID4gMCkge1xuXHRcdFx0XHRcdFx0bGV0IGluc2VydGlvblBvaW50ID0gaWRzVG9JbnNlcnRbLS1pXS5vZmZzZXQgKyBzdGFydDtcblx0XHRcdFx0XHRcdGlmIChpbnNlcnRpb25Qb2ludCA8IChsYXN0QnVuZGxlLnN0cmluZ3NQb3NpdGlvbiArIHN0YXJ0KSAmJiBpbmNyZW1lbnRQb3NpdGlvbiA9PT0gLTEpXG5cdFx0XHRcdFx0XHRcdGluY3JlbWVudFBvc2l0aW9uID0gMDtcblx0XHRcdFx0XHRcdGlmIChpbnNlcnRpb25Qb2ludCA+IChsYXN0QnVuZGxlLnBvc2l0aW9uICsgc3RhcnQpKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChpbmNyZW1lbnRQb3NpdGlvbiA+PSAwKVxuXHRcdFx0XHRcdFx0XHRcdGluY3JlbWVudFBvc2l0aW9uICs9IDY7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpZiAoaW5jcmVtZW50UG9zaXRpb24gPj0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIHVwZGF0ZSB0aGUgYnVuZGxlIHJlZmVyZW5jZSBub3dcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihsYXN0QnVuZGxlLnBvc2l0aW9uICsgc3RhcnQsXG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3LmdldFVpbnQzMihsYXN0QnVuZGxlLnBvc2l0aW9uICsgc3RhcnQpICsgaW5jcmVtZW50UG9zaXRpb24pXG5cdFx0XHRcdFx0XHRcdFx0aW5jcmVtZW50UG9zaXRpb24gPSAtMTsgLy8gcmVzZXRcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRsYXN0QnVuZGxlID0gbGFzdEJ1bmRsZS5wcmV2aW91cztcblx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoaW5jcmVtZW50UG9zaXRpb24gPj0gMCAmJiBsYXN0QnVuZGxlKSB7XG5cdFx0XHRcdFx0XHQvLyB1cGRhdGUgdGhlIGJ1bmRsZSByZWZlcmVuY2Ugbm93XG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihsYXN0QnVuZGxlLnBvc2l0aW9uICsgc3RhcnQsXG5cdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcuZ2V0VWludDMyKGxhc3RCdW5kbGUucG9zaXRpb24gKyBzdGFydCkgKyBpbmNyZW1lbnRQb3NpdGlvbilcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zaXRpb24gKz0gaWRzVG9JbnNlcnQubGVuZ3RoICogNjtcblx0XHRcdFx0XHRpZiAocG9zaXRpb24gPiBzYWZlRW5kKVxuXHRcdFx0XHRcdFx0bWFrZVJvb20ocG9zaXRpb24pXG5cdFx0XHRcdFx0cGFja3Iub2Zmc2V0ID0gcG9zaXRpb25cblx0XHRcdFx0XHRsZXQgc2VyaWFsaXplZCA9IGluc2VydElkcyh0YXJnZXQuc3ViYXJyYXkoc3RhcnQsIHBvc2l0aW9uKSwgaWRzVG9JbnNlcnQpXG5cdFx0XHRcdFx0cmVmZXJlbmNlTWFwID0gbnVsbFxuXHRcdFx0XHRcdHJldHVybiBzZXJpYWxpemVkXG5cdFx0XHRcdH1cblx0XHRcdFx0cGFja3Iub2Zmc2V0ID0gcG9zaXRpb24gLy8gdXBkYXRlIHRoZSBvZmZzZXQgc28gbmV4dCBzZXJpYWxpemF0aW9uIGRvZXNuJ3Qgd3JpdGUgb3ZlciBvdXIgYnVmZmVyLCBidXQgY2FuIGNvbnRpbnVlIHdyaXRpbmcgdG8gc2FtZSBidWZmZXIgc2VxdWVudGlhbGx5XG5cdFx0XHRcdGlmIChlbmNvZGVPcHRpb25zICYgUkVVU0VfQlVGRkVSX01PREUpIHtcblx0XHRcdFx0XHR0YXJnZXQuc3RhcnQgPSBzdGFydFxuXHRcdFx0XHRcdHRhcmdldC5lbmQgPSBwb3NpdGlvblxuXHRcdFx0XHRcdHJldHVybiB0YXJnZXRcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LnN1YmFycmF5KHN0YXJ0LCBwb3NpdGlvbikgLy8gcG9zaXRpb24gY2FuIGNoYW5nZSBpZiB3ZSBjYWxsIHBhY2sgYWdhaW4gaW4gc2F2ZVN0cnVjdHVyZXMsIHNvIHdlIGdldCB0aGUgYnVmZmVyIG5vd1xuXHRcdFx0fSBjYXRjaChlcnJvcikge1xuXHRcdFx0XHRlbmNvZGluZ0Vycm9yID0gZXJyb3I7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0aWYgKHN0cnVjdHVyZXMpIHtcblx0XHRcdFx0XHRyZXNldFN0cnVjdHVyZXMoKTtcblx0XHRcdFx0XHRpZiAoaGFzU2hhcmVkVXBkYXRlICYmIHBhY2tyLnNhdmVTdHJ1Y3R1cmVzKSB7XG5cdFx0XHRcdFx0XHRsZXQgc2hhcmVkTGVuZ3RoID0gc3RydWN0dXJlcy5zaGFyZWRMZW5ndGggfHwgMFxuXHRcdFx0XHRcdFx0Ly8gd2UgY2FuJ3QgcmVseSBvbiBzdGFydC9lbmQgd2l0aCBSRVVTRV9CVUZGRVJfTU9ERSBzaW5jZSB0aGV5IHdpbGwgKHByb2JhYmx5KSBjaGFuZ2Ugd2hlbiB3ZSBzYXZlXG5cdFx0XHRcdFx0XHRsZXQgcmV0dXJuQnVmZmVyID0gdGFyZ2V0LnN1YmFycmF5KHN0YXJ0LCBwb3NpdGlvbilcblx0XHRcdFx0XHRcdGxldCBuZXdTaGFyZWREYXRhID0gcHJlcGFyZVN0cnVjdHVyZXMoc3RydWN0dXJlcywgcGFja3IpO1xuXHRcdFx0XHRcdFx0aWYgKCFlbmNvZGluZ0Vycm9yKSB7IC8vIFRPRE86IElmIHRoZXJlIGlzIGFuIGVuY29kaW5nIGVycm9yLCBzaG91bGQgbWFrZSB0aGUgc3RydWN0dXJlcyBhcyB1bmluaXRpYWxpemVkIHNvIHRoZXkgZ2V0IHJlYnVpbHQgbmV4dCB0aW1lXG5cdFx0XHRcdFx0XHRcdGlmIChwYWNrci5zYXZlU3RydWN0dXJlcyhuZXdTaGFyZWREYXRhLCBuZXdTaGFyZWREYXRhLmlzQ29tcGF0aWJsZSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gZ2V0IHVwZGF0ZWQgc3RydWN0dXJlcyBhbmQgdHJ5IGFnYWluIGlmIHRoZSB1cGRhdGUgZmFpbGVkXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhY2tyLnBhY2sodmFsdWUsIGVuY29kZU9wdGlvbnMpXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cGFja3IubGFzdE5hbWVkU3RydWN0dXJlc0xlbmd0aCA9IHNoYXJlZExlbmd0aFxuXHRcdFx0XHRcdFx0XHQvLyBkb24ndCBrZWVwIGxhcmdlIGJ1ZmZlcnMgYXJvdW5kXG5cdFx0XHRcdFx0XHRcdGlmICh0YXJnZXQubGVuZ3RoID4gMHg0MDAwMDAwMCkgdGFyZ2V0ID0gbnVsbFxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmV0dXJuQnVmZmVyXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGRvbid0IGtlZXAgbGFyZ2UgYnVmZmVycyBhcm91bmQsIHRoZXkgdGFrZSB0b28gbXVjaCBtZW1vcnkgYW5kIGNhdXNlIHByb2JsZW1zIChsaW1pdCBhdCAxR0IpXG5cdFx0XHRcdGlmICh0YXJnZXQubGVuZ3RoID4gMHg0MDAwMDAwMCkgdGFyZ2V0ID0gbnVsbFxuXHRcdFx0XHRpZiAoZW5jb2RlT3B0aW9ucyAmIFJFU0VUX0JVRkZFUl9NT0RFKVxuXHRcdFx0XHRcdHBvc2l0aW9uID0gc3RhcnRcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3QgcmVzZXRTdHJ1Y3R1cmVzID0gKCkgPT4ge1xuXHRcdFx0aWYgKHNlcmlhbGl6YXRpb25zU2luY2VUcmFuc2l0aW9uUmVidWlsZCA8IDEwKVxuXHRcdFx0XHRzZXJpYWxpemF0aW9uc1NpbmNlVHJhbnNpdGlvblJlYnVpbGQrK1xuXHRcdFx0bGV0IHNoYXJlZExlbmd0aCA9IHN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoIHx8IDBcblx0XHRcdGlmIChzdHJ1Y3R1cmVzLmxlbmd0aCA+IHNoYXJlZExlbmd0aCAmJiAhaXNTZXF1ZW50aWFsKVxuXHRcdFx0XHRzdHJ1Y3R1cmVzLmxlbmd0aCA9IHNoYXJlZExlbmd0aFxuXHRcdFx0aWYgKHRyYW5zaXRpb25zQ291bnQgPiAxMDAwMCkge1xuXHRcdFx0XHQvLyBmb3JjZSBhIHJlYnVpbGQgb2NjYXNpb25hbGx5IGFmdGVyIGEgbG90IG9mIHRyYW5zaXRpb25zIHNvIGl0IGNhbiBnZXQgY2xlYW5lZCB1cFxuXHRcdFx0XHRzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zID0gbnVsbFxuXHRcdFx0XHRzZXJpYWxpemF0aW9uc1NpbmNlVHJhbnNpdGlvblJlYnVpbGQgPSAwXG5cdFx0XHRcdHRyYW5zaXRpb25zQ291bnQgPSAwXG5cdFx0XHRcdGlmIChyZWNvcmRJZHNUb1JlbW92ZS5sZW5ndGggPiAwKVxuXHRcdFx0XHRcdHJlY29yZElkc1RvUmVtb3ZlID0gW11cblx0XHRcdH0gZWxzZSBpZiAocmVjb3JkSWRzVG9SZW1vdmUubGVuZ3RoID4gMCAmJiAhaXNTZXF1ZW50aWFsKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gcmVjb3JkSWRzVG9SZW1vdmUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0cmVjb3JkSWRzVG9SZW1vdmVbaV1bUkVDT1JEX1NZTUJPTF0gPSAwXG5cdFx0XHRcdH1cblx0XHRcdFx0cmVjb3JkSWRzVG9SZW1vdmUgPSBbXVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCBwYWNrQXJyYXkgPSAodmFsdWUpID0+IHtcblx0XHRcdHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGhcblx0XHRcdGlmIChsZW5ndGggPCAweDEwKSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4OTAgfCBsZW5ndGhcblx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRjXG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCA+PiA4XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCAmIDB4ZmZcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGRcblx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGxlbmd0aClcblx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0fVxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRwYWNrKHZhbHVlW2ldKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCBwYWNrID0gKHZhbHVlKSA9PiB7XG5cdFx0XHRpZiAocG9zaXRpb24gPiBzYWZlRW5kKVxuXHRcdFx0XHR0YXJnZXQgPSBtYWtlUm9vbShwb3NpdGlvbilcblxuXHRcdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWVcblx0XHRcdHZhciBsZW5ndGhcblx0XHRcdGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRsZXQgc3RyTGVuZ3RoID0gdmFsdWUubGVuZ3RoXG5cdFx0XHRcdGlmIChidW5kbGVkU3RyaW5ncyAmJiBzdHJMZW5ndGggPj0gNCAmJiBzdHJMZW5ndGggPCAweDEwMDApIHtcblx0XHRcdFx0XHRpZiAoKGJ1bmRsZWRTdHJpbmdzLnNpemUgKz0gc3RyTGVuZ3RoKSA+IE1BWF9CVU5ETEVfU0laRSkge1xuXHRcdFx0XHRcdFx0bGV0IGV4dFN0YXJ0XG5cdFx0XHRcdFx0XHRsZXQgbWF4Qnl0ZXMgPSAoYnVuZGxlZFN0cmluZ3NbMF0gPyBidW5kbGVkU3RyaW5nc1swXS5sZW5ndGggKiAzICsgYnVuZGxlZFN0cmluZ3NbMV0ubGVuZ3RoIDogMCkgKyAxMFxuXHRcdFx0XHRcdFx0aWYgKHBvc2l0aW9uICsgbWF4Qnl0ZXMgPiBzYWZlRW5kKVxuXHRcdFx0XHRcdFx0XHR0YXJnZXQgPSBtYWtlUm9vbShwb3NpdGlvbiArIG1heEJ5dGVzKVxuXHRcdFx0XHRcdFx0bGV0IGxhc3RCdW5kbGVcblx0XHRcdFx0XHRcdGlmIChidW5kbGVkU3RyaW5ncy5wb3NpdGlvbikgeyAvLyBoZXJlIHdlIHVzZSB0aGUgMHg2MiBleHRlbnNpb24gdG8gd3JpdGUgdGhlIGxhc3QgYnVuZGxlIGFuZCByZXNlcnZlIHNwYWNlIGZvciB0aGUgcmVmZXJlbmNlIHBvaW50ZXIgdG8gdGhlIG5leHQvY3VycmVudCBidW5kbGVcblx0XHRcdFx0XHRcdFx0bGFzdEJ1bmRsZSA9IGJ1bmRsZWRTdHJpbmdzXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbl0gPSAweGM4IC8vIGV4dCAxNlxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSAzIC8vIHJlc2VydmUgZm9yIHRoZSB3cml0aW5nIGJ1bmRsZSBzaXplXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NjIgLy8gJ2InXG5cdFx0XHRcdFx0XHRcdGV4dFN0YXJ0ID0gcG9zaXRpb24gLSBzdGFydFxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0IC8vIHJlc2VydmUgZm9yIHdyaXRpbmcgYnVuZGxlIHJlZmVyZW5jZVxuXHRcdFx0XHRcdFx0XHR3cml0ZUJ1bmRsZXMoc3RhcnQsIHBhY2ssIDApIC8vIHdyaXRlIHRoZSBsYXN0IGJ1bmRsZXNcblx0XHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MTYoZXh0U3RhcnQgKyBzdGFydCAtIDMsIHBvc2l0aW9uIC0gc3RhcnQgLSBleHRTdGFydClcblx0XHRcdFx0XHRcdH0gZWxzZSB7IC8vIGhlcmUgd2UgdXNlIHRoZSAweDYyIGV4dGVuc2lvbiBqdXN0IHRvIHJlc2VydmUgdGhlIHNwYWNlIGZvciB0aGUgcmVmZXJlbmNlIHBvaW50ZXIgdG8gdGhlIGJ1bmRsZSAod2lsbCBiZSB1cGRhdGVkIG9uY2UgdGhlIGJ1bmRsZSBpcyB3cml0dGVuKVxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ2IC8vIGZpeGV4dCA0XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NjIgLy8gJ2InXG5cdFx0XHRcdFx0XHRcdGV4dFN0YXJ0ID0gcG9zaXRpb24gLSBzdGFydFxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0IC8vIHJlc2VydmUgZm9yIHdyaXRpbmcgYnVuZGxlIHJlZmVyZW5jZVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnVuZGxlZFN0cmluZ3MgPSBbJycsICcnXSAvLyBjcmVhdGUgbmV3IG9uZXNcblx0XHRcdFx0XHRcdGJ1bmRsZWRTdHJpbmdzLnByZXZpb3VzID0gbGFzdEJ1bmRsZTtcblx0XHRcdFx0XHRcdGJ1bmRsZWRTdHJpbmdzLnNpemUgPSAwXG5cdFx0XHRcdFx0XHRidW5kbGVkU3RyaW5ncy5wb3NpdGlvbiA9IGV4dFN0YXJ0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxldCB0d29CeXRlID0gaGFzTm9uTGF0aW4udGVzdCh2YWx1ZSlcblx0XHRcdFx0XHRidW5kbGVkU3RyaW5nc1t0d29CeXRlID8gMCA6IDFdICs9IHZhbHVlXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjMVxuXHRcdFx0XHRcdHBhY2sodHdvQnl0ZSA/IC1zdHJMZW5ndGggOiBzdHJMZW5ndGgpO1xuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdGxldCBoZWFkZXJTaXplXG5cdFx0XHRcdC8vIGZpcnN0IHdlIGVzdGltYXRlIHRoZSBoZWFkZXIgc2l6ZSwgc28gd2UgY2FuIHdyaXRlIHRvIHRoZSBjb3JyZWN0IGxvY2F0aW9uXG5cdFx0XHRcdGlmIChzdHJMZW5ndGggPCAweDIwKSB7XG5cdFx0XHRcdFx0aGVhZGVyU2l6ZSA9IDFcblx0XHRcdFx0fSBlbHNlIGlmIChzdHJMZW5ndGggPCAweDEwMCkge1xuXHRcdFx0XHRcdGhlYWRlclNpemUgPSAyXG5cdFx0XHRcdH0gZWxzZSBpZiAoc3RyTGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHRcdGhlYWRlclNpemUgPSAzXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aGVhZGVyU2l6ZSA9IDVcblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgbWF4Qnl0ZXMgPSBzdHJMZW5ndGggKiAzXG5cdFx0XHRcdGlmIChwb3NpdGlvbiArIG1heEJ5dGVzID4gc2FmZUVuZClcblx0XHRcdFx0XHR0YXJnZXQgPSBtYWtlUm9vbShwb3NpdGlvbiArIG1heEJ5dGVzKVxuXG5cdFx0XHRcdGlmIChzdHJMZW5ndGggPCAweDQwIHx8ICFlbmNvZGVVdGY4KSB7XG5cdFx0XHRcdFx0bGV0IGksIGMxLCBjMiwgc3RyUG9zaXRpb24gPSBwb3NpdGlvbiArIGhlYWRlclNpemVcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgc3RyTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGMxID0gdmFsdWUuY2hhckNvZGVBdChpKVxuXHRcdFx0XHRcdFx0aWYgKGMxIDwgMHg4MCkge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChjMSA8IDB4ODAwKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxID4+IDYgfCAweGMwXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxICYgMHgzZiB8IDB4ODBcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdFx0XHRcdChjMSAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJlxuXHRcdFx0XHRcdFx0XHQoKGMyID0gdmFsdWUuY2hhckNvZGVBdChpICsgMSkpICYgMHhmYzAwKSA9PT0gMHhkYzAwXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0YzEgPSAweDEwMDAwICsgKChjMSAmIDB4MDNmZikgPDwgMTApICsgKGMyICYgMHgwM2ZmKVxuXHRcdFx0XHRcdFx0XHRpKytcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgPj4gMTggfCAweGYwXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxID4+IDEyICYgMHgzZiB8IDB4ODBcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgPj4gNiAmIDB4M2YgfCAweDgwXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxICYgMHgzZiB8IDB4ODBcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxID4+IDEyIHwgMHhlMFxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSA+PiA2ICYgMHgzZiB8IDB4ODBcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgJiAweDNmIHwgMHg4MFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsZW5ndGggPSBzdHJQb3NpdGlvbiAtIHBvc2l0aW9uIC0gaGVhZGVyU2l6ZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxlbmd0aCA9IGVuY29kZVV0ZjgodmFsdWUsIHBvc2l0aW9uICsgaGVhZGVyU2l6ZSlcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChsZW5ndGggPCAweDIwKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhhMCB8IGxlbmd0aFxuXHRcdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwKSB7XG5cdFx0XHRcdFx0aWYgKGhlYWRlclNpemUgPCAyKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQuY29weVdpdGhpbihwb3NpdGlvbiArIDIsIHBvc2l0aW9uICsgMSwgcG9zaXRpb24gKyAxICsgbGVuZ3RoKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ5XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoXG5cdFx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHRcdGlmIChoZWFkZXJTaXplIDwgMykge1xuXHRcdFx0XHRcdFx0dGFyZ2V0LmNvcHlXaXRoaW4ocG9zaXRpb24gKyAzLCBwb3NpdGlvbiArIDIsIHBvc2l0aW9uICsgMiArIGxlbmd0aClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkYVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCA+PiA4XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZlxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChoZWFkZXJTaXplIDwgNSkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0LmNvcHlXaXRoaW4ocG9zaXRpb24gKyA1LCBwb3NpdGlvbiArIDMsIHBvc2l0aW9uICsgMyArIGxlbmd0aClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkYlxuXHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBsZW5ndGgpXG5cdFx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0XHR9XG5cdFx0XHRcdHBvc2l0aW9uICs9IGxlbmd0aFxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRpZiAodmFsdWUgPj4+IDAgPT09IHZhbHVlKSB7Ly8gcG9zaXRpdmUgaW50ZWdlciwgMzItYml0IG9yIGxlc3Ncblx0XHRcdFx0XHQvLyBwb3NpdGl2ZSB1aW50XG5cdFx0XHRcdFx0aWYgKHZhbHVlIDwgMHgyMCB8fCAodmFsdWUgPCAweDgwICYmIHRoaXMudXNlUmVjb3JkcyA9PT0gZmFsc2UpIHx8ICh2YWx1ZSA8IDB4NDAgJiYgIXRoaXMucmFuZG9tQWNjZXNzU3RydWN0dXJlKSkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdmFsdWVcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlIDwgMHgxMDApIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2Ncblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA8IDB4MTAwMDApIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2Rcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlID4+IDhcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlICYgMHhmZlxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGNlXG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlID4+IDAgPT09IHZhbHVlKSB7IC8vIG5lZ2F0aXZlIGludGVnZXJcblx0XHRcdFx0XHRpZiAodmFsdWUgPj0gLTB4MjApIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4MTAwICsgdmFsdWVcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlID49IC0weDgwKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQwXG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSB2YWx1ZSArIDB4MTAwXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA+PSAtMHg4MDAwKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQxXG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEludDE2KHBvc2l0aW9uLCB2YWx1ZSlcblx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDJcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkMlxuXHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRJbnQzMihwb3NpdGlvbiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxldCB1c2VGbG9hdDMyXG5cdFx0XHRcdFx0aWYgKCh1c2VGbG9hdDMyID0gdGhpcy51c2VGbG9hdDMyKSA+IDAgJiYgdmFsdWUgPCAweDEwMDAwMDAwMCAmJiB2YWx1ZSA+PSAtMHg4MDAwMDAwMCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjYVxuXHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRGbG9hdDMyKHBvc2l0aW9uLCB2YWx1ZSlcblx0XHRcdFx0XHRcdGxldCB4U2hpZnRlZFxuXHRcdFx0XHRcdFx0aWYgKHVzZUZsb2F0MzIgPCA0IHx8XG5cdFx0XHRcdFx0XHRcdFx0Ly8gdGhpcyBjaGVja3MgZm9yIHJvdW5kaW5nIG9mIG51bWJlcnMgdGhhdCB3ZXJlIGVuY29kZWQgaW4gMzItYml0IGZsb2F0IHRvIG5lYXJlc3Qgc2lnbmlmaWNhbnQgZGVjaW1hbCBkaWdpdCB0aGF0IGNvdWxkIGJlIHByZXNlcnZlZFxuXHRcdFx0XHRcdFx0XHRcdCgoeFNoaWZ0ZWQgPSB2YWx1ZSAqIG11bHQxMFsoKHRhcmdldFtwb3NpdGlvbl0gJiAweDdmKSA8PCAxKSB8ICh0YXJnZXRbcG9zaXRpb24gKyAxXSA+PiA3KV0pID4+IDApID09PSB4U2hpZnRlZCkge1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uLS0gLy8gbW92ZSBiYWNrIGludG8gcG9zaXRpb24gZm9yIHdyaXRpbmcgYSBkb3VibGVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjYlxuXHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0RmxvYXQ2NChwb3NpdGlvbiwgdmFsdWUpXG5cdFx0XHRcdFx0cG9zaXRpb24gKz0gOFxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0aWYgKCF2YWx1ZSlcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGMwXG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmIChyZWZlcmVuY2VNYXApIHtcblx0XHRcdFx0XHRcdGxldCByZWZlcmVlID0gcmVmZXJlbmNlTWFwLmdldCh2YWx1ZSlcblx0XHRcdFx0XHRcdGlmIChyZWZlcmVlKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghcmVmZXJlZS5pZCkge1xuXHRcdFx0XHRcdFx0XHRcdGxldCBpZHNUb0luc2VydCA9IHJlZmVyZW5jZU1hcC5pZHNUb0luc2VydCB8fCAocmVmZXJlbmNlTWFwLmlkc1RvSW5zZXJ0ID0gW10pXG5cdFx0XHRcdFx0XHRcdFx0cmVmZXJlZS5pZCA9IGlkc1RvSW5zZXJ0LnB1c2gocmVmZXJlZSlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ2IC8vIGZpeGV4dCA0XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NzAgLy8gXCJwXCIgZm9yIHBvaW50ZXJcblx0XHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIHJlZmVyZWUuaWQpXG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdFx0cmVmZXJlbmNlTWFwLnNldCh2YWx1ZSwgeyBvZmZzZXQ6IHBvc2l0aW9uIC0gc3RhcnQgfSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGV0IGNvbnN0cnVjdG9yID0gdmFsdWUuY29uc3RydWN0b3Jcblx0XHRcdFx0XHRpZiAoY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuXHRcdFx0XHRcdFx0d3JpdGVPYmplY3QodmFsdWUpXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcblx0XHRcdFx0XHRcdHBhY2tBcnJheSh2YWx1ZSlcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGNvbnN0cnVjdG9yID09PSBNYXApIHtcblx0XHRcdFx0XHRcdGlmICh0aGlzLm1hcEFzRW1wdHlPYmplY3QpIHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ODBcblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsZW5ndGggPSB2YWx1ZS5zaXplXG5cdFx0XHRcdFx0XHRcdGlmIChsZW5ndGggPCAweDEwKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg4MCB8IGxlbmd0aFxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRlXG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoID4+IDhcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggJiAweGZmXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkZlxuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBsZW5ndGgpXG5cdFx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGZvciAobGV0IFtrZXksIGVudHJ5VmFsdWVdIG9mIHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGFjayhrZXkpXG5cdFx0XHRcdFx0XHRcdFx0cGFjayhlbnRyeVZhbHVlKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gZXh0ZW5zaW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0bGV0IGV4dGVuc2lvbkNsYXNzID0gZXh0ZW5zaW9uQ2xhc3Nlc1tpXVxuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBleHRlbnNpb25DbGFzcykge1xuXHRcdFx0XHRcdFx0XHRcdGxldCBleHRlbnNpb24gPSBleHRlbnNpb25zW2ldXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGV4dGVuc2lvbi53cml0ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGV4dGVuc2lvbi50eXBlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDQgLy8gb25lIGJ5dGUgXCJ0YWdcIiBleHRlbnNpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gZXh0ZW5zaW9uLnR5cGVcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0bGV0IHdyaXRlUmVzdWx0ID0gZXh0ZW5zaW9uLndyaXRlLmNhbGwodGhpcywgdmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAod3JpdGVSZXN1bHQgPT09IHZhbHVlKSB7IC8vIGF2b2lkIGluZmluaXRlIHJlY3Vyc2lvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwYWNrQXJyYXkodmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0d3JpdGVPYmplY3QodmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhY2sod3JpdGVSZXN1bHQpXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGN1cnJlbnRUYXJnZXQgPSB0YXJnZXRcblx0XHRcdFx0XHRcdFx0XHRsZXQgY3VycmVudFRhcmdldFZpZXcgPSB0YXJnZXRWaWV3XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGN1cnJlbnRQb3NpdGlvbiA9IHBvc2l0aW9uXG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gbnVsbFxuXHRcdFx0XHRcdFx0XHRcdGxldCByZXN1bHRcblx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzdWx0ID0gZXh0ZW5zaW9uLnBhY2suY2FsbCh0aGlzLCB2YWx1ZSwgKHNpemUpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gcmVzdG9yZSB0YXJnZXQgYW5kIHVzZSBpdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXQgPSBjdXJyZW50VGFyZ2V0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRUYXJnZXQgPSBudWxsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IHNpemVcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKHBvc2l0aW9uID4gc2FmZUVuZClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYWtlUm9vbShwb3NpdGlvbilcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXQsIHRhcmdldFZpZXcsIHBvc2l0aW9uOiBwb3NpdGlvbiAtIHNpemVcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSwgcGFjaylcblx0XHRcdFx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gcmVzdG9yZSBjdXJyZW50IHRhcmdldCBpbmZvcm1hdGlvbiAodW5sZXNzIGFscmVhZHkgcmVzdG9yZWQpXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoY3VycmVudFRhcmdldCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXQgPSBjdXJyZW50VGFyZ2V0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcgPSBjdXJyZW50VGFyZ2V0Vmlld1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbiA9IGN1cnJlbnRQb3NpdGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmIChyZXN1bHQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChyZXN1bHQubGVuZ3RoICsgcG9zaXRpb24gPiBzYWZlRW5kKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRtYWtlUm9vbShyZXN1bHQubGVuZ3RoICsgcG9zaXRpb24pXG5cdFx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbiA9IHdyaXRlRXh0ZW5zaW9uRGF0YShyZXN1bHQsIHRhcmdldCwgcG9zaXRpb24sIGV4dGVuc2lvbi50eXBlKVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gY2hlY2sgaXNBcnJheSBhZnRlciBleHRlbnNpb25zLCBiZWNhdXNlIGV4dGVuc2lvbnMgY2FuIGV4dGVuZCBBcnJheVxuXHRcdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdHBhY2tBcnJheSh2YWx1ZSlcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIHVzZSB0aGlzIGFzIGFuIGFsdGVybmF0ZSBtZWNoYW5pc20gZm9yIGV4cHJlc3NpbmcgaG93IHRvIHNlcmlhbGl6ZVxuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUudG9KU09OKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QganNvbiA9IHZhbHVlLnRvSlNPTigpXG5cdFx0XHRcdFx0XHRcdFx0Ly8gaWYgZm9yIHNvbWUgcmVhc29uIHZhbHVlLnRvSlNPTiByZXR1cm5zIGl0c2VsZiBpdCdsbCBsb29wIGZvcmV2ZXJcblx0XHRcdFx0XHRcdFx0XHRpZiAoanNvbiAhPT0gdmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcGFjayhqc29uKVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgYSB3cml0ZUZ1bmN0aW9uLCB1c2UgaXQsIG90aGVyd2lzZSBqdXN0IGVuY29kZSBhcyB1bmRlZmluZWRcblx0XHRcdFx0XHRcdFx0aWYgKHR5cGUgPT09ICdmdW5jdGlvbicpXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhY2sodGhpcy53cml0ZUZ1bmN0aW9uICYmIHRoaXMud3JpdGVGdW5jdGlvbih2YWx1ZSkpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIG5vIGV4dGVuc2lvbiBmb3VuZCwgd3JpdGUgYXMgcGxhaW4gb2JqZWN0XG5cdFx0XHRcdFx0XHRcdHdyaXRlT2JqZWN0KHZhbHVlKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdmFsdWUgPyAweGMzIDogMHhjMlxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnYmlnaW50Jykge1xuXHRcdFx0XHRpZiAodmFsdWUgPCAoQmlnSW50KDEpPDxCaWdJbnQoNjMpKSAmJiB2YWx1ZSA+PSAtKEJpZ0ludCgxKTw8QmlnSW50KDYzKSkpIHtcblx0XHRcdFx0XHQvLyB1c2UgYSBzaWduZWQgaW50IGFzIGxvbmcgYXMgaXQgZml0c1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDNcblx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEJpZ0ludDY0KHBvc2l0aW9uLCB2YWx1ZSlcblx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA8IChCaWdJbnQoMSk8PEJpZ0ludCg2NCkpICYmIHZhbHVlID4gMCkge1xuXHRcdFx0XHRcdC8vIGlmIHdlIGNhbiBmaXQgYW4gdW5zaWduZWQgaW50LCB1c2UgdGhhdFxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2Zcblx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEJpZ1VpbnQ2NChwb3NpdGlvbiwgdmFsdWUpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gb3ZlcmZsb3dcblx0XHRcdFx0XHRpZiAodGhpcy5sYXJnZUJpZ0ludFRvRmxvYXQpIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2Jcblx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0RmxvYXQ2NChwb3NpdGlvbiwgTnVtYmVyKHZhbHVlKSlcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMubGFyZ2VCaWdJbnRUb1N0cmluZykge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHBhY2sodmFsdWUudG9TdHJpbmcoKSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLnVzZUJpZ0ludEV4dGVuc2lvbiAmJiB2YWx1ZSA8IEJpZ0ludCgyKSoqQmlnSW50KDEwMjMpICYmIHZhbHVlID4gLShCaWdJbnQoMikqKkJpZ0ludCgxMDIzKSkpIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzdcblx0XHRcdFx0XHRcdHBvc2l0aW9uKys7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDQyIC8vIFwiQlwiIGZvciBCaWdJbnRcblx0XHRcdFx0XHRcdGxldCBieXRlcyA9IFtdO1xuXHRcdFx0XHRcdFx0bGV0IGFsaWduZWRTaWduO1xuXHRcdFx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdFx0XHRsZXQgYnl0ZSA9IHZhbHVlICYgQmlnSW50KDB4ZmYpO1xuXHRcdFx0XHRcdFx0XHRhbGlnbmVkU2lnbiA9IChieXRlICYgQmlnSW50KDB4ODApKSA9PT0gKHZhbHVlIDwgQmlnSW50KDApID8gQmlnSW50KDB4ODApIDogQmlnSW50KDApKTtcblx0XHRcdFx0XHRcdFx0Ynl0ZXMucHVzaChieXRlKTtcblx0XHRcdFx0XHRcdFx0dmFsdWUgPj49IEJpZ0ludCg4KTtcblx0XHRcdFx0XHRcdH0gd2hpbGUgKCEoKHZhbHVlID09PSBCaWdJbnQoMCkgfHwgdmFsdWUgPT09IEJpZ0ludCgtMSkpICYmIGFsaWduZWRTaWduKSk7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24tMl0gPSBieXRlcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gYnl0ZXMubGVuZ3RoOyBpID4gMDspIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gTnVtYmVyKGJ5dGVzWy0taV0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKHZhbHVlICsgJyB3YXMgdG9vIGxhcmdlIHRvIGZpdCBpbiBNZXNzYWdlUGFjayA2NC1iaXQgaW50ZWdlciBmb3JtYXQsIHVzZScgK1xuXHRcdFx0XHRcdFx0XHQnIHVzZUJpZ0ludEV4dGVuc2lvbiwgb3Igc2V0IGxhcmdlQmlnSW50VG9GbG9hdCB0byBjb252ZXJ0IHRvIGZsb2F0LTY0LCBvciBzZXQnICtcblx0XHRcdFx0XHRcdFx0JyBsYXJnZUJpZ0ludFRvU3RyaW5nIHRvIGNvbnZlcnQgdG8gc3RyaW5nJylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cG9zaXRpb24gKz0gOFxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRpZiAodGhpcy5lbmNvZGVVbmRlZmluZWRBc05pbClcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGMwXG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDQgLy8gYSBudW1iZXIgb2YgaW1wbGVtZW50YXRpb25zIHVzZSBmaXhleHQxIHdpdGggdHlwZSAwLCBkYXRhIDAgdG8gZGVub3RlIHVuZGVmaW5lZCwgc28gd2UgZm9sbG93IHN1aXRlXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMFxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDBcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyB0eXBlKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IHdyaXRlUGxhaW5PYmplY3QgPSAodGhpcy52YXJpYWJsZU1hcFNpemUgfHwgdGhpcy5jb2VyY2libGVLZXlBc051bWJlciB8fCB0aGlzLnNraXBWYWx1ZXMpID8gKG9iamVjdCkgPT4ge1xuXHRcdFx0Ly8gdGhpcyBtZXRob2QgaXMgc2xpZ2h0bHkgc2xvd2VyLCBidXQgZ2VuZXJhdGVzIFwicHJlZmVycmVkIHNlcmlhbGl6YXRpb25cIiAob3B0aW1hbGx5IHNtYWxsIGZvciBzbWFsbGVyIG9iamVjdHMpXG5cdFx0XHRsZXQga2V5cztcblx0XHRcdGlmICh0aGlzLnNraXBWYWx1ZXMpIHtcblx0XHRcdFx0a2V5cyA9IFtdO1xuXHRcdFx0XHRmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdFx0aWYgKCh0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5ICE9PSAnZnVuY3Rpb24nIHx8IG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSAmJlxuXHRcdFx0XHRcdFx0IXRoaXMuc2tpcFZhbHVlcy5pbmNsdWRlcyhvYmplY3Rba2V5XSkpXG5cdFx0XHRcdFx0XHRrZXlzLnB1c2goa2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdClcblx0XHRcdH1cblx0XHRcdGxldCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTApIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg4MCB8IGxlbmd0aFxuXHRcdFx0fSBlbHNlIGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGVcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoID4+IDhcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZlxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkZlxuXHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgbGVuZ3RoKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHR9XG5cdFx0XHRsZXQga2V5XG5cdFx0XHRpZiAodGhpcy5jb2VyY2libGVLZXlBc051bWJlcikge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0a2V5ID0ga2V5c1tpXVxuXHRcdFx0XHRcdGxldCBudW0gPSBOdW1iZXIoa2V5KVxuXHRcdFx0XHRcdHBhY2soaXNOYU4obnVtKSA/IGtleSA6IG51bSlcblx0XHRcdFx0XHRwYWNrKG9iamVjdFtrZXldKVxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRwYWNrKGtleSA9IGtleXNbaV0pXG5cdFx0XHRcdFx0cGFjayhvYmplY3Rba2V5XSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gOlxuXHRcdChvYmplY3QpID0+IHtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGUgLy8gYWx3YXlzIHVzaW5nIG1hcCAxNiwgc28gd2UgY2FuIHByZWFsbG9jYXRlIGFuZCBzZXQgdGhlIGxlbmd0aCBhZnRlcndhcmRzXG5cdFx0XHRsZXQgb2JqZWN0T2Zmc2V0ID0gcG9zaXRpb24gLSBzdGFydFxuXHRcdFx0cG9zaXRpb24gKz0gMlxuXHRcdFx0bGV0IHNpemUgPSAwXG5cdFx0XHRmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5ICE9PSAnZnVuY3Rpb24nIHx8IG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0cGFjayhrZXkpXG5cdFx0XHRcdFx0cGFjayhvYmplY3Rba2V5XSlcblx0XHRcdFx0XHRzaXplKytcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHNpemUgPiAweGZmZmYpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdPYmplY3QgaXMgdG9vIGxhcmdlIHRvIHNlcmlhbGl6ZSB3aXRoIGZhc3QgMTYtYml0IG1hcCBzaXplLCcgK1xuXHRcdFx0XHQnIHVzZSB0aGUgXCJ2YXJpYWJsZU1hcFNpemVcIiBvcHRpb24gdG8gc2VyaWFsaXplIHRoaXMgb2JqZWN0Jyk7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXRbb2JqZWN0T2Zmc2V0KysgKyBzdGFydF0gPSBzaXplID4+IDhcblx0XHRcdHRhcmdldFtvYmplY3RPZmZzZXQgKyBzdGFydF0gPSBzaXplICYgMHhmZlxuXHRcdH1cblxuXHRcdGNvbnN0IHdyaXRlUmVjb3JkID0gdGhpcy51c2VSZWNvcmRzID09PSBmYWxzZSA/IHdyaXRlUGxhaW5PYmplY3QgOlxuXHRcdChvcHRpb25zLnByb2dyZXNzaXZlUmVjb3JkcyAmJiAhdXNlVHdvQnl0ZVJlY29yZHMpID8gIC8vIHRoaXMgaXMgYWJvdXQgMiUgZmFzdGVyIGZvciBoaWdobHkgc3RhYmxlIHN0cnVjdHVyZXMsIHNpbmNlIGl0IG9ubHkgcmVxdWlyZXMgb25lIGZvci1pbiBsb29wIChidXQgbXVjaCBtb3JlIGV4cGVuc2l2ZSB3aGVuIG5ldyBzdHJ1Y3R1cmUgbmVlZHMgdG8gYmUgd3JpdHRlbilcblx0XHQob2JqZWN0KSA9PiB7XG5cdFx0XHRsZXQgbmV4dFRyYW5zaXRpb24sIHRyYW5zaXRpb24gPSBzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zIHx8IChzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKSlcblx0XHRcdGxldCBvYmplY3RPZmZzZXQgPSBwb3NpdGlvbisrIC0gc3RhcnRcblx0XHRcdGxldCB3cm90ZUtleXNcblx0XHRcdGZvciAobGV0IGtleSBpbiBvYmplY3QpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHkgIT09ICdmdW5jdGlvbicgfHwgb2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XVxuXHRcdFx0XHRcdGlmIChuZXh0VHJhbnNpdGlvbilcblx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvblxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gcmVjb3JkIGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBmdWxsIG5ldyByZWNvcmQgYW5kIGluc2VydCBpdFxuXHRcdFx0XHRcdFx0bGV0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpXG5cdFx0XHRcdFx0XHRsZXQgbGFzdFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uXG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gc3RydWN0dXJlcy50cmFuc2l0aW9uc1xuXHRcdFx0XHRcdFx0bGV0IG5ld1RyYW5zaXRpb25zID0gMFxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRsZXQga2V5ID0ga2V5c1tpXVxuXHRcdFx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XVxuXHRcdFx0XHRcdFx0XHRpZiAoIW5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cdFx0XHRcdFx0XHRcdFx0bmV3VHJhbnNpdGlvbnMrK1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKG9iamVjdE9mZnNldCArIHN0YXJ0ICsgMSA9PSBwb3NpdGlvbikge1xuXHRcdFx0XHRcdFx0XHQvLyBmaXJzdCBrZXksIHNvIHdlIGRvbid0IG5lZWQgdG8gaW5zZXJ0LCB3ZSBjYW4ganVzdCB3cml0ZSByZWNvcmQgZGlyZWN0bHlcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24tLVxuXHRcdFx0XHRcdFx0XHRuZXdSZWNvcmQodHJhbnNpdGlvbiwga2V5cywgbmV3VHJhbnNpdGlvbnMpXG5cdFx0XHRcdFx0XHR9IGVsc2UgLy8gb3RoZXJ3aXNlIHdlIG5lZWQgdG8gaW5zZXJ0IHRoZSByZWNvcmQsIG1vdmluZyBleGlzdGluZyBkYXRhIGFmdGVyIHRoZSByZWNvcmRcblx0XHRcdFx0XHRcdFx0aW5zZXJ0TmV3UmVjb3JkKHRyYW5zaXRpb24sIGtleXMsIG9iamVjdE9mZnNldCwgbmV3VHJhbnNpdGlvbnMpXG5cdFx0XHRcdFx0XHR3cm90ZUtleXMgPSB0cnVlXG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbGFzdFRyYW5zaXRpb25ba2V5XVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwYWNrKG9iamVjdFtrZXldKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXdyb3RlS2V5cykge1xuXHRcdFx0XHRsZXQgcmVjb3JkSWQgPSB0cmFuc2l0aW9uW1JFQ09SRF9TWU1CT0xdXG5cdFx0XHRcdGlmIChyZWNvcmRJZClcblx0XHRcdFx0XHR0YXJnZXRbb2JqZWN0T2Zmc2V0ICsgc3RhcnRdID0gcmVjb3JkSWRcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGluc2VydE5ld1JlY29yZCh0cmFuc2l0aW9uLCBPYmplY3Qua2V5cyhvYmplY3QpLCBvYmplY3RPZmZzZXQsIDApXG5cdFx0XHR9XG5cdFx0fSA6XG5cdFx0KG9iamVjdCkgPT4ge1xuXHRcdFx0bGV0IG5leHRUcmFuc2l0aW9uLCB0cmFuc2l0aW9uID0gc3RydWN0dXJlcy50cmFuc2l0aW9ucyB8fCAoc3RydWN0dXJlcy50cmFuc2l0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCkpXG5cdFx0XHRsZXQgbmV3VHJhbnNpdGlvbnMgPSAwXG5cdFx0XHRmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSBpZiAodHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJyB8fCBvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XVxuXHRcdFx0XHRpZiAoIW5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cdFx0XHRcdFx0bmV3VHJhbnNpdGlvbnMrK1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvblxuXHRcdFx0fVxuXHRcdFx0bGV0IHJlY29yZElkID0gdHJhbnNpdGlvbltSRUNPUkRfU1lNQk9MXVxuXHRcdFx0aWYgKHJlY29yZElkKSB7XG5cdFx0XHRcdGlmIChyZWNvcmRJZCA+PSAweDYwICYmIHVzZVR3b0J5dGVSZWNvcmRzKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKChyZWNvcmRJZCAtPSAweDYwKSAmIDB4MWYpICsgMHg2MFxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHJlY29yZElkID4+IDVcblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gcmVjb3JkSWRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5ld1JlY29yZCh0cmFuc2l0aW9uLCB0cmFuc2l0aW9uLl9fa2V5c19fIHx8IE9iamVjdC5rZXlzKG9iamVjdCksIG5ld1RyYW5zaXRpb25zKVxuXHRcdFx0fVxuXHRcdFx0Ly8gbm93IHdyaXRlIHRoZSB2YWx1ZXNcblx0XHRcdGZvciAobGV0IGtleSBpbiBvYmplY3QpXG5cdFx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5ICE9PSAnZnVuY3Rpb24nIHx8IG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0cGFjayhvYmplY3Rba2V5XSlcblx0XHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGNyZWF0ZSByZWZlcmVuY2UgdG8gdXNlUmVjb3JkcyBpZiB1c2VSZWNvcmRzIGlzIGEgZnVuY3Rpb25cblx0XHRjb25zdCBjaGVja1VzZVJlY29yZHMgPSB0eXBlb2YgdGhpcy51c2VSZWNvcmRzID09ICdmdW5jdGlvbicgJiYgdGhpcy51c2VSZWNvcmRzO1xuXG5cdFx0Y29uc3Qgd3JpdGVPYmplY3QgPSBjaGVja1VzZVJlY29yZHMgPyAob2JqZWN0KSA9PiB7XG5cdFx0XHRjaGVja1VzZVJlY29yZHMob2JqZWN0KSA/IHdyaXRlUmVjb3JkKG9iamVjdCkgOiB3cml0ZVBsYWluT2JqZWN0KG9iamVjdClcblx0XHR9IDogd3JpdGVSZWNvcmRcblxuXHRcdGNvbnN0IG1ha2VSb29tID0gKGVuZCkgPT4ge1xuXHRcdFx0bGV0IG5ld1NpemVcblx0XHRcdGlmIChlbmQgPiAweDEwMDAwMDApIHtcblx0XHRcdFx0Ly8gc3BlY2lhbCBoYW5kbGluZyBmb3IgcmVhbGx5IGxhcmdlIGJ1ZmZlcnNcblx0XHRcdFx0aWYgKChlbmQgLSBzdGFydCkgPiBNQVhfQlVGRkVSX1NJWkUpXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQYWNrZWQgYnVmZmVyIHdvdWxkIGJlIGxhcmdlciB0aGFuIG1heGltdW0gYnVmZmVyIHNpemUnKVxuXHRcdFx0XHRuZXdTaXplID0gTWF0aC5taW4oTUFYX0JVRkZFUl9TSVpFLFxuXHRcdFx0XHRcdE1hdGgucm91bmQoTWF0aC5tYXgoKGVuZCAtIHN0YXJ0KSAqIChlbmQgPiAweDQwMDAwMDAgPyAxLjI1IDogMiksIDB4NDAwMDAwKSAvIDB4MTAwMCkgKiAweDEwMDApXG5cdFx0XHR9IGVsc2UgLy8gZmFzdGVyIGhhbmRsaW5nIGZvciBzbWFsbGVyIGJ1ZmZlcnNcblx0XHRcdFx0bmV3U2l6ZSA9ICgoTWF0aC5tYXgoKGVuZCAtIHN0YXJ0KSA8PCAyLCB0YXJnZXQubGVuZ3RoIC0gMSkgPj4gMTIpICsgMSkgPDwgMTJcblx0XHRcdGxldCBuZXdCdWZmZXIgPSBuZXcgQnl0ZUFycmF5QWxsb2NhdGUobmV3U2l6ZSlcblx0XHRcdHRhcmdldFZpZXcgPSBuZXdCdWZmZXIuZGF0YVZpZXcgfHwgKG5ld0J1ZmZlci5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhuZXdCdWZmZXIuYnVmZmVyLCAwLCBuZXdTaXplKSlcblx0XHRcdGVuZCA9IE1hdGgubWluKGVuZCwgdGFyZ2V0Lmxlbmd0aClcblx0XHRcdGlmICh0YXJnZXQuY29weSlcblx0XHRcdFx0dGFyZ2V0LmNvcHkobmV3QnVmZmVyLCAwLCBzdGFydCwgZW5kKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRuZXdCdWZmZXIuc2V0KHRhcmdldC5zbGljZShzdGFydCwgZW5kKSlcblx0XHRcdHBvc2l0aW9uIC09IHN0YXJ0XG5cdFx0XHRzdGFydCA9IDBcblx0XHRcdHNhZmVFbmQgPSBuZXdCdWZmZXIubGVuZ3RoIC0gMTBcblx0XHRcdHJldHVybiB0YXJnZXQgPSBuZXdCdWZmZXJcblx0XHR9XG5cdFx0Y29uc3QgbmV3UmVjb3JkID0gKHRyYW5zaXRpb24sIGtleXMsIG5ld1RyYW5zaXRpb25zKSA9PiB7XG5cdFx0XHRsZXQgcmVjb3JkSWQgPSBzdHJ1Y3R1cmVzLm5leHRJZFxuXHRcdFx0aWYgKCFyZWNvcmRJZClcblx0XHRcdFx0cmVjb3JkSWQgPSAweDQwXG5cdFx0XHRpZiAocmVjb3JkSWQgPCBzaGFyZWRMaW1pdElkICYmIHRoaXMuc2hvdWxkU2hhcmVTdHJ1Y3R1cmUgJiYgIXRoaXMuc2hvdWxkU2hhcmVTdHJ1Y3R1cmUoa2V5cykpIHtcblx0XHRcdFx0cmVjb3JkSWQgPSBzdHJ1Y3R1cmVzLm5leHRPd25JZFxuXHRcdFx0XHRpZiAoIShyZWNvcmRJZCA8IG1heFN0cnVjdHVyZUlkKSlcblx0XHRcdFx0XHRyZWNvcmRJZCA9IHNoYXJlZExpbWl0SWRcblx0XHRcdFx0c3RydWN0dXJlcy5uZXh0T3duSWQgPSByZWNvcmRJZCArIDFcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChyZWNvcmRJZCA+PSBtYXhTdHJ1Y3R1cmVJZCkvLyBjeWNsZSBiYWNrIGFyb3VuZFxuXHRcdFx0XHRcdHJlY29yZElkID0gc2hhcmVkTGltaXRJZFxuXHRcdFx0XHRzdHJ1Y3R1cmVzLm5leHRJZCA9IHJlY29yZElkICsgMVxuXHRcdFx0fVxuXHRcdFx0bGV0IGhpZ2hCeXRlID0ga2V5cy5oaWdoQnl0ZSA9IHJlY29yZElkID49IDB4NjAgJiYgdXNlVHdvQnl0ZVJlY29yZHMgPyAocmVjb3JkSWQgLSAweDYwKSA+PiA1IDogLTFcblx0XHRcdHRyYW5zaXRpb25bUkVDT1JEX1NZTUJPTF0gPSByZWNvcmRJZFxuXHRcdFx0dHJhbnNpdGlvbi5fX2tleXNfXyA9IGtleXNcblx0XHRcdHN0cnVjdHVyZXNbcmVjb3JkSWQgLSAweDQwXSA9IGtleXNcblxuXHRcdFx0aWYgKHJlY29yZElkIDwgc2hhcmVkTGltaXRJZCkge1xuXHRcdFx0XHRrZXlzLmlzU2hhcmVkID0gdHJ1ZVxuXHRcdFx0XHRzdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCA9IHJlY29yZElkIC0gMHgzZlxuXHRcdFx0XHRoYXNTaGFyZWRVcGRhdGUgPSB0cnVlXG5cdFx0XHRcdGlmIChoaWdoQnl0ZSA+PSAwKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKHJlY29yZElkICYgMHgxZikgKyAweDYwXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gaGlnaEJ5dGVcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSByZWNvcmRJZFxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoaGlnaEJ5dGUgPj0gMCkge1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDUgLy8gZml4ZXh0IDJcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDcyIC8vIFwiclwiIHJlY29yZCBkZWZpbnRpb24gZXh0ZW5zaW9uIHR5cGVcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAocmVjb3JkSWQgJiAweDFmKSArIDB4NjBcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBoaWdoQnl0ZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDQgLy8gZml4ZXh0IDFcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDcyIC8vIFwiclwiIHJlY29yZCBkZWZpbnRpb24gZXh0ZW5zaW9uIHR5cGVcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSByZWNvcmRJZFxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG5ld1RyYW5zaXRpb25zKVxuXHRcdFx0XHRcdHRyYW5zaXRpb25zQ291bnQgKz0gc2VyaWFsaXphdGlvbnNTaW5jZVRyYW5zaXRpb25SZWJ1aWxkICogbmV3VHJhbnNpdGlvbnNcblx0XHRcdFx0Ly8gcmVjb3JkIHRoZSByZW1vdmFsIG9mIHRoZSBpZCwgd2UgY2FuIG1haW50YWluIG91ciBzaGFyZWQgc3RydWN0dXJlXG5cdFx0XHRcdGlmIChyZWNvcmRJZHNUb1JlbW92ZS5sZW5ndGggPj0gbWF4T3duU3RydWN0dXJlcylcblx0XHRcdFx0XHRyZWNvcmRJZHNUb1JlbW92ZS5zaGlmdCgpW1JFQ09SRF9TWU1CT0xdID0gMCAvLyB3ZSBhcmUgY3ljbGluZyBiYWNrIHRocm91Z2gsIGFuZCBoYXZlIHRvIHJlbW92ZSBvbGQgb25lc1xuXHRcdFx0XHRyZWNvcmRJZHNUb1JlbW92ZS5wdXNoKHRyYW5zaXRpb24pXG5cdFx0XHRcdHBhY2soa2V5cylcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3QgaW5zZXJ0TmV3UmVjb3JkID0gKHRyYW5zaXRpb24sIGtleXMsIGluc2VydGlvbk9mZnNldCwgbmV3VHJhbnNpdGlvbnMpID0+IHtcblx0XHRcdGxldCBtYWluVGFyZ2V0ID0gdGFyZ2V0XG5cdFx0XHRsZXQgbWFpblBvc2l0aW9uID0gcG9zaXRpb25cblx0XHRcdGxldCBtYWluU2FmZUVuZCA9IHNhZmVFbmRcblx0XHRcdGxldCBtYWluU3RhcnQgPSBzdGFydFxuXHRcdFx0dGFyZ2V0ID0ga2V5c1RhcmdldFxuXHRcdFx0cG9zaXRpb24gPSAwXG5cdFx0XHRzdGFydCA9IDBcblx0XHRcdGlmICghdGFyZ2V0KVxuXHRcdFx0XHRrZXlzVGFyZ2V0ID0gdGFyZ2V0ID0gbmV3IEJ5dGVBcnJheUFsbG9jYXRlKDgxOTIpXG5cdFx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwXG5cdFx0XHRuZXdSZWNvcmQodHJhbnNpdGlvbiwga2V5cywgbmV3VHJhbnNpdGlvbnMpXG5cdFx0XHRrZXlzVGFyZ2V0ID0gdGFyZ2V0XG5cdFx0XHRsZXQga2V5c1Bvc2l0aW9uID0gcG9zaXRpb25cblx0XHRcdHRhcmdldCA9IG1haW5UYXJnZXRcblx0XHRcdHBvc2l0aW9uID0gbWFpblBvc2l0aW9uXG5cdFx0XHRzYWZlRW5kID0gbWFpblNhZmVFbmRcblx0XHRcdHN0YXJ0ID0gbWFpblN0YXJ0XG5cdFx0XHRpZiAoa2V5c1Bvc2l0aW9uID4gMSkge1xuXHRcdFx0XHRsZXQgbmV3RW5kID0gcG9zaXRpb24gKyBrZXlzUG9zaXRpb24gLSAxXG5cdFx0XHRcdGlmIChuZXdFbmQgPiBzYWZlRW5kKVxuXHRcdFx0XHRcdG1ha2VSb29tKG5ld0VuZClcblx0XHRcdFx0bGV0IGluc2VydGlvblBvc2l0aW9uID0gaW5zZXJ0aW9uT2Zmc2V0ICsgc3RhcnRcblx0XHRcdFx0dGFyZ2V0LmNvcHlXaXRoaW4oaW5zZXJ0aW9uUG9zaXRpb24gKyBrZXlzUG9zaXRpb24sIGluc2VydGlvblBvc2l0aW9uICsgMSwgcG9zaXRpb24pXG5cdFx0XHRcdHRhcmdldC5zZXQoa2V5c1RhcmdldC5zbGljZSgwLCBrZXlzUG9zaXRpb24pLCBpbnNlcnRpb25Qb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gPSBuZXdFbmRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhcmdldFtpbnNlcnRpb25PZmZzZXQgKyBzdGFydF0gPSBrZXlzVGFyZ2V0WzBdXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnN0IHdyaXRlU3RydWN0ID0gKG9iamVjdCkgPT4ge1xuXHRcdFx0bGV0IG5ld1Bvc2l0aW9uID0gd3JpdGVTdHJ1Y3RTbG90cyhvYmplY3QsIHRhcmdldCwgc3RhcnQsIHBvc2l0aW9uLCBzdHJ1Y3R1cmVzLCBtYWtlUm9vbSwgKHZhbHVlLCBuZXdQb3NpdGlvbiwgbm90aWZ5U2hhcmVkVXBkYXRlKSA9PiB7XG5cdFx0XHRcdGlmIChub3RpZnlTaGFyZWRVcGRhdGUpXG5cdFx0XHRcdFx0cmV0dXJuIGhhc1NoYXJlZFVwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdHBvc2l0aW9uID0gbmV3UG9zaXRpb247XG5cdFx0XHRcdGxldCBzdGFydFRhcmdldCA9IHRhcmdldDtcblx0XHRcdFx0cGFjayh2YWx1ZSk7XG5cdFx0XHRcdHJlc2V0U3RydWN0dXJlcygpO1xuXHRcdFx0XHRpZiAoc3RhcnRUYXJnZXQgIT09IHRhcmdldCkge1xuXHRcdFx0XHRcdHJldHVybiB7IHBvc2l0aW9uLCB0YXJnZXRWaWV3LCB0YXJnZXQgfTsgLy8gaW5kaWNhdGUgdGhlIGJ1ZmZlciB3YXMgcmUtYWxsb2NhdGVkXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHBvc2l0aW9uO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0XHRpZiAobmV3UG9zaXRpb24gPT09IDApIC8vIGJhaWwgYW5kIGdvIHRvIGEgbXNncGFjayBvYmplY3Rcblx0XHRcdFx0cmV0dXJuIHdyaXRlT2JqZWN0KG9iamVjdCk7XG5cdFx0XHRwb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuXHRcdH1cblx0fVxuXHR1c2VCdWZmZXIoYnVmZmVyKSB7XG5cdFx0Ly8gdGhpcyBtZWFucyB3ZSBhcmUgZmluaXNoZWQgdXNpbmcgb3VyIG93biBidWZmZXIgYW5kIHdlIGNhbiB3cml0ZSBvdmVyIGl0IHNhZmVseVxuXHRcdHRhcmdldCA9IGJ1ZmZlclxuXHRcdHRhcmdldC5kYXRhVmlldyB8fCAodGFyZ2V0LmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHRhcmdldC5idWZmZXIsIHRhcmdldC5ieXRlT2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aCkpXG5cdFx0cG9zaXRpb24gPSAwXG5cdH1cblx0c2V0IHBvc2l0aW9uICh2YWx1ZSkge1xuXHRcdHBvc2l0aW9uID0gdmFsdWU7XG5cdH1cblx0Z2V0IHBvc2l0aW9uKCkge1xuXHRcdHJldHVybiBwb3NpdGlvbjtcblx0fVxuXHRzZXQgYnVmZmVyIChidWZmZXIpIHtcblx0XHR0YXJnZXQgPSBidWZmZXI7XG5cdH1cblx0Z2V0IGJ1ZmZlciAoKSB7XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fVxuXHRjbGVhclNoYXJlZERhdGEoKSB7XG5cdFx0aWYgKHRoaXMuc3RydWN0dXJlcylcblx0XHRcdHRoaXMuc3RydWN0dXJlcyA9IFtdXG5cdFx0aWYgKHRoaXMudHlwZWRTdHJ1Y3RzKVxuXHRcdFx0dGhpcy50eXBlZFN0cnVjdHMgPSBbXVxuXHR9XG59XG5cbmV4dGVuc2lvbkNsYXNzZXMgPSBbIERhdGUsIFNldCwgRXJyb3IsIFJlZ0V4cCwgQXJyYXlCdWZmZXIsIE9iamVjdC5nZXRQcm90b3R5cGVPZihVaW50OEFycmF5LnByb3RvdHlwZSkuY29uc3RydWN0b3IgLypUeXBlZEFycmF5Ki8sIEMxVHlwZSBdXG5leHRlbnNpb25zID0gW3tcblx0cGFjayhkYXRlLCBhbGxvY2F0ZUZvcldyaXRlLCBwYWNrKSB7XG5cdFx0bGV0IHNlY29uZHMgPSBkYXRlLmdldFRpbWUoKSAvIDEwMDBcblx0XHRpZiAoKHRoaXMudXNlVGltZXN0YW1wMzIgfHwgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSA9PT0gMCkgJiYgc2Vjb25kcyA+PSAwICYmIHNlY29uZHMgPCAweDEwMDAwMDAwMCkge1xuXHRcdFx0Ly8gVGltZXN0YW1wIDMyXG5cdFx0XHRsZXQgeyB0YXJnZXQsIHRhcmdldFZpZXcsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUoNilcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDZcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZmZcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBzZWNvbmRzKVxuXHRcdH0gZWxzZSBpZiAoc2Vjb25kcyA+IDAgJiYgc2Vjb25kcyA8IDB4MTAwMDAwMDAwKSB7XG5cdFx0XHQvLyBUaW1lc3RhbXAgNjRcblx0XHRcdGxldCB7IHRhcmdldCwgdGFyZ2V0VmlldywgcG9zaXRpb259ID0gYWxsb2NhdGVGb3JXcml0ZSgxMClcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDdcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZmZcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBkYXRlLmdldE1pbGxpc2Vjb25kcygpICogNDAwMDAwMCArICgoc2Vjb25kcyAvIDEwMDAgLyAweDEwMDAwMDAwMCkgPj4gMCkpXG5cdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiArIDQsIHNlY29uZHMpXG5cdFx0fSBlbHNlIGlmIChpc05hTihzZWNvbmRzKSkge1xuXHRcdFx0aWYgKHRoaXMub25JbnZhbGlkRGF0ZSkge1xuXHRcdFx0XHRhbGxvY2F0ZUZvcldyaXRlKDApXG5cdFx0XHRcdHJldHVybiBwYWNrKHRoaXMub25JbnZhbGlkRGF0ZSgpKVxuXHRcdFx0fVxuXHRcdFx0Ly8gSW50ZW50aW9uYWxseSBpbnZhbGlkIHRpbWVzdGFtcFxuXHRcdFx0bGV0IHsgdGFyZ2V0LCB0YXJnZXRWaWV3LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKDMpXG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGZmXG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGZmXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRpbWVzdGFtcCA5NlxuXHRcdFx0bGV0IHsgdGFyZ2V0LCB0YXJnZXRWaWV3LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKDE1KVxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjN1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMTJcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZmZcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBkYXRlLmdldE1pbGxpc2Vjb25kcygpICogMTAwMDAwMClcblx0XHRcdHRhcmdldFZpZXcuc2V0QmlnSW50NjQocG9zaXRpb24gKyA0LCBCaWdJbnQoTWF0aC5mbG9vcihzZWNvbmRzKSkpXG5cdFx0fVxuXHR9XG59LCB7XG5cdHBhY2soc2V0LCBhbGxvY2F0ZUZvcldyaXRlLCBwYWNrKSB7XG5cdFx0aWYgKHRoaXMuc2V0QXNFbXB0eU9iamVjdCkge1xuXHRcdFx0YWxsb2NhdGVGb3JXcml0ZSgwKTtcblx0XHRcdHJldHVybiBwYWNrKHt9KVxuXHRcdH1cblx0XHRsZXQgYXJyYXkgPSBBcnJheS5mcm9tKHNldClcblx0XHRsZXQgeyB0YXJnZXQsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUodGhpcy5tb3JlVHlwZXMgPyAzIDogMClcblx0XHRpZiAodGhpcy5tb3JlVHlwZXMpIHtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDRcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NzMgLy8gJ3MnIGZvciBTZXRcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDBcblx0XHR9XG5cdFx0cGFjayhhcnJheSlcblx0fVxufSwge1xuXHRwYWNrKGVycm9yLCBhbGxvY2F0ZUZvcldyaXRlLCBwYWNrKSB7XG5cdFx0bGV0IHsgdGFyZ2V0LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKHRoaXMubW9yZVR5cGVzID8gMyA6IDApXG5cdFx0aWYgKHRoaXMubW9yZVR5cGVzKSB7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDY1IC8vICdlJyBmb3IgZXJyb3Jcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDBcblx0XHR9XG5cdFx0cGFjayhbIGVycm9yLm5hbWUsIGVycm9yLm1lc3NhZ2UsIGVycm9yLmNhdXNlIF0pXG5cdH1cbn0sIHtcblx0cGFjayhyZWdleCwgYWxsb2NhdGVGb3JXcml0ZSwgcGFjaykge1xuXHRcdGxldCB7IHRhcmdldCwgcG9zaXRpb259ID0gYWxsb2NhdGVGb3JXcml0ZSh0aGlzLm1vcmVUeXBlcyA/IDMgOiAwKVxuXHRcdGlmICh0aGlzLm1vcmVUeXBlcykge1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNFxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg3OCAvLyAneCcgZm9yIHJlZ2VYcFxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMFxuXHRcdH1cblx0XHRwYWNrKFsgcmVnZXguc291cmNlLCByZWdleC5mbGFncyBdKVxuXHR9XG59LCB7XG5cdHBhY2soYXJyYXlCdWZmZXIsIGFsbG9jYXRlRm9yV3JpdGUpIHtcblx0XHRpZiAodGhpcy5tb3JlVHlwZXMpXG5cdFx0XHR3cml0ZUV4dEJ1ZmZlcihhcnJheUJ1ZmZlciwgMHgxMCwgYWxsb2NhdGVGb3JXcml0ZSlcblx0XHRlbHNlXG5cdFx0XHR3cml0ZUJ1ZmZlcihoYXNOb2RlQnVmZmVyID8gQnVmZmVyLmZyb20oYXJyYXlCdWZmZXIpIDogbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpLCBhbGxvY2F0ZUZvcldyaXRlKVxuXHR9XG59LCB7XG5cdHBhY2sodHlwZWRBcnJheSwgYWxsb2NhdGVGb3JXcml0ZSkge1xuXHRcdGxldCBjb25zdHJ1Y3RvciA9IHR5cGVkQXJyYXkuY29uc3RydWN0b3Jcblx0XHRpZiAoY29uc3RydWN0b3IgIT09IEJ5dGVBcnJheSAmJiB0aGlzLm1vcmVUeXBlcylcblx0XHRcdHdyaXRlRXh0QnVmZmVyKHR5cGVkQXJyYXksIHR5cGVkQXJyYXlzLmluZGV4T2YoY29uc3RydWN0b3IubmFtZSksIGFsbG9jYXRlRm9yV3JpdGUpXG5cdFx0ZWxzZVxuXHRcdFx0d3JpdGVCdWZmZXIodHlwZWRBcnJheSwgYWxsb2NhdGVGb3JXcml0ZSlcblx0fVxufSwge1xuXHRwYWNrKGMxLCBhbGxvY2F0ZUZvcldyaXRlKSB7IC8vIHNwZWNpZmljIDB4QzEgb2JqZWN0XG5cdFx0bGV0IHsgdGFyZ2V0LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKDEpXG5cdFx0dGFyZ2V0W3Bvc2l0aW9uXSA9IDB4YzFcblx0fVxufV1cblxuZnVuY3Rpb24gd3JpdGVFeHRCdWZmZXIodHlwZWRBcnJheSwgdHlwZSwgYWxsb2NhdGVGb3JXcml0ZSwgZW5jb2RlKSB7XG5cdGxldCBsZW5ndGggPSB0eXBlZEFycmF5LmJ5dGVMZW5ndGhcblx0aWYgKGxlbmd0aCArIDEgPCAweDEwMCkge1xuXHRcdHZhciB7IHRhcmdldCwgcG9zaXRpb24gfSA9IGFsbG9jYXRlRm9yV3JpdGUoNCArIGxlbmd0aClcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM3XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICsgMVxuXHR9IGVsc2UgaWYgKGxlbmd0aCArIDEgPCAweDEwMDAwKSB7XG5cdFx0dmFyIHsgdGFyZ2V0LCBwb3NpdGlvbiB9ID0gYWxsb2NhdGVGb3JXcml0ZSg1ICsgbGVuZ3RoKVxuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzhcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAobGVuZ3RoICsgMSkgPj4gOFxuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IChsZW5ndGggKyAxKSAmIDB4ZmZcblx0fSBlbHNlIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uLCB0YXJnZXRWaWV3IH0gPSBhbGxvY2F0ZUZvcldyaXRlKDcgKyBsZW5ndGgpXG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjOVxuXHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBsZW5ndGggKyAxKSAvLyBwbHVzIG9uZSBmb3IgdGhlIHR5cGUgYnl0ZVxuXHRcdHBvc2l0aW9uICs9IDRcblx0fVxuXHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDc0IC8vIFwidFwiIGZvciB0eXBlZCBhcnJheVxuXHR0YXJnZXRbcG9zaXRpb24rK10gPSB0eXBlXG5cdGlmICghdHlwZWRBcnJheS5idWZmZXIpIHR5cGVkQXJyYXkgPSBuZXcgVWludDhBcnJheSh0eXBlZEFycmF5KVxuXHR0YXJnZXQuc2V0KG5ldyBVaW50OEFycmF5KHR5cGVkQXJyYXkuYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkuYnl0ZUxlbmd0aCksIHBvc2l0aW9uKVxufVxuZnVuY3Rpb24gd3JpdGVCdWZmZXIoYnVmZmVyLCBhbGxvY2F0ZUZvcldyaXRlKSB7XG5cdGxldCBsZW5ndGggPSBidWZmZXIuYnl0ZUxlbmd0aFxuXHR2YXIgdGFyZ2V0LCBwb3NpdGlvblxuXHRpZiAobGVuZ3RoIDwgMHgxMDApIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uIH0gPSBhbGxvY2F0ZUZvcldyaXRlKGxlbmd0aCArIDIpXG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjNFxuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aFxuXHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uIH0gPSBhbGxvY2F0ZUZvcldyaXRlKGxlbmd0aCArIDMpXG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjNVxuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCA+PiA4XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZlxuXHR9IGVsc2Uge1xuXHRcdHZhciB7IHRhcmdldCwgcG9zaXRpb24sIHRhcmdldFZpZXcgfSA9IGFsbG9jYXRlRm9yV3JpdGUobGVuZ3RoICsgNSlcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM2XG5cdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGxlbmd0aClcblx0XHRwb3NpdGlvbiArPSA0XG5cdH1cblx0dGFyZ2V0LnNldChidWZmZXIsIHBvc2l0aW9uKVxufVxuXG5mdW5jdGlvbiB3cml0ZUV4dGVuc2lvbkRhdGEocmVzdWx0LCB0YXJnZXQsIHBvc2l0aW9uLCB0eXBlKSB7XG5cdGxldCBsZW5ndGggPSByZXN1bHQubGVuZ3RoXG5cdHN3aXRjaCAobGVuZ3RoKSB7XG5cdFx0Y2FzZSAxOlxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNFxuXHRcdFx0YnJlYWtcblx0XHRjYXNlIDI6XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ1XG5cdFx0XHRicmVha1xuXHRcdGNhc2UgNDpcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDZcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSA4OlxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkN1xuXHRcdFx0YnJlYWtcblx0XHRjYXNlIDE2OlxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkOFxuXHRcdFx0YnJlYWtcblx0XHRkZWZhdWx0OlxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwKSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzdcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoXG5cdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjOFxuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggPj4gOFxuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggJiAweGZmXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM5XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCA+PiAyNFxuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAobGVuZ3RoID4+IDE2KSAmIDB4ZmZcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKGxlbmd0aCA+PiA4KSAmIDB4ZmZcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZlxuXHRcdFx0fVxuXHR9XG5cdHRhcmdldFtwb3NpdGlvbisrXSA9IHR5cGVcblx0dGFyZ2V0LnNldChyZXN1bHQsIHBvc2l0aW9uKVxuXHRwb3NpdGlvbiArPSBsZW5ndGhcblx0cmV0dXJuIHBvc2l0aW9uXG59XG5cbmZ1bmN0aW9uIGluc2VydElkcyhzZXJpYWxpemVkLCBpZHNUb0luc2VydCkge1xuXHQvLyBpbnNlcnQgdGhlIGlkcyB0aGF0IG5lZWQgdG8gYmUgcmVmZXJlbmNlZCBmb3Igc3RydWN0dXJlZCBjbG9uZXNcblx0bGV0IG5leHRJZFxuXHRsZXQgZGlzdGFuY2VUb01vdmUgPSBpZHNUb0luc2VydC5sZW5ndGggKiA2XG5cdGxldCBsYXN0RW5kID0gc2VyaWFsaXplZC5sZW5ndGggLSBkaXN0YW5jZVRvTW92ZVxuXHR3aGlsZSAobmV4dElkID0gaWRzVG9JbnNlcnQucG9wKCkpIHtcblx0XHRsZXQgb2Zmc2V0ID0gbmV4dElkLm9mZnNldFxuXHRcdGxldCBpZCA9IG5leHRJZC5pZFxuXHRcdHNlcmlhbGl6ZWQuY29weVdpdGhpbihvZmZzZXQgKyBkaXN0YW5jZVRvTW92ZSwgb2Zmc2V0LCBsYXN0RW5kKVxuXHRcdGRpc3RhbmNlVG9Nb3ZlIC09IDZcblx0XHRsZXQgcG9zaXRpb24gPSBvZmZzZXQgKyBkaXN0YW5jZVRvTW92ZVxuXHRcdHNlcmlhbGl6ZWRbcG9zaXRpb24rK10gPSAweGQ2XG5cdFx0c2VyaWFsaXplZFtwb3NpdGlvbisrXSA9IDB4NjkgLy8gJ2knXG5cdFx0c2VyaWFsaXplZFtwb3NpdGlvbisrXSA9IGlkID4+IDI0XG5cdFx0c2VyaWFsaXplZFtwb3NpdGlvbisrXSA9IChpZCA+PiAxNikgJiAweGZmXG5cdFx0c2VyaWFsaXplZFtwb3NpdGlvbisrXSA9IChpZCA+PiA4KSAmIDB4ZmZcblx0XHRzZXJpYWxpemVkW3Bvc2l0aW9uKytdID0gaWQgJiAweGZmXG5cdFx0bGFzdEVuZCA9IG9mZnNldFxuXHR9XG5cdHJldHVybiBzZXJpYWxpemVkXG59XG5cbmZ1bmN0aW9uIHdyaXRlQnVuZGxlcyhzdGFydCwgcGFjaywgaW5jcmVtZW50UG9zaXRpb24pIHtcblx0aWYgKGJ1bmRsZWRTdHJpbmdzLmxlbmd0aCA+IDApIHtcblx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihidW5kbGVkU3RyaW5ncy5wb3NpdGlvbiArIHN0YXJ0LCBwb3NpdGlvbiArIGluY3JlbWVudFBvc2l0aW9uIC0gYnVuZGxlZFN0cmluZ3MucG9zaXRpb24gLSBzdGFydClcblx0XHRidW5kbGVkU3RyaW5ncy5zdHJpbmdzUG9zaXRpb24gPSBwb3NpdGlvbiAtIHN0YXJ0O1xuXHRcdGxldCB3cml0ZVN0cmluZ3MgPSBidW5kbGVkU3RyaW5nc1xuXHRcdGJ1bmRsZWRTdHJpbmdzID0gbnVsbFxuXHRcdHBhY2sod3JpdGVTdHJpbmdzWzBdKVxuXHRcdHBhY2sod3JpdGVTdHJpbmdzWzFdKVxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRFeHRlbnNpb24oZXh0ZW5zaW9uKSB7XG5cdGlmIChleHRlbnNpb24uQ2xhc3MpIHtcblx0XHRpZiAoIWV4dGVuc2lvbi5wYWNrICYmICFleHRlbnNpb24ud3JpdGUpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0V4dGVuc2lvbiBoYXMgbm8gcGFjayBvciB3cml0ZSBmdW5jdGlvbicpXG5cdFx0aWYgKGV4dGVuc2lvbi5wYWNrICYmICFleHRlbnNpb24udHlwZSlcblx0XHRcdHRocm93IG5ldyBFcnJvcignRXh0ZW5zaW9uIGhhcyBubyB0eXBlIChudW1lcmljIGNvZGUgdG8gaWRlbnRpZnkgdGhlIGV4dGVuc2lvbiknKVxuXHRcdGV4dGVuc2lvbkNsYXNzZXMudW5zaGlmdChleHRlbnNpb24uQ2xhc3MpXG5cdFx0ZXh0ZW5zaW9ucy51bnNoaWZ0KGV4dGVuc2lvbilcblx0fVxuXHR1bnBhY2tBZGRFeHRlbnNpb24oZXh0ZW5zaW9uKVxufVxuZnVuY3Rpb24gcHJlcGFyZVN0cnVjdHVyZXMoc3RydWN0dXJlcywgcGFja3IpIHtcblx0c3RydWN0dXJlcy5pc0NvbXBhdGlibGUgPSAoZXhpc3RpbmdTdHJ1Y3R1cmVzKSA9PiB7XG5cdFx0bGV0IGNvbXBhdGlibGUgPSAhZXhpc3RpbmdTdHJ1Y3R1cmVzIHx8ICgocGFja3IubGFzdE5hbWVkU3RydWN0dXJlc0xlbmd0aCB8fCAwKSA9PT0gZXhpc3RpbmdTdHJ1Y3R1cmVzLmxlbmd0aClcblx0XHRpZiAoIWNvbXBhdGlibGUpIC8vIHdlIHdhbnQgdG8gbWVyZ2UgdGhlc2UgZXhpc3Rpbmcgc3RydWN0dXJlcyBpbW1lZGlhdGVseSBzaW5jZSB3ZSBhbHJlYWR5IGhhdmUgaXQgYW5kIHdlIGFyZSBpbiB0aGUgcmlnaHQgdHJhbnNhY3Rpb25cblx0XHRcdHBhY2tyLl9tZXJnZVN0cnVjdHVyZXMoZXhpc3RpbmdTdHJ1Y3R1cmVzKTtcblx0XHRyZXR1cm4gY29tcGF0aWJsZTtcblx0fVxuXHRyZXR1cm4gc3RydWN0dXJlc1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldFdyaXRlU3RydWN0U2xvdHMod3JpdGVTbG90cywgbWFrZVN0cnVjdHVyZXMpIHtcblx0d3JpdGVTdHJ1Y3RTbG90cyA9IHdyaXRlU2xvdHM7XG5cdHByZXBhcmVTdHJ1Y3R1cmVzID0gbWFrZVN0cnVjdHVyZXM7XG59XG5cbmxldCBkZWZhdWx0UGFja3IgPSBuZXcgUGFja3IoeyB1c2VSZWNvcmRzOiBmYWxzZSB9KVxuZXhwb3J0IGNvbnN0IHBhY2sgPSBkZWZhdWx0UGFja3IucGFja1xuZXhwb3J0IGNvbnN0IGVuY29kZSA9IGRlZmF1bHRQYWNrci5wYWNrXG5leHBvcnQgY29uc3QgRW5jb2RlciA9IFBhY2tyXG5leHBvcnQgeyBGTE9BVDMyX09QVElPTlMgfSBmcm9tICcuL3VucGFjay5qcydcbmltcG9ydCB7IEZMT0FUMzJfT1BUSU9OUyB9IGZyb20gJy4vdW5wYWNrLmpzJ1xuZXhwb3J0IGNvbnN0IHsgTkVWRVIsIEFMV0FZUywgREVDSU1BTF9ST1VORCwgREVDSU1BTF9GSVQgfSA9IEZMT0FUMzJfT1BUSU9OU1xuZXhwb3J0IGNvbnN0IFJFVVNFX0JVRkZFUl9NT0RFID0gNTEyXG5leHBvcnQgY29uc3QgUkVTRVRfQlVGRkVSX01PREUgPSAxMDI0XG5leHBvcnQgY29uc3QgUkVTRVJWRV9TVEFSVF9TUEFDRSA9IDIwNDhcbiIsInZhciBkZWNvZGVyXG50cnkge1xuXHRkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbn0gY2F0Y2goZXJyb3IpIHt9XG52YXIgc3JjXG52YXIgc3JjRW5kXG52YXIgcG9zaXRpb24gPSAwXG52YXIgYWxyZWFkeVNldFxuY29uc3QgRU1QVFlfQVJSQVkgPSBbXVxudmFyIHN0cmluZ3MgPSBFTVBUWV9BUlJBWVxudmFyIHN0cmluZ1Bvc2l0aW9uID0gMFxudmFyIGN1cnJlbnRVbnBhY2tyID0ge31cbnZhciBjdXJyZW50U3RydWN0dXJlc1xudmFyIHNyY1N0cmluZ1xudmFyIHNyY1N0cmluZ1N0YXJ0ID0gMFxudmFyIHNyY1N0cmluZ0VuZCA9IDBcbnZhciBidW5kbGVkU3RyaW5nc1xudmFyIHJlZmVyZW5jZU1hcFxudmFyIGN1cnJlbnRFeHRlbnNpb25zID0gW11cbnZhciBkYXRhVmlld1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuXHR1c2VSZWNvcmRzOiBmYWxzZSxcblx0bWFwc0FzT2JqZWN0czogdHJ1ZVxufVxuZXhwb3J0IGNsYXNzIEMxVHlwZSB7fVxuZXhwb3J0IGNvbnN0IEMxID0gbmV3IEMxVHlwZSgpXG5DMS5uYW1lID0gJ01lc3NhZ2VQYWNrIDB4QzEnXG52YXIgc2VxdWVudGlhbE1vZGUgPSBmYWxzZVxudmFyIGlubGluZU9iamVjdFJlYWRUaHJlc2hvbGQgPSAyXG52YXIgcmVhZFN0cnVjdCwgb25Mb2FkZWRTdHJ1Y3R1cmVzLCBvblNhdmVTdGF0ZVxudmFyIEJsb2NrZWRGdW5jdGlvbiAvLyB3ZSB1c2Ugc2VhcmNoIGFuZCByZXBsYWNlIHRvIGNoYW5nZSB0aGUgbmV4dCBjYWxsIHRvIEJsb2NrZWRGdW5jdGlvbiB0byBhdm9pZCBDU1AgaXNzdWVzIGZvclxuLy8gbm8tZXZhbCBidWlsZFxudHJ5IHtcblx0bmV3IEZ1bmN0aW9uKCcnKVxufSBjYXRjaChlcnJvcikge1xuXHQvLyBpZiBldmFsIHZhcmlhbnRzIGFyZSBub3Qgc3VwcG9ydGVkLCBkbyBub3QgY3JlYXRlIGlubGluZSBvYmplY3QgcmVhZGVycyBldmVyXG5cdGlubGluZU9iamVjdFJlYWRUaHJlc2hvbGQgPSBJbmZpbml0eVxufVxuXG5leHBvcnQgY2xhc3MgVW5wYWNrciB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9ucykge1xuXHRcdFx0aWYgKG9wdGlvbnMudXNlUmVjb3JkcyA9PT0gZmFsc2UgJiYgb3B0aW9ucy5tYXBzQXNPYmplY3RzID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdG9wdGlvbnMubWFwc0FzT2JqZWN0cyA9IHRydWVcblx0XHRcdGlmIChvcHRpb25zLnNlcXVlbnRpYWwgJiYgb3B0aW9ucy50cnVzdGVkICE9PSBmYWxzZSkge1xuXHRcdFx0XHRvcHRpb25zLnRydXN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRpZiAoIW9wdGlvbnMuc3RydWN0dXJlcyAmJiBvcHRpb25zLnVzZVJlY29yZHMgIT0gZmFsc2UpIHtcblx0XHRcdFx0XHRvcHRpb25zLnN0cnVjdHVyZXMgPSBbXVxuXHRcdFx0XHRcdGlmICghb3B0aW9ucy5tYXhTaGFyZWRTdHJ1Y3R1cmVzKVxuXHRcdFx0XHRcdFx0b3B0aW9ucy5tYXhTaGFyZWRTdHJ1Y3R1cmVzID0gMFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0aW9ucy5zdHJ1Y3R1cmVzKVxuXHRcdFx0XHRvcHRpb25zLnN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoID0gb3B0aW9ucy5zdHJ1Y3R1cmVzLmxlbmd0aFxuXHRcdFx0ZWxzZSBpZiAob3B0aW9ucy5nZXRTdHJ1Y3R1cmVzKSB7XG5cdFx0XHRcdChvcHRpb25zLnN0cnVjdHVyZXMgPSBbXSkudW5pbml0aWFsaXplZCA9IHRydWUgLy8gdGhpcyBpcyB3aGF0IHdlIHVzZSB0byBkZW5vdGUgYW4gdW5pbml0aWFsaXplZCBzdHJ1Y3R1cmVzXG5cdFx0XHRcdG9wdGlvbnMuc3RydWN0dXJlcy5zaGFyZWRMZW5ndGggPSAwXG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0aW9ucy5pbnQ2NEFzTnVtYmVyKSB7XG5cdFx0XHRcdG9wdGlvbnMuaW50NjRBc1R5cGUgPSAnbnVtYmVyJ1xuXHRcdFx0fVxuXHRcdH1cblx0XHRPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpXG5cdH1cblx0dW5wYWNrKHNvdXJjZSwgb3B0aW9ucykge1xuXHRcdGlmIChzcmMpIHtcblx0XHRcdC8vIHJlLWVudHJhbnQgZXhlY3V0aW9uLCBzYXZlIHRoZSBzdGF0ZSBhbmQgcmVzdG9yZSBpdCBhZnRlciB3ZSBkbyB0aGlzIHVucGFja1xuXHRcdFx0cmV0dXJuIHNhdmVTdGF0ZSgoKSA9PiB7XG5cdFx0XHRcdGNsZWFyU291cmNlKClcblx0XHRcdFx0cmV0dXJuIHRoaXMgPyB0aGlzLnVucGFjayhzb3VyY2UsIG9wdGlvbnMpIDogVW5wYWNrci5wcm90b3R5cGUudW5wYWNrLmNhbGwoZGVmYXVsdE9wdGlvbnMsIHNvdXJjZSwgb3B0aW9ucylcblx0XHRcdH0pXG5cdFx0fVxuXHRcdGlmICghc291cmNlLmJ1ZmZlciAmJiBzb3VyY2UuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKVxuXHRcdFx0c291cmNlID0gdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgPyBCdWZmZXIuZnJvbShzb3VyY2UpIDogbmV3IFVpbnQ4QXJyYXkoc291cmNlKTtcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRzcmNFbmQgPSBvcHRpb25zLmVuZCB8fCBzb3VyY2UubGVuZ3RoXG5cdFx0XHRwb3NpdGlvbiA9IG9wdGlvbnMuc3RhcnQgfHwgMFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRwb3NpdGlvbiA9IDBcblx0XHRcdHNyY0VuZCA9IG9wdGlvbnMgPiAtMSA/IG9wdGlvbnMgOiBzb3VyY2UubGVuZ3RoXG5cdFx0fVxuXHRcdHN0cmluZ1Bvc2l0aW9uID0gMFxuXHRcdHNyY1N0cmluZ0VuZCA9IDBcblx0XHRzcmNTdHJpbmcgPSBudWxsXG5cdFx0c3RyaW5ncyA9IEVNUFRZX0FSUkFZXG5cdFx0YnVuZGxlZFN0cmluZ3MgPSBudWxsXG5cdFx0c3JjID0gc291cmNlXG5cdFx0Ly8gdGhpcyBwcm92aWRlcyBjYWNoZWQgYWNjZXNzIHRvIHRoZSBkYXRhIHZpZXcgZm9yIGEgYnVmZmVyIGlmIGl0IGlzIGdldHRpbmcgcmV1c2VkLCB3aGljaCBpcyBhIHJlY29tbWVuZFxuXHRcdC8vIHRlY2huaXF1ZSBmb3IgZ2V0dGluZyBkYXRhIGZyb20gYSBkYXRhYmFzZSB3aGVyZSBpdCBjYW4gYmUgY29waWVkIGludG8gYW4gZXhpc3RpbmcgYnVmZmVyIGluc3RlYWQgb2YgY3JlYXRpbmdcblx0XHQvLyBuZXcgb25lc1xuXHRcdHRyeSB7XG5cdFx0XHRkYXRhVmlldyA9IHNvdXJjZS5kYXRhVmlldyB8fCAoc291cmNlLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNvdXJjZS5idWZmZXIsIHNvdXJjZS5ieXRlT2Zmc2V0LCBzb3VyY2UuYnl0ZUxlbmd0aCkpXG5cdFx0fSBjYXRjaChlcnJvcikge1xuXHRcdFx0Ly8gaWYgaXQgZG9lc24ndCBoYXZlIGEgYnVmZmVyLCBtYXliZSBpdCBpcyB0aGUgd3JvbmcgdHlwZSBvZiBvYmplY3Rcblx0XHRcdHNyYyA9IG51bGxcblx0XHRcdGlmIChzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuXHRcdFx0XHR0aHJvdyBlcnJvclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgbXVzdCBiZSBhIFVpbnQ4QXJyYXkgb3IgQnVmZmVyIGJ1dCB3YXMgYSAnICsgKChzb3VyY2UgJiYgdHlwZW9mIHNvdXJjZSA9PSAnb2JqZWN0JykgPyBzb3VyY2UuY29uc3RydWN0b3IubmFtZSA6IHR5cGVvZiBzb3VyY2UpKVxuXHRcdH1cblx0XHRpZiAodGhpcyBpbnN0YW5jZW9mIFVucGFja3IpIHtcblx0XHRcdGN1cnJlbnRVbnBhY2tyID0gdGhpc1xuXHRcdFx0aWYgKHRoaXMuc3RydWN0dXJlcykge1xuXHRcdFx0XHRjdXJyZW50U3RydWN0dXJlcyA9IHRoaXMuc3RydWN0dXJlc1xuXHRcdFx0XHRyZXR1cm4gY2hlY2tlZFJlYWQob3B0aW9ucylcblx0XHRcdH0gZWxzZSBpZiAoIWN1cnJlbnRTdHJ1Y3R1cmVzIHx8IGN1cnJlbnRTdHJ1Y3R1cmVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y3VycmVudFN0cnVjdHVyZXMgPSBbXVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJyZW50VW5wYWNrciA9IGRlZmF1bHRPcHRpb25zXG5cdFx0XHRpZiAoIWN1cnJlbnRTdHJ1Y3R1cmVzIHx8IGN1cnJlbnRTdHJ1Y3R1cmVzLmxlbmd0aCA+IDApXG5cdFx0XHRcdGN1cnJlbnRTdHJ1Y3R1cmVzID0gW11cblx0XHR9XG5cdFx0cmV0dXJuIGNoZWNrZWRSZWFkKG9wdGlvbnMpXG5cdH1cblx0dW5wYWNrTXVsdGlwbGUoc291cmNlLCBmb3JFYWNoKSB7XG5cdFx0bGV0IHZhbHVlcywgbGFzdFBvc2l0aW9uID0gMFxuXHRcdHRyeSB7XG5cdFx0XHRzZXF1ZW50aWFsTW9kZSA9IHRydWVcblx0XHRcdGxldCBzaXplID0gc291cmNlLmxlbmd0aFxuXHRcdFx0bGV0IHZhbHVlID0gdGhpcyA/IHRoaXMudW5wYWNrKHNvdXJjZSwgc2l6ZSkgOiBkZWZhdWx0VW5wYWNrci51bnBhY2soc291cmNlLCBzaXplKVxuXHRcdFx0aWYgKGZvckVhY2gpIHtcblx0XHRcdFx0aWYgKGZvckVhY2godmFsdWUsIGxhc3RQb3NpdGlvbiwgcG9zaXRpb24pID09PSBmYWxzZSkgcmV0dXJuO1xuXHRcdFx0XHR3aGlsZShwb3NpdGlvbiA8IHNpemUpIHtcblx0XHRcdFx0XHRsYXN0UG9zaXRpb24gPSBwb3NpdGlvblxuXHRcdFx0XHRcdGlmIChmb3JFYWNoKGNoZWNrZWRSZWFkKCksIGxhc3RQb3NpdGlvbiwgcG9zaXRpb24pID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dmFsdWVzID0gWyB2YWx1ZSBdXG5cdFx0XHRcdHdoaWxlKHBvc2l0aW9uIDwgc2l6ZSkge1xuXHRcdFx0XHRcdGxhc3RQb3NpdGlvbiA9IHBvc2l0aW9uXG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goY2hlY2tlZFJlYWQoKSlcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzXG5cdFx0XHR9XG5cdFx0fSBjYXRjaChlcnJvcikge1xuXHRcdFx0ZXJyb3IubGFzdFBvc2l0aW9uID0gbGFzdFBvc2l0aW9uXG5cdFx0XHRlcnJvci52YWx1ZXMgPSB2YWx1ZXNcblx0XHRcdHRocm93IGVycm9yXG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNlcXVlbnRpYWxNb2RlID0gZmFsc2Vcblx0XHRcdGNsZWFyU291cmNlKClcblx0XHR9XG5cdH1cblx0X21lcmdlU3RydWN0dXJlcyhsb2FkZWRTdHJ1Y3R1cmVzLCBleGlzdGluZ1N0cnVjdHVyZXMpIHtcblx0XHRpZiAob25Mb2FkZWRTdHJ1Y3R1cmVzKVxuXHRcdFx0bG9hZGVkU3RydWN0dXJlcyA9IG9uTG9hZGVkU3RydWN0dXJlcy5jYWxsKHRoaXMsIGxvYWRlZFN0cnVjdHVyZXMpO1xuXHRcdGxvYWRlZFN0cnVjdHVyZXMgPSBsb2FkZWRTdHJ1Y3R1cmVzIHx8IFtdXG5cdFx0aWYgKE9iamVjdC5pc0Zyb3plbihsb2FkZWRTdHJ1Y3R1cmVzKSlcblx0XHRcdGxvYWRlZFN0cnVjdHVyZXMgPSBsb2FkZWRTdHJ1Y3R1cmVzLm1hcChzdHJ1Y3R1cmUgPT4gc3RydWN0dXJlLnNsaWNlKDApKVxuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gbG9hZGVkU3RydWN0dXJlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGxldCBzdHJ1Y3R1cmUgPSBsb2FkZWRTdHJ1Y3R1cmVzW2ldXG5cdFx0XHRpZiAoc3RydWN0dXJlKSB7XG5cdFx0XHRcdHN0cnVjdHVyZS5pc1NoYXJlZCA9IHRydWVcblx0XHRcdFx0aWYgKGkgPj0gMzIpXG5cdFx0XHRcdFx0c3RydWN0dXJlLmhpZ2hCeXRlID0gKGkgLSAzMikgPj4gNVxuXHRcdFx0fVxuXHRcdH1cblx0XHRsb2FkZWRTdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCA9IGxvYWRlZFN0cnVjdHVyZXMubGVuZ3RoXG5cdFx0Zm9yIChsZXQgaWQgaW4gZXhpc3RpbmdTdHJ1Y3R1cmVzIHx8IFtdKSB7XG5cdFx0XHRpZiAoaWQgPj0gMCkge1xuXHRcdFx0XHRsZXQgc3RydWN0dXJlID0gbG9hZGVkU3RydWN0dXJlc1tpZF1cblx0XHRcdFx0bGV0IGV4aXN0aW5nID0gZXhpc3RpbmdTdHJ1Y3R1cmVzW2lkXVxuXHRcdFx0XHRpZiAoZXhpc3RpbmcpIHtcblx0XHRcdFx0XHRpZiAoc3RydWN0dXJlKVxuXHRcdFx0XHRcdFx0KGxvYWRlZFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMgfHwgKGxvYWRlZFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMgPSBbXSkpW2lkXSA9IHN0cnVjdHVyZVxuXHRcdFx0XHRcdGxvYWRlZFN0cnVjdHVyZXNbaWRdID0gZXhpc3Rpbmdcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5zdHJ1Y3R1cmVzID0gbG9hZGVkU3RydWN0dXJlc1xuXHR9XG5cdGRlY29kZShzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gdGhpcy51bnBhY2soc291cmNlLCBvcHRpb25zKVxuXHR9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9zaXRpb24oKSB7XG5cdHJldHVybiBwb3NpdGlvblxufVxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrZWRSZWFkKG9wdGlvbnMpIHtcblx0dHJ5IHtcblx0XHRpZiAoIWN1cnJlbnRVbnBhY2tyLnRydXN0ZWQgJiYgIXNlcXVlbnRpYWxNb2RlKSB7XG5cdFx0XHRsZXQgc2hhcmVkTGVuZ3RoID0gY3VycmVudFN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoIHx8IDBcblx0XHRcdGlmIChzaGFyZWRMZW5ndGggPCBjdXJyZW50U3RydWN0dXJlcy5sZW5ndGgpXG5cdFx0XHRcdGN1cnJlbnRTdHJ1Y3R1cmVzLmxlbmd0aCA9IHNoYXJlZExlbmd0aFxuXHRcdH1cblx0XHRsZXQgcmVzdWx0XG5cdFx0aWYgKGN1cnJlbnRVbnBhY2tyLnJhbmRvbUFjY2Vzc1N0cnVjdHVyZSAmJiBzcmNbcG9zaXRpb25dIDwgMHg0MCAmJiBzcmNbcG9zaXRpb25dID49IDB4MjAgJiYgcmVhZFN0cnVjdCkge1xuXHRcdFx0cmVzdWx0ID0gcmVhZFN0cnVjdChzcmMsIHBvc2l0aW9uLCBzcmNFbmQsIGN1cnJlbnRVbnBhY2tyKVxuXHRcdFx0c3JjID0gbnVsbCAvLyBkaXNwb3NlIG9mIHRoaXMgc28gdGhhdCByZWN1cnNpdmUgdW5wYWNrIGNhbGxzIGRvbid0IHNhdmUgc3RhdGVcblx0XHRcdGlmICghKG9wdGlvbnMgJiYgb3B0aW9ucy5sYXp5KSAmJiByZXN1bHQpXG5cdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC50b0pTT04oKVxuXHRcdFx0cG9zaXRpb24gPSBzcmNFbmRcblx0XHR9IGVsc2Vcblx0XHRcdHJlc3VsdCA9IHJlYWQoKVxuXHRcdGlmIChidW5kbGVkU3RyaW5ncykgeyAvLyBidW5kbGVkIHN0cmluZ3MgdG8gc2tpcCBwYXN0XG5cdFx0XHRwb3NpdGlvbiA9IGJ1bmRsZWRTdHJpbmdzLnBvc3RCdW5kbGVQb3NpdGlvblxuXHRcdFx0YnVuZGxlZFN0cmluZ3MgPSBudWxsXG5cdFx0fVxuXHRcdGlmIChzZXF1ZW50aWFsTW9kZSlcblx0XHRcdC8vIHdlIG9ubHkgbmVlZCB0byByZXN0b3JlIHRoZSBzdHJ1Y3R1cmVzIGlmIHRoZXJlIHdhcyBhbiBlcnJvciwgYnV0IGlmIHdlIGNvbXBsZXRlZCBhIHJlYWQsXG5cdFx0XHQvLyB3ZSBjYW4gY2xlYXIgdGhpcyBvdXQgYW5kIGtlZXAgdGhlIHN0cnVjdHVyZXMgd2UgcmVhZFxuXHRcdFx0Y3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMgPSBudWxsXG5cblx0XHRpZiAocG9zaXRpb24gPT0gc3JjRW5kKSB7XG5cdFx0XHQvLyBmaW5pc2hlZCByZWFkaW5nIHRoaXMgc291cmNlLCBjbGVhbnVwIHJlZmVyZW5jZXNcblx0XHRcdGlmIChjdXJyZW50U3RydWN0dXJlcyAmJiBjdXJyZW50U3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlcylcblx0XHRcdFx0cmVzdG9yZVN0cnVjdHVyZXMoKVxuXHRcdFx0Y3VycmVudFN0cnVjdHVyZXMgPSBudWxsXG5cdFx0XHRzcmMgPSBudWxsXG5cdFx0XHRpZiAocmVmZXJlbmNlTWFwKVxuXHRcdFx0XHRyZWZlcmVuY2VNYXAgPSBudWxsXG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbiA+IHNyY0VuZCkge1xuXHRcdFx0Ly8gb3ZlciByZWFkXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIE1lc3NhZ2VQYWNrIGRhdGEnKVxuXHRcdH0gZWxzZSBpZiAoIXNlcXVlbnRpYWxNb2RlKSB7XG5cdFx0XHRsZXQganNvblZpZXc7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRqc29uVmlldyA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCwgKF8sIHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIgPyBgJHt2YWx1ZX1uYCA6IHZhbHVlKS5zbGljZSgwLCAxMDApXG5cdFx0XHR9IGNhdGNoKGVycm9yKSB7XG5cdFx0XHRcdGpzb25WaWV3ID0gJyhKU09OIHZpZXcgbm90IGF2YWlsYWJsZSAnICsgZXJyb3IgKyAnKSdcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvcignRGF0YSByZWFkLCBidXQgZW5kIG9mIGJ1ZmZlciBub3QgcmVhY2hlZCAnICsganNvblZpZXcpXG5cdFx0fVxuXHRcdC8vIGVsc2UgbW9yZSB0byByZWFkLCBidXQgd2UgYXJlIHJlYWRpbmcgc2VxdWVudGlhbGx5LCBzbyBkb24ndCBjbGVhciBzb3VyY2UgeWV0XG5cdFx0cmV0dXJuIHJlc3VsdFxuXHR9IGNhdGNoKGVycm9yKSB7XG5cdFx0aWYgKGN1cnJlbnRTdHJ1Y3R1cmVzICYmIGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzKVxuXHRcdFx0cmVzdG9yZVN0cnVjdHVyZXMoKVxuXHRcdGNsZWFyU291cmNlKClcblx0XHRpZiAoZXJyb3IgaW5zdGFuY2VvZiBSYW5nZUVycm9yIHx8IGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aCgnVW5leHBlY3RlZCBlbmQgb2YgYnVmZmVyJykgfHwgcG9zaXRpb24gPiBzcmNFbmQpIHtcblx0XHRcdGVycm9yLmluY29tcGxldGUgPSB0cnVlXG5cdFx0fVxuXHRcdHRocm93IGVycm9yXG5cdH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZVN0cnVjdHVyZXMoKSB7XG5cdGZvciAobGV0IGlkIGluIGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzKSB7XG5cdFx0Y3VycmVudFN0cnVjdHVyZXNbaWRdID0gY3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXNbaWRdXG5cdH1cblx0Y3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMgPSBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkKCkge1xuXHRsZXQgdG9rZW4gPSBzcmNbcG9zaXRpb24rK11cblx0aWYgKHRva2VuIDwgMHhhMCkge1xuXHRcdGlmICh0b2tlbiA8IDB4ODApIHtcblx0XHRcdGlmICh0b2tlbiA8IDB4NDApXG5cdFx0XHRcdHJldHVybiB0b2tlblxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxldCBzdHJ1Y3R1cmUgPSBjdXJyZW50U3RydWN0dXJlc1t0b2tlbiAmIDB4M2ZdIHx8XG5cdFx0XHRcdFx0Y3VycmVudFVucGFja3IuZ2V0U3RydWN0dXJlcyAmJiBsb2FkU3RydWN0dXJlcygpW3Rva2VuICYgMHgzZl1cblx0XHRcdFx0aWYgKHN0cnVjdHVyZSkge1xuXHRcdFx0XHRcdGlmICghc3RydWN0dXJlLnJlYWQpIHtcblx0XHRcdFx0XHRcdHN0cnVjdHVyZS5yZWFkID0gY3JlYXRlU3RydWN0dXJlUmVhZGVyKHN0cnVjdHVyZSwgdG9rZW4gJiAweDNmKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gc3RydWN0dXJlLnJlYWQoKVxuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRyZXR1cm4gdG9rZW5cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHRva2VuIDwgMHg5MCkge1xuXHRcdFx0Ly8gbWFwXG5cdFx0XHR0b2tlbiAtPSAweDgwXG5cdFx0XHRpZiAoY3VycmVudFVucGFja3IubWFwc0FzT2JqZWN0cykge1xuXHRcdFx0XHRsZXQgb2JqZWN0ID0ge31cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbjsgaSsrKSB7XG5cdFx0XHRcdFx0bGV0IGtleSA9IHJlYWRLZXkoKVxuXHRcdFx0XHRcdGlmIChrZXkgPT09ICdfX3Byb3RvX18nKVxuXHRcdFx0XHRcdFx0a2V5ID0gJ19fcHJvdG9fJ1xuXHRcdFx0XHRcdG9iamVjdFtrZXldID0gcmVhZCgpXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9iamVjdFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGV0IG1hcCA9IG5ldyBNYXAoKVxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuOyBpKyspIHtcblx0XHRcdFx0XHRtYXAuc2V0KHJlYWQoKSwgcmVhZCgpKVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXBcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dG9rZW4gLT0gMHg5MFxuXHRcdFx0bGV0IGFycmF5ID0gbmV3IEFycmF5KHRva2VuKVxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbjsgaSsrKSB7XG5cdFx0XHRcdGFycmF5W2ldID0gcmVhZCgpXG5cdFx0XHR9XG5cdFx0XHRpZiAoY3VycmVudFVucGFja3IuZnJlZXplRGF0YSlcblx0XHRcdFx0cmV0dXJuIE9iamVjdC5mcmVlemUoYXJyYXkpXG5cdFx0XHRyZXR1cm4gYXJyYXlcblx0XHR9XG5cdH0gZWxzZSBpZiAodG9rZW4gPCAweGMwKSB7XG5cdFx0Ly8gZml4c3RyXG5cdFx0bGV0IGxlbmd0aCA9IHRva2VuIC0gMHhhMFxuXHRcdGlmIChzcmNTdHJpbmdFbmQgPj0gcG9zaXRpb24pIHtcblx0XHRcdHJldHVybiBzcmNTdHJpbmcuc2xpY2UocG9zaXRpb24gLSBzcmNTdHJpbmdTdGFydCwgKHBvc2l0aW9uICs9IGxlbmd0aCkgLSBzcmNTdHJpbmdTdGFydClcblx0XHR9XG5cdFx0aWYgKHNyY1N0cmluZ0VuZCA9PSAwICYmIHNyY0VuZCA8IDE0MCkge1xuXHRcdFx0Ly8gZm9yIHNtYWxsIGJsb2NrcywgYXZvaWRpbmcgdGhlIG92ZXJoZWFkIG9mIHRoZSBleHRyYWN0IGNhbGwgaXMgaGVscGZ1bFxuXHRcdFx0bGV0IHN0cmluZyA9IGxlbmd0aCA8IDE2ID8gc2hvcnRTdHJpbmdJbkpTKGxlbmd0aCkgOiBsb25nU3RyaW5nSW5KUyhsZW5ndGgpXG5cdFx0XHRpZiAoc3RyaW5nICE9IG51bGwpXG5cdFx0XHRcdHJldHVybiBzdHJpbmdcblx0XHR9XG5cdFx0cmV0dXJuIHJlYWRGaXhlZFN0cmluZyhsZW5ndGgpXG5cdH0gZWxzZSB7XG5cdFx0bGV0IHZhbHVlXG5cdFx0c3dpdGNoICh0b2tlbikge1xuXHRcdFx0Y2FzZSAweGMwOiByZXR1cm4gbnVsbFxuXHRcdFx0Y2FzZSAweGMxOlxuXHRcdFx0XHRpZiAoYnVuZGxlZFN0cmluZ3MpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHJlYWQoKSAvLyBmb2xsb3dlZCBieSB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgaW4gY2hhcmFjdGVycyAobm90IGJ5dGVzISlcblx0XHRcdFx0XHRpZiAodmFsdWUgPiAwKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGJ1bmRsZWRTdHJpbmdzWzFdLnNsaWNlKGJ1bmRsZWRTdHJpbmdzLnBvc2l0aW9uMSwgYnVuZGxlZFN0cmluZ3MucG9zaXRpb24xICs9IHZhbHVlKVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHJldHVybiBidW5kbGVkU3RyaW5nc1swXS5zbGljZShidW5kbGVkU3RyaW5ncy5wb3NpdGlvbjAsIGJ1bmRsZWRTdHJpbmdzLnBvc2l0aW9uMCAtPSB2YWx1ZSlcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gQzE7IC8vIFwibmV2ZXItdXNlZFwiLCByZXR1cm4gc3BlY2lhbCBvYmplY3QgdG8gZGVub3RlIHRoYXRcblx0XHRcdGNhc2UgMHhjMjogcmV0dXJuIGZhbHNlXG5cdFx0XHRjYXNlIDB4YzM6IHJldHVybiB0cnVlXG5cdFx0XHRjYXNlIDB4YzQ6XG5cdFx0XHRcdC8vIGJpbiA4XG5cdFx0XHRcdHZhbHVlID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgYnVmZmVyJylcblx0XHRcdFx0cmV0dXJuIHJlYWRCaW4odmFsdWUpXG5cdFx0XHRjYXNlIDB4YzU6XG5cdFx0XHRcdC8vIGJpbiAxNlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gMlxuXHRcdFx0XHRyZXR1cm4gcmVhZEJpbih2YWx1ZSlcblx0XHRcdGNhc2UgMHhjNjpcblx0XHRcdFx0Ly8gYmluIDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdHJldHVybiByZWFkQmluKHZhbHVlKVxuXHRcdFx0Y2FzZSAweGM3OlxuXHRcdFx0XHQvLyBleHQgOFxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dChzcmNbcG9zaXRpb24rK10pXG5cdFx0XHRjYXNlIDB4Yzg6XG5cdFx0XHRcdC8vIGV4dCAxNlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gMlxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dCh2YWx1ZSlcblx0XHRcdGNhc2UgMHhjOTpcblx0XHRcdFx0Ly8gZXh0IDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdHJldHVybiByZWFkRXh0KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGNhOlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEZsb2F0MzIocG9zaXRpb24pXG5cdFx0XHRcdGlmIChjdXJyZW50VW5wYWNrci51c2VGbG9hdDMyID4gMikge1xuXHRcdFx0XHRcdC8vIHRoaXMgZG9lcyByb3VuZGluZyBvZiBudW1iZXJzIHRoYXQgd2VyZSBlbmNvZGVkIGluIDMyLWJpdCBmbG9hdCB0byBuZWFyZXN0IHNpZ25pZmljYW50IGRlY2ltYWwgZGlnaXQgdGhhdCBjb3VsZCBiZSBwcmVzZXJ2ZWRcblx0XHRcdFx0XHRsZXQgbXVsdGlwbGllciA9IG11bHQxMFsoKHNyY1twb3NpdGlvbl0gJiAweDdmKSA8PCAxKSB8IChzcmNbcG9zaXRpb24gKyAxXSA+PiA3KV1cblx0XHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdFx0cmV0dXJuICgobXVsdGlwbGllciAqIHZhbHVlICsgKHZhbHVlID4gMCA/IDAuNSA6IC0wLjUpKSA+PiAwKSAvIG11bHRpcGxpZXJcblx0XHRcdFx0fVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0Y2FzZSAweGNiOlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEZsb2F0NjQocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDhcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHQvLyB1aW50IGhhbmRsZXJzXG5cdFx0XHRjYXNlIDB4Y2M6XG5cdFx0XHRcdHJldHVybiBzcmNbcG9zaXRpb24rK11cblx0XHRcdGNhc2UgMHhjZDpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDJcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHRjYXNlIDB4Y2U6XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0Y2FzZSAweGNmOlxuXHRcdFx0XHRpZiAoY3VycmVudFVucGFja3IuaW50NjRBc1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24pICogMHgxMDAwMDAwMDBcblx0XHRcdFx0XHR2YWx1ZSArPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24gKyA0KVxuXHRcdFx0XHR9IGVsc2UgaWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnVWludDY0KHBvc2l0aW9uKS50b1N0cmluZygpXG5cdFx0XHRcdH0gZWxzZSBpZiAoY3VycmVudFVucGFja3IuaW50NjRBc1R5cGUgPT09ICdhdXRvJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnVWludDY0KHBvc2l0aW9uKVxuXHRcdFx0XHRcdGlmICh2YWx1ZTw9QmlnSW50KDIpPDxCaWdJbnQoNTIpKSB2YWx1ZT1OdW1iZXIodmFsdWUpXG5cdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnVWludDY0KHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA4XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXG5cdFx0XHQvLyBpbnQgaGFuZGxlcnNcblx0XHRcdGNhc2UgMHhkMDpcblx0XHRcdFx0cmV0dXJuIGRhdGFWaWV3LmdldEludDgocG9zaXRpb24rKylcblx0XHRcdGNhc2UgMHhkMTpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRJbnQxNihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gMlxuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdGNhc2UgMHhkMjpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRJbnQzMihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdGNhc2UgMHhkMzpcblx0XHRcdFx0aWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0SW50MzIocG9zaXRpb24pICogMHgxMDAwMDAwMDBcblx0XHRcdFx0XHR2YWx1ZSArPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24gKyA0KVxuXHRcdFx0XHR9IGVsc2UgaWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnSW50NjQocG9zaXRpb24pLnRvU3RyaW5nKClcblx0XHRcdFx0fSBlbHNlIGlmIChjdXJyZW50VW5wYWNrci5pbnQ2NEFzVHlwZSA9PT0gJ2F1dG8nKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRCaWdJbnQ2NChwb3NpdGlvbilcblx0XHRcdFx0XHRpZiAodmFsdWU+PUJpZ0ludCgtMik8PEJpZ0ludCg1MikmJnZhbHVlPD1CaWdJbnQoMik8PEJpZ0ludCg1MikpIHZhbHVlPU51bWJlcih2YWx1ZSlcblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRCaWdJbnQ2NChwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gOFxuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblxuXHRcdFx0Y2FzZSAweGQ0OlxuXHRcdFx0XHQvLyBmaXhleHQgMVxuXHRcdFx0XHR2YWx1ZSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRpZiAodmFsdWUgPT0gMHg3Mikge1xuXHRcdFx0XHRcdHJldHVybiByZWNvcmREZWZpbml0aW9uKHNyY1twb3NpdGlvbisrXSAmIDB4M2YpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGV0IGV4dGVuc2lvbiA9IGN1cnJlbnRFeHRlbnNpb25zW3ZhbHVlXVxuXHRcdFx0XHRcdGlmIChleHRlbnNpb24pIHtcblx0XHRcdFx0XHRcdGlmIChleHRlbnNpb24ucmVhZCkge1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbisrIC8vIHNraXAgZmlsbGVyIGJ5dGVcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGV4dGVuc2lvbi5yZWFkKHJlYWQoKSlcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoZXh0ZW5zaW9uLm5vQnVmZmVyKSB7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uKysgLy8gc2tpcCBmaWxsZXIgYnl0ZVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9uKClcblx0XHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9uKHNyYy5zdWJhcnJheShwb3NpdGlvbiwgKytwb3NpdGlvbikpXG5cdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZXh0ZW5zaW9uICcgKyB2YWx1ZSlcblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSAweGQ1OlxuXHRcdFx0XHQvLyBmaXhleHQgMlxuXHRcdFx0XHR2YWx1ZSA9IHNyY1twb3NpdGlvbl1cblx0XHRcdFx0aWYgKHZhbHVlID09IDB4NzIpIHtcblx0XHRcdFx0XHRwb3NpdGlvbisrXG5cdFx0XHRcdFx0cmV0dXJuIHJlY29yZERlZmluaXRpb24oc3JjW3Bvc2l0aW9uKytdICYgMHgzZiwgc3JjW3Bvc2l0aW9uKytdKVxuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRyZXR1cm4gcmVhZEV4dCgyKVxuXHRcdFx0Y2FzZSAweGQ2OlxuXHRcdFx0XHQvLyBmaXhleHQgNFxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dCg0KVxuXHRcdFx0Y2FzZSAweGQ3OlxuXHRcdFx0XHQvLyBmaXhleHQgOFxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dCg4KVxuXHRcdFx0Y2FzZSAweGQ4OlxuXHRcdFx0XHQvLyBmaXhleHQgMTZcblx0XHRcdFx0cmV0dXJuIHJlYWRFeHQoMTYpXG5cdFx0XHRjYXNlIDB4ZDk6XG5cdFx0XHQvLyBzdHIgOFxuXHRcdFx0XHR2YWx1ZSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRpZiAoc3JjU3RyaW5nRW5kID49IHBvc2l0aW9uKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNyY1N0cmluZy5zbGljZShwb3NpdGlvbiAtIHNyY1N0cmluZ1N0YXJ0LCAocG9zaXRpb24gKz0gdmFsdWUpIC0gc3JjU3RyaW5nU3RhcnQpXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlYWRTdHJpbmc4KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRhOlxuXHRcdFx0Ly8gc3RyIDE2XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSAyXG5cdFx0XHRcdGlmIChzcmNTdHJpbmdFbmQgPj0gcG9zaXRpb24pIHtcblx0XHRcdFx0XHRyZXR1cm4gc3JjU3RyaW5nLnNsaWNlKHBvc2l0aW9uIC0gc3JjU3RyaW5nU3RhcnQsIChwb3NpdGlvbiArPSB2YWx1ZSkgLSBzcmNTdHJpbmdTdGFydClcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVhZFN0cmluZzE2KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRiOlxuXHRcdFx0Ly8gc3RyIDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdGlmIChzcmNTdHJpbmdFbmQgPj0gcG9zaXRpb24pIHtcblx0XHRcdFx0XHRyZXR1cm4gc3JjU3RyaW5nLnNsaWNlKHBvc2l0aW9uIC0gc3JjU3RyaW5nU3RhcnQsIChwb3NpdGlvbiArPSB2YWx1ZSkgLSBzcmNTdHJpbmdTdGFydClcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVhZFN0cmluZzMyKHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRjOlxuXHRcdFx0Ly8gYXJyYXkgMTZcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDJcblx0XHRcdFx0cmV0dXJuIHJlYWRBcnJheSh2YWx1ZSlcblx0XHRcdGNhc2UgMHhkZDpcblx0XHRcdC8vIGFycmF5IDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdHJldHVybiByZWFkQXJyYXkodmFsdWUpXG5cdFx0XHRjYXNlIDB4ZGU6XG5cdFx0XHQvLyBtYXAgMTZcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDJcblx0XHRcdFx0cmV0dXJuIHJlYWRNYXAodmFsdWUpXG5cdFx0XHRjYXNlIDB4ZGY6XG5cdFx0XHQvLyBtYXAgMzJcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdFx0cmV0dXJuIHJlYWRNYXAodmFsdWUpXG5cdFx0XHRkZWZhdWx0OiAvLyBuZWdhdGl2ZSBpbnRcblx0XHRcdFx0aWYgKHRva2VuID49IDB4ZTApXG5cdFx0XHRcdFx0cmV0dXJuIHRva2VuIC0gMHgxMDBcblx0XHRcdFx0aWYgKHRva2VuID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRsZXQgZXJyb3IgPSBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIE1lc3NhZ2VQYWNrIGRhdGEnKVxuXHRcdFx0XHRcdGVycm9yLmluY29tcGxldGUgPSB0cnVlXG5cdFx0XHRcdFx0dGhyb3cgZXJyb3Jcblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gTWVzc2FnZVBhY2sgdG9rZW4gJyArIHRva2VuKVxuXG5cdFx0fVxuXHR9XG59XG5jb25zdCB2YWxpZE5hbWUgPSAvXlthLXpBLVpfJF1bYS16QS1aXFxkXyRdKiQvXG5mdW5jdGlvbiBjcmVhdGVTdHJ1Y3R1cmVSZWFkZXIoc3RydWN0dXJlLCBmaXJzdElkKSB7XG5cdGZ1bmN0aW9uIHJlYWRPYmplY3QoKSB7XG5cdFx0Ly8gVGhpcyBpbml0aWFsIGZ1bmN0aW9uIGlzIHF1aWNrIHRvIGluc3RhbnRpYXRlLCBidXQgcnVucyBzbG93ZXIuIEFmdGVyIHNldmVyYWwgaXRlcmF0aW9ucyBwYXkgdGhlIGNvc3QgdG8gYnVpbGQgdGhlIGZhc3RlciBmdW5jdGlvblxuXHRcdGlmIChyZWFkT2JqZWN0LmNvdW50KysgPiBpbmxpbmVPYmplY3RSZWFkVGhyZXNob2xkKSB7XG5cdFx0XHRsZXQgcmVhZE9iamVjdCA9IHN0cnVjdHVyZS5yZWFkID0gKG5ldyBGdW5jdGlvbigncicsICdyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gJyArIChjdXJyZW50VW5wYWNrci5mcmVlemVEYXRhID8gJ09iamVjdC5mcmVlemUnIDogJycpICtcblx0XHRcdFx0Jyh7JyArIHN0cnVjdHVyZS5tYXAoa2V5ID0+IGtleSA9PT0gJ19fcHJvdG9fXycgPyAnX19wcm90b186cigpJyA6IHZhbGlkTmFtZS50ZXN0KGtleSkgPyBrZXkgKyAnOnIoKScgOiAoJ1snICsgSlNPTi5zdHJpbmdpZnkoa2V5KSArICddOnIoKScpKS5qb2luKCcsJykgKyAnfSl9JykpKHJlYWQpXG5cdFx0XHRpZiAoc3RydWN0dXJlLmhpZ2hCeXRlID09PSAwKVxuXHRcdFx0XHRzdHJ1Y3R1cmUucmVhZCA9IGNyZWF0ZVNlY29uZEJ5dGVSZWFkZXIoZmlyc3RJZCwgc3RydWN0dXJlLnJlYWQpXG5cdFx0XHRyZXR1cm4gcmVhZE9iamVjdCgpIC8vIHNlY29uZCBieXRlIGlzIGFscmVhZHkgcmVhZCwgaWYgdGhlcmUgaXMgb25lIHNvIGltbWVkaWF0ZWx5IHJlYWQgb2JqZWN0XG5cdFx0fVxuXHRcdGxldCBvYmplY3QgPSB7fVxuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gc3RydWN0dXJlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0bGV0IGtleSA9IHN0cnVjdHVyZVtpXVxuXHRcdFx0aWYgKGtleSA9PT0gJ19fcHJvdG9fXycpXG5cdFx0XHRcdGtleSA9ICdfX3Byb3RvXydcblx0XHRcdG9iamVjdFtrZXldID0gcmVhZCgpXG5cdFx0fVxuXHRcdGlmIChjdXJyZW50VW5wYWNrci5mcmVlemVEYXRhKVxuXHRcdFx0cmV0dXJuIE9iamVjdC5mcmVlemUob2JqZWN0KTtcblx0XHRyZXR1cm4gb2JqZWN0XG5cdH1cblx0cmVhZE9iamVjdC5jb3VudCA9IDBcblx0aWYgKHN0cnVjdHVyZS5oaWdoQnl0ZSA9PT0gMCkge1xuXHRcdHJldHVybiBjcmVhdGVTZWNvbmRCeXRlUmVhZGVyKGZpcnN0SWQsIHJlYWRPYmplY3QpXG5cdH1cblx0cmV0dXJuIHJlYWRPYmplY3Rcbn1cblxuY29uc3QgY3JlYXRlU2Vjb25kQnl0ZVJlYWRlciA9IChmaXJzdElkLCByZWFkMCkgPT4ge1xuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0bGV0IGhpZ2hCeXRlID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0aWYgKGhpZ2hCeXRlID09PSAwKVxuXHRcdFx0cmV0dXJuIHJlYWQwKClcblx0XHRsZXQgaWQgPSBmaXJzdElkIDwgMzIgPyAtKGZpcnN0SWQgKyAoaGlnaEJ5dGUgPDwgNSkpIDogZmlyc3RJZCArIChoaWdoQnl0ZSA8PCA1KVxuXHRcdGxldCBzdHJ1Y3R1cmUgPSBjdXJyZW50U3RydWN0dXJlc1tpZF0gfHwgbG9hZFN0cnVjdHVyZXMoKVtpZF1cblx0XHRpZiAoIXN0cnVjdHVyZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdSZWNvcmQgaWQgaXMgbm90IGRlZmluZWQgZm9yICcgKyBpZClcblx0XHR9XG5cdFx0aWYgKCFzdHJ1Y3R1cmUucmVhZClcblx0XHRcdHN0cnVjdHVyZS5yZWFkID0gY3JlYXRlU3RydWN0dXJlUmVhZGVyKHN0cnVjdHVyZSwgZmlyc3RJZClcblx0XHRyZXR1cm4gc3RydWN0dXJlLnJlYWQoKVxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkU3RydWN0dXJlcygpIHtcblx0bGV0IGxvYWRlZFN0cnVjdHVyZXMgPSBzYXZlU3RhdGUoKCkgPT4ge1xuXHRcdC8vIHNhdmUgdGhlIHN0YXRlIGluIGNhc2UgZ2V0U3RydWN0dXJlcyBtb2RpZmllcyBvdXIgYnVmZmVyXG5cdFx0c3JjID0gbnVsbFxuXHRcdHJldHVybiBjdXJyZW50VW5wYWNrci5nZXRTdHJ1Y3R1cmVzKClcblx0fSlcblx0cmV0dXJuIGN1cnJlbnRTdHJ1Y3R1cmVzID0gY3VycmVudFVucGFja3IuX21lcmdlU3RydWN0dXJlcyhsb2FkZWRTdHJ1Y3R1cmVzLCBjdXJyZW50U3RydWN0dXJlcylcbn1cblxudmFyIHJlYWRGaXhlZFN0cmluZyA9IHJlYWRTdHJpbmdKU1xudmFyIHJlYWRTdHJpbmc4ID0gcmVhZFN0cmluZ0pTXG52YXIgcmVhZFN0cmluZzE2ID0gcmVhZFN0cmluZ0pTXG52YXIgcmVhZFN0cmluZzMyID0gcmVhZFN0cmluZ0pTXG5leHBvcnQgbGV0IGlzTmF0aXZlQWNjZWxlcmF0aW9uRW5hYmxlZCA9IGZhbHNlXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRFeHRyYWN0b3IoZXh0cmFjdFN0cmluZ3MpIHtcblx0aXNOYXRpdmVBY2NlbGVyYXRpb25FbmFibGVkID0gdHJ1ZVxuXHRyZWFkRml4ZWRTdHJpbmcgPSByZWFkU3RyaW5nKDEpXG5cdHJlYWRTdHJpbmc4ID0gcmVhZFN0cmluZygyKVxuXHRyZWFkU3RyaW5nMTYgPSByZWFkU3RyaW5nKDMpXG5cdHJlYWRTdHJpbmczMiA9IHJlYWRTdHJpbmcoNSlcblx0ZnVuY3Rpb24gcmVhZFN0cmluZyhoZWFkZXJMZW5ndGgpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gcmVhZFN0cmluZyhsZW5ndGgpIHtcblx0XHRcdGxldCBzdHJpbmcgPSBzdHJpbmdzW3N0cmluZ1Bvc2l0aW9uKytdXG5cdFx0XHRpZiAoc3RyaW5nID09IG51bGwpIHtcblx0XHRcdFx0aWYgKGJ1bmRsZWRTdHJpbmdzKVxuXHRcdFx0XHRcdHJldHVybiByZWFkU3RyaW5nSlMobGVuZ3RoKVxuXHRcdFx0XHRsZXQgYnl0ZU9mZnNldCA9IHNyYy5ieXRlT2Zmc2V0XG5cdFx0XHRcdGxldCBleHRyYWN0aW9uID0gZXh0cmFjdFN0cmluZ3MocG9zaXRpb24gLSBoZWFkZXJMZW5ndGggKyBieXRlT2Zmc2V0LCBzcmNFbmQgKyBieXRlT2Zmc2V0LCBzcmMuYnVmZmVyKVxuXHRcdFx0XHRpZiAodHlwZW9mIGV4dHJhY3Rpb24gPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRzdHJpbmcgPSBleHRyYWN0aW9uXG5cdFx0XHRcdFx0c3RyaW5ncyA9IEVNUFRZX0FSUkFZXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RyaW5ncyA9IGV4dHJhY3Rpb25cblx0XHRcdFx0XHRzdHJpbmdQb3NpdGlvbiA9IDFcblx0XHRcdFx0XHRzcmNTdHJpbmdFbmQgPSAxIC8vIGV2ZW4gaWYgYSB1dGYtOCBzdHJpbmcgd2FzIGRlY29kZWQsIG11c3QgaW5kaWNhdGUgd2UgYXJlIGluIHRoZSBtaWRzdCBvZiBleHRyYWN0ZWQgc3RyaW5ncyBhbmQgY2FuJ3Qgc2tpcCBzdHJpbmdzXG5cdFx0XHRcdFx0c3RyaW5nID0gc3RyaW5nc1swXVxuXHRcdFx0XHRcdGlmIChzdHJpbmcgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgYnVmZmVyJylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bGV0IHNyY1N0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGhcblx0XHRcdGlmIChzcmNTdHJpbmdMZW5ndGggPD0gbGVuZ3RoKSB7XG5cdFx0XHRcdHBvc2l0aW9uICs9IGxlbmd0aFxuXHRcdFx0XHRyZXR1cm4gc3RyaW5nXG5cdFx0XHR9XG5cdFx0XHRzcmNTdHJpbmcgPSBzdHJpbmdcblx0XHRcdHNyY1N0cmluZ1N0YXJ0ID0gcG9zaXRpb25cblx0XHRcdHNyY1N0cmluZ0VuZCA9IHBvc2l0aW9uICsgc3JjU3RyaW5nTGVuZ3RoXG5cdFx0XHRwb3NpdGlvbiArPSBsZW5ndGhcblx0XHRcdHJldHVybiBzdHJpbmcuc2xpY2UoMCwgbGVuZ3RoKSAvLyB3ZSBrbm93IHdlIGp1c3Qgd2FudCB0aGUgYmVnaW5uaW5nXG5cdFx0fVxuXHR9XG59XG5mdW5jdGlvbiByZWFkU3RyaW5nSlMobGVuZ3RoKSB7XG5cdGxldCByZXN1bHRcblx0aWYgKGxlbmd0aCA8IDE2KSB7XG5cdFx0aWYgKHJlc3VsdCA9IHNob3J0U3RyaW5nSW5KUyhsZW5ndGgpKVxuXHRcdFx0cmV0dXJuIHJlc3VsdFxuXHR9XG5cdGlmIChsZW5ndGggPiA2NCAmJiBkZWNvZGVyKVxuXHRcdHJldHVybiBkZWNvZGVyLmRlY29kZShzcmMuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICs9IGxlbmd0aCkpXG5cdGNvbnN0IGVuZCA9IHBvc2l0aW9uICsgbGVuZ3RoXG5cdGNvbnN0IHVuaXRzID0gW11cblx0cmVzdWx0ID0gJydcblx0d2hpbGUgKHBvc2l0aW9uIDwgZW5kKSB7XG5cdFx0Y29uc3QgYnl0ZTEgPSBzcmNbcG9zaXRpb24rK11cblx0XHRpZiAoKGJ5dGUxICYgMHg4MCkgPT09IDApIHtcblx0XHRcdC8vIDEgYnl0ZVxuXHRcdFx0dW5pdHMucHVzaChieXRlMSlcblx0XHR9IGVsc2UgaWYgKChieXRlMSAmIDB4ZTApID09PSAweGMwKSB7XG5cdFx0XHQvLyAyIGJ5dGVzXG5cdFx0XHRjb25zdCBieXRlMiA9IHNyY1twb3NpdGlvbisrXSAmIDB4M2Zcblx0XHRcdHVuaXRzLnB1c2goKChieXRlMSAmIDB4MWYpIDw8IDYpIHwgYnl0ZTIpXG5cdFx0fSBlbHNlIGlmICgoYnl0ZTEgJiAweGYwKSA9PT0gMHhlMCkge1xuXHRcdFx0Ly8gMyBieXRlc1xuXHRcdFx0Y29uc3QgYnl0ZTIgPSBzcmNbcG9zaXRpb24rK10gJiAweDNmXG5cdFx0XHRjb25zdCBieXRlMyA9IHNyY1twb3NpdGlvbisrXSAmIDB4M2Zcblx0XHRcdHVuaXRzLnB1c2goKChieXRlMSAmIDB4MWYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzKVxuXHRcdH0gZWxzZSBpZiAoKGJ5dGUxICYgMHhmOCkgPT09IDB4ZjApIHtcblx0XHRcdC8vIDQgYnl0ZXNcblx0XHRcdGNvbnN0IGJ5dGUyID0gc3JjW3Bvc2l0aW9uKytdICYgMHgzZlxuXHRcdFx0Y29uc3QgYnl0ZTMgPSBzcmNbcG9zaXRpb24rK10gJiAweDNmXG5cdFx0XHRjb25zdCBieXRlNCA9IHNyY1twb3NpdGlvbisrXSAmIDB4M2Zcblx0XHRcdGxldCB1bml0ID0gKChieXRlMSAmIDB4MDcpIDw8IDB4MTIpIHwgKGJ5dGUyIDw8IDB4MGMpIHwgKGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTRcblx0XHRcdGlmICh1bml0ID4gMHhmZmZmKSB7XG5cdFx0XHRcdHVuaXQgLT0gMHgxMDAwMFxuXHRcdFx0XHR1bml0cy5wdXNoKCgodW5pdCA+Pj4gMTApICYgMHgzZmYpIHwgMHhkODAwKVxuXHRcdFx0XHR1bml0ID0gMHhkYzAwIHwgKHVuaXQgJiAweDNmZilcblx0XHRcdH1cblx0XHRcdHVuaXRzLnB1c2godW5pdClcblx0XHR9IGVsc2Uge1xuXHRcdFx0dW5pdHMucHVzaChieXRlMSlcblx0XHR9XG5cblx0XHRpZiAodW5pdHMubGVuZ3RoID49IDB4MTAwMCkge1xuXHRcdFx0cmVzdWx0ICs9IGZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIHVuaXRzKVxuXHRcdFx0dW5pdHMubGVuZ3RoID0gMFxuXHRcdH1cblx0fVxuXG5cdGlmICh1bml0cy5sZW5ndGggPiAwKSB7XG5cdFx0cmVzdWx0ICs9IGZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIHVuaXRzKVxuXHR9XG5cblx0cmV0dXJuIHJlc3VsdFxufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRTdHJpbmcoc291cmNlLCBzdGFydCwgbGVuZ3RoKSB7XG5cdGxldCBleGlzdGluZ1NyYyA9IHNyYztcblx0c3JjID0gc291cmNlO1xuXHRwb3NpdGlvbiA9IHN0YXJ0O1xuXHR0cnkge1xuXHRcdHJldHVybiByZWFkU3RyaW5nSlMobGVuZ3RoKTtcblx0fSBmaW5hbGx5IHtcblx0XHRzcmMgPSBleGlzdGluZ1NyYztcblx0fVxufVxuXG5mdW5jdGlvbiByZWFkQXJyYXkobGVuZ3RoKSB7XG5cdGxldCBhcnJheSA9IG5ldyBBcnJheShsZW5ndGgpXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRhcnJheVtpXSA9IHJlYWQoKVxuXHR9XG5cdGlmIChjdXJyZW50VW5wYWNrci5mcmVlemVEYXRhKVxuXHRcdHJldHVybiBPYmplY3QuZnJlZXplKGFycmF5KVxuXHRyZXR1cm4gYXJyYXlcbn1cblxuZnVuY3Rpb24gcmVhZE1hcChsZW5ndGgpIHtcblx0aWYgKGN1cnJlbnRVbnBhY2tyLm1hcHNBc09iamVjdHMpIHtcblx0XHRsZXQgb2JqZWN0ID0ge31cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQga2V5ID0gcmVhZEtleSgpXG5cdFx0XHRpZiAoa2V5ID09PSAnX19wcm90b19fJylcblx0XHRcdFx0a2V5ID0gJ19fcHJvdG9fJztcblx0XHRcdG9iamVjdFtrZXldID0gcmVhZCgpXG5cdFx0fVxuXHRcdHJldHVybiBvYmplY3Rcblx0fSBlbHNlIHtcblx0XHRsZXQgbWFwID0gbmV3IE1hcCgpXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0bWFwLnNldChyZWFkKCksIHJlYWQoKSlcblx0XHR9XG5cdFx0cmV0dXJuIG1hcFxuXHR9XG59XG5cbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlXG5mdW5jdGlvbiBsb25nU3RyaW5nSW5KUyhsZW5ndGgpIHtcblx0bGV0IHN0YXJ0ID0gcG9zaXRpb25cblx0bGV0IGJ5dGVzID0gbmV3IEFycmF5KGxlbmd0aClcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IGJ5dGUgPSBzcmNbcG9zaXRpb24rK107XG5cdFx0aWYgKChieXRlICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdHBvc2l0aW9uID0gc3RhcnRcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRieXRlc1tpXSA9IGJ5dGVcblx0XHR9XG5cdFx0cmV0dXJuIGZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGJ5dGVzKVxufVxuZnVuY3Rpb24gc2hvcnRTdHJpbmdJbkpTKGxlbmd0aCkge1xuXHRpZiAobGVuZ3RoIDwgNCkge1xuXHRcdGlmIChsZW5ndGggPCAyKSB7XG5cdFx0XHRpZiAobGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gJydcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRsZXQgYSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRpZiAoKGEgJiAweDgwKSA+IDEpIHtcblx0XHRcdFx0XHRwb3NpdGlvbiAtPSAxXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhKVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgYSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0bGV0IGIgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdGlmICgoYSAmIDB4ODApID4gMCB8fCAoYiAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiAtPSAyXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDMpXG5cdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYilcblx0XHRcdGxldCBjID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRpZiAoKGMgJiAweDgwKSA+IDApIHtcblx0XHRcdFx0cG9zaXRpb24gLT0gM1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYylcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0bGV0IGEgPSBzcmNbcG9zaXRpb24rK11cblx0XHRsZXQgYiA9IHNyY1twb3NpdGlvbisrXVxuXHRcdGxldCBjID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0bGV0IGQgPSBzcmNbcG9zaXRpb24rK11cblx0XHRpZiAoKGEgJiAweDgwKSA+IDAgfHwgKGIgJiAweDgwKSA+IDAgfHwgKGMgJiAweDgwKSA+IDAgfHwgKGQgJiAweDgwKSA+IDApIHtcblx0XHRcdHBvc2l0aW9uIC09IDRcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRpZiAobGVuZ3RoIDwgNikge1xuXHRcdFx0aWYgKGxlbmd0aCA9PT0gNClcblx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkKVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxldCBlID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdGlmICgoZSAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdHBvc2l0aW9uIC09IDVcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUpXG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChsZW5ndGggPCA4KSB7XG5cdFx0XHRsZXQgZSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0bGV0IGYgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdGlmICgoZSAmIDB4ODApID4gMCB8fCAoZiAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiAtPSA2XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDcpXG5cdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZilcblx0XHRcdGxldCBnID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRpZiAoKGcgJiAweDgwKSA+IDApIHtcblx0XHRcdFx0cG9zaXRpb24gLT0gN1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZylcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IGUgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdGxldCBmID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRsZXQgZyA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0bGV0IGggPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdGlmICgoZSAmIDB4ODApID4gMCB8fCAoZiAmIDB4ODApID4gMCB8fCAoZyAmIDB4ODApID4gMCB8fCAoaCAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiAtPSA4XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDEwKSB7XG5cdFx0XHRcdGlmIChsZW5ndGggPT09IDgpXG5cdFx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRsZXQgaSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRcdGlmICgoaSAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24gLT0gOVxuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSlcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChsZW5ndGggPCAxMikge1xuXHRcdFx0XHRsZXQgaSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRsZXQgaiA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRpZiAoKGkgJiAweDgwKSA+IDAgfHwgKGogJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRwb3NpdGlvbiAtPSAxMFxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsZW5ndGggPCAxMSlcblx0XHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGopXG5cdFx0XHRcdGxldCBrID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdGlmICgoayAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdHBvc2l0aW9uIC09IDExXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGV0IGkgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0bGV0IGogPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0bGV0IGsgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0bGV0IGwgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0aWYgKChpICYgMHg4MCkgPiAwIHx8IChqICYgMHg4MCkgPiAwIHx8IChrICYgMHg4MCkgPiAwIHx8IChsICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24gLT0gMTJcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobGVuZ3RoIDwgMTQpIHtcblx0XHRcdFx0XHRpZiAobGVuZ3RoID09PSAxMilcblx0XHRcdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbClcblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGxldCBtID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdFx0XHRpZiAoKG0gJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24gLT0gMTNcblx0XHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwsIG0pXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxldCBtID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdFx0bGV0IG4gPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0XHRpZiAoKG0gJiAweDgwKSA+IDAgfHwgKG4gJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uIC09IDE0XG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGxlbmd0aCA8IDE1KVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsLCBtLCBuKVxuXHRcdFx0XHRcdGxldCBvID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdFx0aWYgKChvICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiAtPSAxNVxuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCwgbSwgbiwgbylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiByZWFkT25seUpTU3RyaW5nKCkge1xuXHRsZXQgdG9rZW4gPSBzcmNbcG9zaXRpb24rK11cblx0bGV0IGxlbmd0aFxuXHRpZiAodG9rZW4gPCAweGMwKSB7XG5cdFx0Ly8gZml4c3RyXG5cdFx0bGVuZ3RoID0gdG9rZW4gLSAweGEwXG5cdH0gZWxzZSB7XG5cdFx0c3dpdGNoKHRva2VuKSB7XG5cdFx0XHRjYXNlIDB4ZDk6XG5cdFx0XHQvLyBzdHIgOFxuXHRcdFx0XHRsZW5ndGggPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMHhkYTpcblx0XHRcdC8vIHN0ciAxNlxuXHRcdFx0XHRsZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDJcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMHhkYjpcblx0XHRcdC8vIHN0ciAzMlxuXHRcdFx0XHRsZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdFx0YnJlYWtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgc3RyaW5nJylcblx0XHR9XG5cdH1cblx0cmV0dXJuIHJlYWRTdHJpbmdKUyhsZW5ndGgpXG59XG5cblxuZnVuY3Rpb24gcmVhZEJpbihsZW5ndGgpIHtcblx0cmV0dXJuIGN1cnJlbnRVbnBhY2tyLmNvcHlCdWZmZXJzID9cblx0XHQvLyBzcGVjaWZpY2FsbHkgdXNlIHRoZSBjb3B5aW5nIHNsaWNlIChub3QgdGhlIG5vZGUgb25lKVxuXHRcdFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc3JjLCBwb3NpdGlvbiwgcG9zaXRpb24gKz0gbGVuZ3RoKSA6XG5cdFx0c3JjLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArPSBsZW5ndGgpXG59XG5mdW5jdGlvbiByZWFkRXh0KGxlbmd0aCkge1xuXHRsZXQgdHlwZSA9IHNyY1twb3NpdGlvbisrXVxuXHRpZiAoY3VycmVudEV4dGVuc2lvbnNbdHlwZV0pIHtcblx0XHRsZXQgZW5kXG5cdFx0cmV0dXJuIGN1cnJlbnRFeHRlbnNpb25zW3R5cGVdKHNyYy5zdWJhcnJheShwb3NpdGlvbiwgZW5kID0gKHBvc2l0aW9uICs9IGxlbmd0aCkpLCAocmVhZFBvc2l0aW9uKSA9PiB7XG5cdFx0XHRwb3NpdGlvbiA9IHJlYWRQb3NpdGlvbjtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJldHVybiByZWFkKCk7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRwb3NpdGlvbiA9IGVuZDtcblx0XHRcdH1cblx0XHR9KVxuXHR9XG5cdGVsc2Vcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZXh0ZW5zaW9uIHR5cGUgJyArIHR5cGUpXG59XG5cbnZhciBrZXlDYWNoZSA9IG5ldyBBcnJheSg0MDk2KVxuZnVuY3Rpb24gcmVhZEtleSgpIHtcblx0bGV0IGxlbmd0aCA9IHNyY1twb3NpdGlvbisrXVxuXHRpZiAobGVuZ3RoID49IDB4YTAgJiYgbGVuZ3RoIDwgMHhjMCkge1xuXHRcdC8vIGZpeHN0ciwgcG90ZW50aWFsbHkgdXNlIGtleSBjYWNoZVxuXHRcdGxlbmd0aCA9IGxlbmd0aCAtIDB4YTBcblx0XHRpZiAoc3JjU3RyaW5nRW5kID49IHBvc2l0aW9uKSAvLyBpZiBpdCBoYXMgYmVlbiBleHRyYWN0ZWQsIG11c3QgdXNlIGl0IChhbmQgZmFzdGVyIGFueXdheSlcblx0XHRcdHJldHVybiBzcmNTdHJpbmcuc2xpY2UocG9zaXRpb24gLSBzcmNTdHJpbmdTdGFydCwgKHBvc2l0aW9uICs9IGxlbmd0aCkgLSBzcmNTdHJpbmdTdGFydClcblx0XHRlbHNlIGlmICghKHNyY1N0cmluZ0VuZCA9PSAwICYmIHNyY0VuZCA8IDE4MCkpXG5cdFx0XHRyZXR1cm4gcmVhZEZpeGVkU3RyaW5nKGxlbmd0aClcblx0fSBlbHNlIHsgLy8gbm90IGNhY2hlYWJsZSwgZ28gYmFjayBhbmQgZG8gYSBzdGFuZGFyZCByZWFkXG5cdFx0cG9zaXRpb24tLVxuXHRcdHJldHVybiBhc1NhZmVTdHJpbmcocmVhZCgpKVxuXHR9XG5cdGxldCBrZXkgPSAoKGxlbmd0aCA8PCA1KSBeIChsZW5ndGggPiAxID8gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uKSA6IGxlbmd0aCA+IDAgPyBzcmNbcG9zaXRpb25dIDogMCkpICYgMHhmZmZcblx0bGV0IGVudHJ5ID0ga2V5Q2FjaGVba2V5XVxuXHRsZXQgY2hlY2tQb3NpdGlvbiA9IHBvc2l0aW9uXG5cdGxldCBlbmQgPSBwb3NpdGlvbiArIGxlbmd0aCAtIDNcblx0bGV0IGNodW5rXG5cdGxldCBpID0gMFxuXHRpZiAoZW50cnkgJiYgZW50cnkuYnl0ZXMgPT0gbGVuZ3RoKSB7XG5cdFx0d2hpbGUgKGNoZWNrUG9zaXRpb24gPCBlbmQpIHtcblx0XHRcdGNodW5rID0gZGF0YVZpZXcuZ2V0VWludDMyKGNoZWNrUG9zaXRpb24pXG5cdFx0XHRpZiAoY2h1bmsgIT0gZW50cnlbaSsrXSkge1xuXHRcdFx0XHRjaGVja1Bvc2l0aW9uID0gMHg3MDAwMDAwMFxuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdFx0Y2hlY2tQb3NpdGlvbiArPSA0XG5cdFx0fVxuXHRcdGVuZCArPSAzXG5cdFx0d2hpbGUgKGNoZWNrUG9zaXRpb24gPCBlbmQpIHtcblx0XHRcdGNodW5rID0gc3JjW2NoZWNrUG9zaXRpb24rK11cblx0XHRcdGlmIChjaHVuayAhPSBlbnRyeVtpKytdKSB7XG5cdFx0XHRcdGNoZWNrUG9zaXRpb24gPSAweDcwMDAwMDAwXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChjaGVja1Bvc2l0aW9uID09PSBlbmQpIHtcblx0XHRcdHBvc2l0aW9uID0gY2hlY2tQb3NpdGlvblxuXHRcdFx0cmV0dXJuIGVudHJ5LnN0cmluZ1xuXHRcdH1cblx0XHRlbmQgLT0gM1xuXHRcdGNoZWNrUG9zaXRpb24gPSBwb3NpdGlvblxuXHR9XG5cdGVudHJ5ID0gW11cblx0a2V5Q2FjaGVba2V5XSA9IGVudHJ5XG5cdGVudHJ5LmJ5dGVzID0gbGVuZ3RoXG5cdHdoaWxlIChjaGVja1Bvc2l0aW9uIDwgZW5kKSB7XG5cdFx0Y2h1bmsgPSBkYXRhVmlldy5nZXRVaW50MzIoY2hlY2tQb3NpdGlvbilcblx0XHRlbnRyeS5wdXNoKGNodW5rKVxuXHRcdGNoZWNrUG9zaXRpb24gKz0gNFxuXHR9XG5cdGVuZCArPSAzXG5cdHdoaWxlIChjaGVja1Bvc2l0aW9uIDwgZW5kKSB7XG5cdFx0Y2h1bmsgPSBzcmNbY2hlY2tQb3NpdGlvbisrXVxuXHRcdGVudHJ5LnB1c2goY2h1bmspXG5cdH1cblx0Ly8gZm9yIHNtYWxsIGJsb2NrcywgYXZvaWRpbmcgdGhlIG92ZXJoZWFkIG9mIHRoZSBleHRyYWN0IGNhbGwgaXMgaGVscGZ1bFxuXHRsZXQgc3RyaW5nID0gbGVuZ3RoIDwgMTYgPyBzaG9ydFN0cmluZ0luSlMobGVuZ3RoKSA6IGxvbmdTdHJpbmdJbkpTKGxlbmd0aClcblx0aWYgKHN0cmluZyAhPSBudWxsKVxuXHRcdHJldHVybiBlbnRyeS5zdHJpbmcgPSBzdHJpbmdcblx0cmV0dXJuIGVudHJ5LnN0cmluZyA9IHJlYWRGaXhlZFN0cmluZyhsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzU2FmZVN0cmluZyhwcm9wZXJ0eSkge1xuXHQvLyBwcm90ZWN0IGFnYWluc3QgZXhwZW5zaXZlIChEb1MpIHN0cmluZyBjb252ZXJzaW9uc1xuXHRpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnc3RyaW5nJykgcmV0dXJuIHByb3BlcnR5O1xuXHRpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgcHJvcGVydHkgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgcHJvcGVydHkgPT09ICdiaWdpbnQnKSByZXR1cm4gcHJvcGVydHkudG9TdHJpbmcoKTtcblx0aWYgKHByb3BlcnR5ID09IG51bGwpIHJldHVybiBwcm9wZXJ0eSArICcnO1xuXHRpZiAoY3VycmVudFVucGFja3IuYWxsb3dBcnJheXNJbk1hcEtleXMgJiYgQXJyYXkuaXNBcnJheShwcm9wZXJ0eSkgJiYgcHJvcGVydHkuZmxhdCgpLmV2ZXJ5KGl0ZW0gPT4gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nLCAnYmlnaW50J10uaW5jbHVkZXModHlwZW9mIGl0ZW0pKSkge1xuXHRcdHJldHVybiBwcm9wZXJ0eS5mbGF0KCkudG9TdHJpbmcoKTtcblx0fVxuXHR0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHJvcGVydHkgdHlwZSBmb3IgcmVjb3JkOiAke3R5cGVvZiBwcm9wZXJ0eX1gKTtcbn1cbi8vIHRoZSByZWdpc3RyYXRpb24gb2YgdGhlIHJlY29yZCBkZWZpbml0aW9uIGV4dGVuc2lvbiAoYXMgXCJyXCIpXG5jb25zdCByZWNvcmREZWZpbml0aW9uID0gKGlkLCBoaWdoQnl0ZSkgPT4ge1xuXHRsZXQgc3RydWN0dXJlID0gcmVhZCgpLm1hcChhc1NhZmVTdHJpbmcpIC8vIGVuc3VyZSB0aGF0IGFsbCBrZXlzIGFyZSBzdHJpbmdzIGFuZFxuXHQvLyB0aGF0IHRoZSBhcnJheSBpcyBtdXRhYmxlXG5cdGxldCBmaXJzdEJ5dGUgPSBpZFxuXHRpZiAoaGlnaEJ5dGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlkID0gaWQgPCAzMiA/IC0oKGhpZ2hCeXRlIDw8IDUpICsgaWQpIDogKChoaWdoQnl0ZSA8PCA1KSArIGlkKVxuXHRcdHN0cnVjdHVyZS5oaWdoQnl0ZSA9IGhpZ2hCeXRlXG5cdH1cblx0bGV0IGV4aXN0aW5nU3RydWN0dXJlID0gY3VycmVudFN0cnVjdHVyZXNbaWRdXG5cdC8vIElmIGl0IGlzIGEgc2hhcmVkIHN0cnVjdHVyZSwgd2UgbmVlZCB0byByZXN0b3JlIGFueSBjaGFuZ2VzIGFmdGVyIHJlYWRpbmcuXG5cdC8vIEFsc28gaW4gc2VxdWVudGlhbCBtb2RlLCB3ZSBtYXkgZ2V0IGluY29tcGxldGUgcmVhZHMgYW5kIHRodXMgZXJyb3JzLCBhbmQgd2UgbmVlZCB0byByZXN0b3JlXG5cdC8vIHRvIHRoZSBzdGF0ZSBwcmlvciB0byBhbiBpbmNvbXBsZXRlIHJlYWQgaW4gb3JkZXIgdG8gcHJvcGVybHkgcmVzdW1lLlxuXHRpZiAoZXhpc3RpbmdTdHJ1Y3R1cmUgJiYgKGV4aXN0aW5nU3RydWN0dXJlLmlzU2hhcmVkIHx8IHNlcXVlbnRpYWxNb2RlKSkge1xuXHRcdChjdXJyZW50U3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlcyB8fCAoY3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMgPSBbXSkpW2lkXSA9IGV4aXN0aW5nU3RydWN0dXJlXG5cdH1cblx0Y3VycmVudFN0cnVjdHVyZXNbaWRdID0gc3RydWN0dXJlXG5cdHN0cnVjdHVyZS5yZWFkID0gY3JlYXRlU3RydWN0dXJlUmVhZGVyKHN0cnVjdHVyZSwgZmlyc3RCeXRlKVxuXHRyZXR1cm4gc3RydWN0dXJlLnJlYWQoKVxufVxuY3VycmVudEV4dGVuc2lvbnNbMF0gPSAoKSA9PiB7fSAvLyBub3RlcGFjayBkZWZpbmVzIGV4dGVuc2lvbiAwIHRvIG1lYW4gdW5kZWZpbmVkLCBzbyB1c2UgdGhhdCBhcyB0aGUgZGVmYXVsdCBoZXJlXG5jdXJyZW50RXh0ZW5zaW9uc1swXS5ub0J1ZmZlciA9IHRydWVcblxuY3VycmVudEV4dGVuc2lvbnNbMHg0Ml0gPSAoZGF0YSkgPT4ge1xuXHQvLyBkZWNvZGUgYmlnaW50XG5cdGxldCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcblx0bGV0IHZhbHVlID0gQmlnSW50KGRhdGFbMF0gJiAweDgwID8gZGF0YVswXSAtIDB4MTAwIDogZGF0YVswXSk7XG5cdGZvciAobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHR2YWx1ZSA8PD0gQmlnSW50KDgpO1xuXHRcdHZhbHVlICs9IEJpZ0ludChkYXRhW2ldKTtcblx0fVxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbmxldCBlcnJvcnMgPSB7IEVycm9yLCBUeXBlRXJyb3IsIFJlZmVyZW5jZUVycm9yIH07XG5jdXJyZW50RXh0ZW5zaW9uc1sweDY1XSA9ICgpID0+IHtcblx0bGV0IGRhdGEgPSByZWFkKClcblx0cmV0dXJuIChlcnJvcnNbZGF0YVswXV0gfHwgRXJyb3IpKGRhdGFbMV0sIHsgY2F1c2U6IGRhdGFbMl0gfSlcbn1cblxuY3VycmVudEV4dGVuc2lvbnNbMHg2OV0gPSAoZGF0YSkgPT4ge1xuXHQvLyBpZCBleHRlbnNpb24gKGZvciBzdHJ1Y3R1cmVkIGNsb25lcylcblx0aWYgKGN1cnJlbnRVbnBhY2tyLnN0cnVjdHVyZWRDbG9uZSA9PT0gZmFsc2UpIHRocm93IG5ldyBFcnJvcignU3RydWN0dXJlZCBjbG9uZSBleHRlbnNpb24gaXMgZGlzYWJsZWQnKVxuXHRsZXQgaWQgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24gLSA0KVxuXHRpZiAoIXJlZmVyZW5jZU1hcClcblx0XHRyZWZlcmVuY2VNYXAgPSBuZXcgTWFwKClcblx0bGV0IHRva2VuID0gc3JjW3Bvc2l0aW9uXVxuXHRsZXQgdGFyZ2V0XG5cdC8vIFRPRE86IGhhbmRsZSBNYXBzLCBTZXRzLCBhbmQgb3RoZXIgdHlwZXMgdGhhdCBjYW4gY3ljbGU7IHRoaXMgaXMgY29tcGxpY2F0ZWQsIGJlY2F1c2UgeW91IHBvdGVudGlhbGx5IG5lZWQgdG8gcmVhZFxuXHQvLyBhaGVhZCBwYXN0IHJlZmVyZW5jZXMgdG8gcmVjb3JkIHN0cnVjdHVyZSBkZWZpbml0aW9uc1xuXHRpZiAodG9rZW4gPj0gMHg5MCAmJiB0b2tlbiA8IDB4YTAgfHwgdG9rZW4gPT0gMHhkYyB8fCB0b2tlbiA9PSAweGRkKVxuXHRcdHRhcmdldCA9IFtdXG5cdGVsc2Vcblx0XHR0YXJnZXQgPSB7fVxuXG5cdGxldCByZWZFbnRyeSA9IHsgdGFyZ2V0IH0gLy8gYSBwbGFjZWhvbGRlciBvYmplY3Rcblx0cmVmZXJlbmNlTWFwLnNldChpZCwgcmVmRW50cnkpXG5cdGxldCB0YXJnZXRQcm9wZXJ0aWVzID0gcmVhZCgpIC8vIHJlYWQgdGhlIG5leHQgdmFsdWUgYXMgdGhlIHRhcmdldCBvYmplY3QgdG8gaWRcblx0aWYgKHJlZkVudHJ5LnVzZWQpIC8vIHRoZXJlIGlzIGEgY3ljbGUsIHNvIHdlIGhhdmUgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8gb3JpZ2luYWwgdGFyZ2V0XG5cdFx0cmV0dXJuIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB0YXJnZXRQcm9wZXJ0aWVzKVxuXHRyZWZFbnRyeS50YXJnZXQgPSB0YXJnZXRQcm9wZXJ0aWVzIC8vIHRoZSBwbGFjZWhvbGRlciB3YXNuJ3QgdXNlZCwgcmVwbGFjZSB3aXRoIHRoZSBkZXNlcmlhbGl6ZWQgb25lXG5cdHJldHVybiB0YXJnZXRQcm9wZXJ0aWVzIC8vIG5vIGN5Y2xlLCBjYW4ganVzdCB1c2UgdGhlIHJldHVybmVkIHJlYWQgb2JqZWN0XG59XG5cbmN1cnJlbnRFeHRlbnNpb25zWzB4NzBdID0gKGRhdGEpID0+IHtcblx0Ly8gcG9pbnRlciBleHRlbnNpb24gKGZvciBzdHJ1Y3R1cmVkIGNsb25lcylcblx0aWYgKGN1cnJlbnRVbnBhY2tyLnN0cnVjdHVyZWRDbG9uZSA9PT0gZmFsc2UpIHRocm93IG5ldyBFcnJvcignU3RydWN0dXJlZCBjbG9uZSBleHRlbnNpb24gaXMgZGlzYWJsZWQnKVxuXHRsZXQgaWQgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24gLSA0KVxuXHRsZXQgcmVmRW50cnkgPSByZWZlcmVuY2VNYXAuZ2V0KGlkKVxuXHRyZWZFbnRyeS51c2VkID0gdHJ1ZVxuXHRyZXR1cm4gcmVmRW50cnkudGFyZ2V0XG59XG5cbmN1cnJlbnRFeHRlbnNpb25zWzB4NzNdID0gKCkgPT4gbmV3IFNldChyZWFkKCkpXG5cbmV4cG9ydCBjb25zdCB0eXBlZEFycmF5cyA9IFsnSW50OCcsJ1VpbnQ4JywnVWludDhDbGFtcGVkJywnSW50MTYnLCdVaW50MTYnLCdJbnQzMicsJ1VpbnQzMicsJ0Zsb2F0MzInLCdGbG9hdDY0JywnQmlnSW50NjQnLCdCaWdVaW50NjQnXS5tYXAodHlwZSA9PiB0eXBlICsgJ0FycmF5JylcblxubGV0IGdsYmwgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgPyBnbG9iYWxUaGlzIDogd2luZG93O1xuY3VycmVudEV4dGVuc2lvbnNbMHg3NF0gPSAoZGF0YSkgPT4ge1xuXHRsZXQgdHlwZUNvZGUgPSBkYXRhWzBdXG5cdGxldCB0eXBlZEFycmF5TmFtZSA9IHR5cGVkQXJyYXlzW3R5cGVDb2RlXVxuXHRpZiAoIXR5cGVkQXJyYXlOYW1lKSB7XG5cdFx0aWYgKHR5cGVDb2RlID09PSAxNikge1xuXHRcdFx0bGV0IGFiID0gbmV3IEFycmF5QnVmZmVyKGRhdGEubGVuZ3RoIC0gMSlcblx0XHRcdGxldCB1OCA9IG5ldyBVaW50OEFycmF5KGFiKVxuXHRcdFx0dTguc2V0KGRhdGEuc3ViYXJyYXkoMSkpXG5cdFx0XHRyZXR1cm4gYWI7XG5cdFx0fVxuXHRcdHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgdHlwZWQgYXJyYXkgZm9yIGNvZGUgJyArIHR5cGVDb2RlKVxuXHR9XG5cdC8vIHdlIGhhdmUgdG8gYWx3YXlzIHNsaWNlL2NvcHkgaGVyZSB0byBnZXQgYSBuZXcgQXJyYXlCdWZmZXIgdGhhdCBpcyB3b3JkL2J5dGUgYWxpZ25lZFxuXHRyZXR1cm4gbmV3IGdsYmxbdHlwZWRBcnJheU5hbWVdKFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSwgMSkuYnVmZmVyKVxufVxuY3VycmVudEV4dGVuc2lvbnNbMHg3OF0gPSAoKSA9PiB7XG5cdGxldCBkYXRhID0gcmVhZCgpXG5cdHJldHVybiBuZXcgUmVnRXhwKGRhdGFbMF0sIGRhdGFbMV0pXG59XG5jb25zdCBURU1QX0JVTkRMRSA9IFtdXG5jdXJyZW50RXh0ZW5zaW9uc1sweDYyXSA9IChkYXRhKSA9PiB7XG5cdGxldCBkYXRhU2l6ZSA9IChkYXRhWzBdIDw8IDI0KSArIChkYXRhWzFdIDw8IDE2KSArIChkYXRhWzJdIDw8IDgpICsgZGF0YVszXVxuXHRsZXQgZGF0YVBvc2l0aW9uID0gcG9zaXRpb25cblx0cG9zaXRpb24gKz0gZGF0YVNpemUgLSBkYXRhLmxlbmd0aFxuXHRidW5kbGVkU3RyaW5ncyA9IFRFTVBfQlVORExFXG5cdGJ1bmRsZWRTdHJpbmdzID0gW3JlYWRPbmx5SlNTdHJpbmcoKSwgcmVhZE9ubHlKU1N0cmluZygpXVxuXHRidW5kbGVkU3RyaW5ncy5wb3NpdGlvbjAgPSAwXG5cdGJ1bmRsZWRTdHJpbmdzLnBvc2l0aW9uMSA9IDBcblx0YnVuZGxlZFN0cmluZ3MucG9zdEJ1bmRsZVBvc2l0aW9uID0gcG9zaXRpb25cblx0cG9zaXRpb24gPSBkYXRhUG9zaXRpb25cblx0cmV0dXJuIHJlYWQoKVxufVxuXG5jdXJyZW50RXh0ZW5zaW9uc1sweGZmXSA9IChkYXRhKSA9PiB7XG5cdC8vIDMyLWJpdCBkYXRlIGV4dGVuc2lvblxuXHRpZiAoZGF0YS5sZW5ndGggPT0gNClcblx0XHRyZXR1cm4gbmV3IERhdGUoKGRhdGFbMF0gKiAweDEwMDAwMDAgKyAoZGF0YVsxXSA8PCAxNikgKyAoZGF0YVsyXSA8PCA4KSArIGRhdGFbM10pICogMTAwMClcblx0ZWxzZSBpZiAoZGF0YS5sZW5ndGggPT0gOClcblx0XHRyZXR1cm4gbmV3IERhdGUoXG5cdFx0XHQoKGRhdGFbMF0gPDwgMjIpICsgKGRhdGFbMV0gPDwgMTQpICsgKGRhdGFbMl0gPDwgNikgKyAoZGF0YVszXSA+PiAyKSkgLyAxMDAwMDAwICtcblx0XHRcdCgoZGF0YVszXSAmIDB4MykgKiAweDEwMDAwMDAwMCArIGRhdGFbNF0gKiAweDEwMDAwMDAgKyAoZGF0YVs1XSA8PCAxNikgKyAoZGF0YVs2XSA8PCA4KSArIGRhdGFbN10pICogMTAwMClcblx0ZWxzZSBpZiAoZGF0YS5sZW5ndGggPT0gMTIpLy8gVE9ETzogSW1wbGVtZW50IHN1cHBvcnQgZm9yIG5lZ2F0aXZlXG5cdFx0cmV0dXJuIG5ldyBEYXRlKFxuXHRcdFx0KChkYXRhWzBdIDw8IDI0KSArIChkYXRhWzFdIDw8IDE2KSArIChkYXRhWzJdIDw8IDgpICsgZGF0YVszXSkgLyAxMDAwMDAwICtcblx0XHRcdCgoKGRhdGFbNF0gJiAweDgwKSA/IC0weDEwMDAwMDAwMDAwMDAgOiAwKSArIGRhdGFbNl0gKiAweDEwMDAwMDAwMDAwICsgZGF0YVs3XSAqIDB4MTAwMDAwMDAwICsgZGF0YVs4XSAqIDB4MTAwMDAwMCArIChkYXRhWzldIDw8IDE2KSArIChkYXRhWzEwXSA8PCA4KSArIGRhdGFbMTFdKSAqIDEwMDApXG5cdGVsc2Vcblx0XHRyZXR1cm4gbmV3IERhdGUoJ2ludmFsaWQnKVxufSAvLyBub3RlcGFjayBkZWZpbmVzIGV4dGVuc2lvbiAwIHRvIG1lYW4gdW5kZWZpbmVkLCBzbyB1c2UgdGhhdCBhcyB0aGUgZGVmYXVsdCBoZXJlXG4vLyByZWdpc3RyYXRpb24gb2YgYnVsayByZWNvcmQgZGVmaW5pdGlvbj9cbi8vIGN1cnJlbnRFeHRlbnNpb25zWzB4NTJdID0gKCkgPT5cblxuZnVuY3Rpb24gc2F2ZVN0YXRlKGNhbGxiYWNrKSB7XG5cdGlmIChvblNhdmVTdGF0ZSlcblx0XHRvblNhdmVTdGF0ZSgpO1xuXHRsZXQgc2F2ZWRTcmNFbmQgPSBzcmNFbmRcblx0bGV0IHNhdmVkUG9zaXRpb24gPSBwb3NpdGlvblxuXHRsZXQgc2F2ZWRTdHJpbmdQb3NpdGlvbiA9IHN0cmluZ1Bvc2l0aW9uXG5cdGxldCBzYXZlZFNyY1N0cmluZ1N0YXJ0ID0gc3JjU3RyaW5nU3RhcnRcblx0bGV0IHNhdmVkU3JjU3RyaW5nRW5kID0gc3JjU3RyaW5nRW5kXG5cdGxldCBzYXZlZFNyY1N0cmluZyA9IHNyY1N0cmluZ1xuXHRsZXQgc2F2ZWRTdHJpbmdzID0gc3RyaW5nc1xuXHRsZXQgc2F2ZWRSZWZlcmVuY2VNYXAgPSByZWZlcmVuY2VNYXBcblx0bGV0IHNhdmVkQnVuZGxlZFN0cmluZ3MgPSBidW5kbGVkU3RyaW5nc1xuXG5cdC8vIFRPRE86IFdlIG1heSBuZWVkIHRvIHJldmlzaXQgdGhpcyBpZiB3ZSBkbyBtb3JlIGV4dGVybmFsIGNhbGxzIHRvIHVzZXIgY29kZSAoc2luY2UgaXQgY291bGQgYmUgc2xvdylcblx0bGV0IHNhdmVkU3JjID0gbmV3IFVpbnQ4QXJyYXkoc3JjLnNsaWNlKDAsIHNyY0VuZCkpIC8vIHdlIGNvcHkgdGhlIGRhdGEgaW4gY2FzZSBpdCBjaGFuZ2VzIHdoaWxlIGV4dGVybmFsIGRhdGEgaXMgcHJvY2Vzc2VkXG5cdGxldCBzYXZlZFN0cnVjdHVyZXMgPSBjdXJyZW50U3RydWN0dXJlc1xuXHRsZXQgc2F2ZWRTdHJ1Y3R1cmVzQ29udGVudHMgPSBjdXJyZW50U3RydWN0dXJlcy5zbGljZSgwLCBjdXJyZW50U3RydWN0dXJlcy5sZW5ndGgpXG5cdGxldCBzYXZlZFBhY2tyID0gY3VycmVudFVucGFja3Jcblx0bGV0IHNhdmVkU2VxdWVudGlhbE1vZGUgPSBzZXF1ZW50aWFsTW9kZVxuXHRsZXQgdmFsdWUgPSBjYWxsYmFjaygpXG5cdHNyY0VuZCA9IHNhdmVkU3JjRW5kXG5cdHBvc2l0aW9uID0gc2F2ZWRQb3NpdGlvblxuXHRzdHJpbmdQb3NpdGlvbiA9IHNhdmVkU3RyaW5nUG9zaXRpb25cblx0c3JjU3RyaW5nU3RhcnQgPSBzYXZlZFNyY1N0cmluZ1N0YXJ0XG5cdHNyY1N0cmluZ0VuZCA9IHNhdmVkU3JjU3RyaW5nRW5kXG5cdHNyY1N0cmluZyA9IHNhdmVkU3JjU3RyaW5nXG5cdHN0cmluZ3MgPSBzYXZlZFN0cmluZ3Ncblx0cmVmZXJlbmNlTWFwID0gc2F2ZWRSZWZlcmVuY2VNYXBcblx0YnVuZGxlZFN0cmluZ3MgPSBzYXZlZEJ1bmRsZWRTdHJpbmdzXG5cdHNyYyA9IHNhdmVkU3JjXG5cdHNlcXVlbnRpYWxNb2RlID0gc2F2ZWRTZXF1ZW50aWFsTW9kZVxuXHRjdXJyZW50U3RydWN0dXJlcyA9IHNhdmVkU3RydWN0dXJlc1xuXHRjdXJyZW50U3RydWN0dXJlcy5zcGxpY2UoMCwgY3VycmVudFN0cnVjdHVyZXMubGVuZ3RoLCAuLi5zYXZlZFN0cnVjdHVyZXNDb250ZW50cylcblx0Y3VycmVudFVucGFja3IgPSBzYXZlZFBhY2tyXG5cdGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0LCBzcmMuYnl0ZUxlbmd0aClcblx0cmV0dXJuIHZhbHVlXG59XG5leHBvcnQgZnVuY3Rpb24gY2xlYXJTb3VyY2UoKSB7XG5cdHNyYyA9IG51bGxcblx0cmVmZXJlbmNlTWFwID0gbnVsbFxuXHRjdXJyZW50U3RydWN0dXJlcyA9IG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEV4dGVuc2lvbihleHRlbnNpb24pIHtcblx0aWYgKGV4dGVuc2lvbi51bnBhY2spXG5cdFx0Y3VycmVudEV4dGVuc2lvbnNbZXh0ZW5zaW9uLnR5cGVdID0gZXh0ZW5zaW9uLnVucGFja1xuXHRlbHNlXG5cdFx0Y3VycmVudEV4dGVuc2lvbnNbZXh0ZW5zaW9uLnR5cGVdID0gZXh0ZW5zaW9uXG59XG5cbmV4cG9ydCBjb25zdCBtdWx0MTAgPSBuZXcgQXJyYXkoMTQ3KSAvLyB0aGlzIGlzIGEgdGFibGUgbWF0Y2hpbmcgYmluYXJ5IGV4cG9uZW50cyB0byB0aGUgbXVsdGlwbGllciB0byBkZXRlcm1pbmUgc2lnbmlmaWNhbnQgZGlnaXQgcm91bmRpbmdcbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0bXVsdDEwW2ldID0gKygnMWUnICsgTWF0aC5mbG9vcig0NS4xNSAtIGkgKiAwLjMwMTAzKSlcbn1cbmV4cG9ydCBjb25zdCBEZWNvZGVyID0gVW5wYWNrclxudmFyIGRlZmF1bHRVbnBhY2tyID0gbmV3IFVucGFja3IoeyB1c2VSZWNvcmRzOiBmYWxzZSB9KVxuZXhwb3J0IGNvbnN0IHVucGFjayA9IGRlZmF1bHRVbnBhY2tyLnVucGFja1xuZXhwb3J0IGNvbnN0IHVucGFja011bHRpcGxlID0gZGVmYXVsdFVucGFja3IudW5wYWNrTXVsdGlwbGVcbmV4cG9ydCBjb25zdCBkZWNvZGUgPSBkZWZhdWx0VW5wYWNrci51bnBhY2tcbmV4cG9ydCBjb25zdCBGTE9BVDMyX09QVElPTlMgPSB7XG5cdE5FVkVSOiAwLFxuXHRBTFdBWVM6IDEsXG5cdERFQ0lNQUxfUk9VTkQ6IDMsXG5cdERFQ0lNQUxfRklUOiA0XG59XG5sZXQgZjMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDEpXG5sZXQgdThBcnJheSA9IG5ldyBVaW50OEFycmF5KGYzMkFycmF5LmJ1ZmZlciwgMCwgNClcbmV4cG9ydCBmdW5jdGlvbiByb3VuZEZsb2F0MzIoZmxvYXQzMk51bWJlcikge1xuXHRmMzJBcnJheVswXSA9IGZsb2F0MzJOdW1iZXJcblx0bGV0IG11bHRpcGxpZXIgPSBtdWx0MTBbKCh1OEFycmF5WzNdICYgMHg3ZikgPDwgMSkgfCAodThBcnJheVsyXSA+PiA3KV1cblx0cmV0dXJuICgobXVsdGlwbGllciAqIGZsb2F0MzJOdW1iZXIgKyAoZmxvYXQzMk51bWJlciA+IDAgPyAwLjUgOiAtMC41KSkgPj4gMCkgLyBtdWx0aXBsaWVyXG59XG5leHBvcnQgZnVuY3Rpb24gc2V0UmVhZFN0cnVjdCh1cGRhdGVkUmVhZFN0cnVjdCwgbG9hZGVkU3RydWN0cywgc2F2ZVN0YXRlKSB7XG5cdHJlYWRTdHJ1Y3QgPSB1cGRhdGVkUmVhZFN0cnVjdDtcblx0b25Mb2FkZWRTdHJ1Y3R1cmVzID0gbG9hZGVkU3RydWN0cztcblx0b25TYXZlU3RhdGUgPSBzYXZlU3RhdGU7XG59XG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLUVTTSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07XG4iLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4gICAgICAgIGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbiAgICAgICAgfVxuICAgIH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKCgpID0+IHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ucnYgPSAoKSA9PiAoXCIxLjcuNlwiKSIsIl9fd2VicGFja19yZXF1aXJlX18ucnVpZCA9IFwiYnVuZGxlcj1yc3BhY2tAMS43LjZcIjsiLCJpbXBvcnQgeyBQYWNrciwgdW5wYWNrIH0gZnJvbSBcIkBjb2x5c2V1cy9tc2dwYWNrclwiO1xuaW1wb3J0IHsgZGVjb2RlLCBEZWNvZGVyLCBlbmNvZGUgfSBmcm9tIFwiQGNvbHlzZXVzL3NjaGVtYVwiO1xuaW1wb3J0IHsgTXlSb29tU3RhdGUgfSBmcm9tIFwiLi9zY2hlbWFzLnRzXCI7XG5pbXBvcnQgeyBQcm90b2NvbCwgQ3VzdG9tTWVzc2FnZVR5cGUgfSBmcm9tIFwiLi9lbnVtcy50c1wiO1xuXG5jb25zdCBmaWx0ZXJlZE1lc3NhZ2VzID0gW1wiUGluZ1wiLCBcIlBvbmdcIiwgXCJQb3NpdGlvblVwZGF0ZVwiXTtcblxuLy8gQHRzLWlnbm9yZVxuY29uc3Qgb3JpZ1dTID0gdW5zYWZlV2luZG93LldlYlNvY2tldDtcblxuY29uc3Qgc3RhdGUgPSBuZXcgTXlSb29tU3RhdGUoKTtcbmNvbnN0IGRlY29kZXIgPSBuZXcgRGVjb2RlcihzdGF0ZSk7XG5sZXQgbG9jYWxwbGF5ZXJpZCA9IG51bGw7XG4vLyBAdHMtaWdub3JlXG51bnNhZmVXaW5kb3cuc3RhdGUgPSBzdGF0ZTtcbi8vIEB0cy1pZ25vcmVcbnVuc2FmZVdpbmRvdy5kZWNvZGVyID0gZGVjb2RlcjtcblxuZnVuY3Rpb24gcHJvY2Vzc1BhY2tldChidWZmZXI6IEFycmF5QnVmZmVyLCBzb3VyY2U/OiBzdHJpbmcpIHtcblx0Y29uc3QgaXQgPSB7IG9mZnNldDogMSB9O1xuXHRjb25zdCBjb2RlID0gYnVmZmVyWzBdO1xuXHRpZiAoY29kZSA9PT0gUHJvdG9jb2wuSk9JTl9ST09NKSB7XG5cdFx0cmV0dXJuIFtjb2RlLCBcImpvaW5pbmchXCJdO1xuXHR9IGVsc2UgaWYgKGNvZGUgPT09IFByb3RvY29sLlJPT01fREFUQSkge1xuXHRcdGNvbnN0IHR5cGUgPSBkZWNvZGUuc3RyaW5nQ2hlY2soYnVmZmVyLCBpdCkgPyBkZWNvZGUuc3RyaW5nKGJ1ZmZlciwgaXQpIDogZGVjb2RlLm51bWJlcihidWZmZXIsIGl0KTtcblx0XHRjb25zdCBtZXNzYWdlID0gYnVmZmVyLmJ5dGVMZW5ndGggPiBpdC5vZmZzZXQgPyB1bnBhY2soYnVmZmVyLCB7IHN0YXJ0OiBpdC5vZmZzZXQgfSkgOiB1bmRlZmluZWQ7XG5cdFx0aWYgKGZpbHRlcmVkTWVzc2FnZXMuaW5kZXhPZihDdXN0b21NZXNzYWdlVHlwZVt0eXBlXSkgPT09IC0xKSB7XG5cdFx0XHQvL2NvbnNvbGUubG9nKHNvdXJjZSA9PT0gXCJyXCIgPyBcInJlY3ZcIiA6IFwic2VuZFwiLCBDdXN0b21NZXNzYWdlVHlwZVt0eXBlXSA/PyB0eXBlLCBtZXNzYWdlID8/IFwiZW1wdHlcIik7XG4gICAgICAgICAgICAgICAgfVxuXHRcdHJldHVybiBbY29kZSwgQ3VzdG9tTWVzc2FnZVR5cGVbdHlwZV0sIG1lc3NhZ2VdO1xuXHR9IGVsc2UgaWYgKGNvZGUgPT09IFByb3RvY29sLlJPT01fU1RBVEUpIHtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIGRlY29kZXIuZGVjb2RlKGJ1ZmZlciwgaXQpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vY29uc29sZS5lcnJvcihcIkBjb2x5c2V1cy9zY2hlbWEgZGVjb2RlIGVycm9yOlwiLCBlLCB7IGJ1ZmZlciB9KTtcblx0XHRcdHJldHVybiBbY29kZSwgXCJkZWNvZGVfZXJyb3JcIl07XG5cdFx0fVxuXHR9IGVsc2UgaWYgKGNvZGUgPT09IFByb3RvY29sLlJPT01fU1RBVEVfUEFUQ0gpIHtcblx0XHRyZXR1cm4gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLCBpdCk7XG5cdH0gZWxzZSBpZiAoY29kZSA9PT0gUHJvdG9jb2wuTEVBVkVfUk9PTSkge1xuXHRcdHJldHVybiBbY29kZSwgXCJMZWF2aW5nIHJvb20hXCJdO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBbY29kZSwgXCI/XCJdO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGVuY29kZVJvb21EYXRhKHR5cGU6IHN0cmluZyB8IG51bWJlciwgbWVzc2FnZTogdW5rbm93bikge1xuXHRjb25zdCBpdCA9IHsgb2Zmc2V0OiAxIH07XG5cdGNvbnN0IHBhY2tyID0gbmV3IFBhY2tyKCk7XG5cdHBhY2tyLmVuY29kZSh1bmRlZmluZWQpO1xuXHRwYWNrci5idWZmZXJbMF0gPSBQcm90b2NvbC5ST09NX0RBVEE7XG5cdGlmICh0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdGVuY29kZS5zdHJpbmcocGFja3IuYnVmZmVyLCB0eXBlLCBpdCk7XG5cdH0gZWxzZSB7XG5cdFx0ZW5jb2RlLm51bWJlcihwYWNrci5idWZmZXIsIHR5cGUsIGl0KTtcblx0fVxuXHRwYWNrci5wb3NpdGlvbiA9IDA7XG5cdHJldHVybiBtZXNzYWdlICE9PSB1bmRlZmluZWRcblx0XHQ/IHBhY2tyLnBhY2sobWVzc2FnZSwgMjA0OCArIGl0Lm9mZnNldCkgLy8gMjA0OCA9IFJFU0VSVkVfU1RBUlRfU1BBQ0Vcblx0XHQ6IHBhY2tyLmJ1ZmZlci5zdWJhcnJheSgwLCBpdC5vZmZzZXQpO1xufVxuLy8gQHRzLWlnbm9yZVxuZnVuY3Rpb24gc2VuZEN1c3RvbSh0eXBlOiBzdHJpbmcgfCBudW1iZXIsIG1lc3NhZ2U6IHVua25vd24pIHtcblx0Y29uc3QgYnVmID0gZW5jb2RlUm9vbURhdGEodHlwZSwgbWVzc2FnZSk7XG5cdC8vIEB0cy1pZ25vcmVcblx0dW5zYWZlV2luZG93LmN1cnJlbnRTb2NrZXQ/LnNlbmQoYnVmKTtcbn07XG5cbi8vIEB0cy1pZ25vcmVcbnVuc2FmZVdpbmRvdy5zZW5kQ3VzdG9tID0gc2VuZEN1c3RvbVxuXG5jbGFzcyBIb29rZWRXUyBleHRlbmRzIG9yaWdXUyB7XG5cdGNvbnN0cnVjdG9yKC4uLmFyZ3M6IGFueVtdKSB7XG5cdFx0Y29uc29sZS5sb2coYGNvbm5lY3RpbmcgdG8gJHthcmdzWzBdfWApO1xuXHRcdGNvbnN0IG1hdGNoID0gL1s/Jl1zZXNzaW9uSWQ9KFteJl0rKS8uZXhlYyhhcmdzWzBdKTtcblx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdGxvY2FscGxheWVyaWQgPSBtYXRjaFsxXTtcblx0XHRcdGNvbnNvbGUubG9nKFwiR290IHBsYXllciBpZDpcIiwgbG9jYWxwbGF5ZXJpZClcblx0XHR9XG5cdFx0c3VwZXIoLi4uYXJncyk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHVuc2FmZVdpbmRvdy5jdXJyZW50U29ja2V0ID0gdGhpcztcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0dGhpcy5zZW5kID0gKHBhY2tldDogYW55KSA9PiB7XG5cdFx0XHRjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShwYWNrZXQpO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc3QgcmVzcCA9IHByb2Nlc3NQYWNrZXQoYnVmZmVyLCBcInNcIik7XG5cdFx0XHRcdC8vY29uc29sZS5sb2cocmVzcFsxXSwgcmVzcFsyXSlcblx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0XHRyZXR1cm4gc3VwZXIuc2VuZChwYWNrZXQpO1xuXHRcdH07XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2dDogeyBkYXRhOiBBcnJheUJ1ZmZlciB9KSA9PiB7XG5cdFx0XHRjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShldnQuZGF0YSk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRwcm9jZXNzUGFja2V0KGJ1ZmZlciwgXCJyXCIpO1xuXHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHR9KTtcblx0fVxufVxuXG4vLyBAdHMtaWdub3JlXG51bnNhZmVXaW5kb3cuV2ViU29ja2V0ID0gSG9va2VkV1M7XG4vLzM0ID0gd2lsZGNhcnJvdFxuY29uc3QgcHJpY2VtYXAgPSB7XG4gICAgMDogMTAsXG4gICAgMTogNTAsXG4gICAgMjogMTAwLFxuICAgIDM6IDgwMCxcbiAgICA0OiAyMjUwLFxuICAgIDU6IDM3NTAsXG4gICAgODogNzUwMCxcbiAgICA5OiAxMDUwMCxcbiAgICAxMDogMTEyNTAsXG4gICAgMTE6IDM1MDAwLFxuICAgIDE3OiAzNzUwMDAwMCxcbiAgICAxODogMjAwLFxuICAgIDE5OiAxNTAwLFxuICAgIDIwOiAxOTUwLFxuICAgIDIxOiAzNzUwLFxuICAgIDIyOiA1MjUwLFxuICAgIDIzOiA2MDAwLFxuICAgIDI0OiA5MDAsXG4gICAgMjU6IDYzMDAsXG4gICAgMjY6IDYzMDAsXG4gICAgMjk6IDY2MDAsXG4gICAgMzA6IDE0MjUsXG4gICAgMzE6IDEwNTAwLFxuICAgIDMyOiAxNjUwLFxuICAgIDM1OiAzMDAwMDAwLFxuICAgIDM2OiAxMDAwMDAwMCxcbiAgICAzNzogNTAwMDAwMDAwLFxufTtcblxubGV0IGZhcm1pbmcgPSBmYWxzZTtcbmxldCBmYXJtaW5nMiA9IGZhbHNlO1xuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBrZXkgPSBldmVudC5rZXkudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChrZXkgPT09IFwicFwiKSB7XG4gICAgICAgIGZhcm1pbmcgPSAhZmFybWluZztcbiAgICAgICAgZmFybWluZzIgPSBmYWxzZTtcblx0XHRhbGVydChgRmFybWluZyB3aXRoIGJ1eWluZzogJHtmYXJtaW5nfSwgRmFybWluZyB3aXRob3V0IGJ1eWluZzogJHtmYXJtaW5nMn1gKTtcbiAgICAgICAgaWYgKGZhcm1pbmcpIHN0YXJ0RmFybWluZygpO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09IFwib1wiKSB7XG4gICAgICAgIGZhcm1pbmcyID0gIWZhcm1pbmcyO1xuICAgICAgICBmYXJtaW5nID0gZmFsc2U7XG5cdFx0YWxlcnQoYEZhcm1pbmcgd2l0aCBidXlpbmc6ICR7ZmFybWluZ30sIEZhcm1pbmcgd2l0aG91dCBidXlpbmc6ICR7ZmFybWluZzJ9YCk7XG4gICAgICAgIGlmIChmYXJtaW5nMikgc3RhcnRGYXJtaW5nMigpO1xuICAgIH1cbn0pO1xuXG4vLyBAdHMtaWdub3JlXG5hc3luYyBmdW5jdGlvbiBzdGFydEZhcm1pbmcoKSB7XG4gICAgd2hpbGUgKGZhcm1pbmcpIHtcbiAgICAgICAgYXdhaXQgZmFybW9uY2UoKTtcbiAgICAgICAgYXdhaXQgc2xlZXAoMTAwMDApO1xuICAgIH1cbn1cblxuLy8gQHRzLWlnbm9yZVxuYXN5bmMgZnVuY3Rpb24gc3RhcnRGYXJtaW5nMigpIHtcbiAgICB3aGlsZSAoZmFybWluZzIpIHtcbiAgICAgICAgYXdhaXQgZmFybW9uY2V3aXRob3V0YnV5aW5nKCk7XG4gICAgICAgIGF3YWl0IHNsZWVwKDEwMDAwKTtcbiAgICB9XG59XG5cbi8vIEB0cy1pZ25vcmVcbmFzeW5jIGZ1bmN0aW9uIGZhcm1vbmNld2l0aG91dGJ1eWluZygpIHtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZ2V0R2FyZGVuKCkucGxhbnRzLml0ZW1zKSB7XG4gICAgICAgIGlmIChpdGVtLmlzRnJ1aXRUcmVlKSB7XG4gICAgICAgICAgICBjb25zdCBmcnVpdGlkID0gaXRlbS5wbGFudElkO1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgaXRlbS5mcnVpdHMuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgQ29sbGVjdFBsYW50KGZydWl0aWQsIHZhbHVlLnBsYW50SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuXHRcdFx0Q29sbGVjdFBsYW50KGl0ZW0ucGxhbnRJZClcblx0XHR9XG4gICAgfVxuXG4gICAgc2VsbEl0ZW1zKCk7XG59O1xuXG5mdW5jdGlvbiBwcmVzc3NwYWNlKCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJjYW52YXNcIik7XG4gICAgY29uc3QgZG93biA9IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5ZG93blwiLCB7XG4gICAgICAgIGtleTogXCIgXCIsXG4gICAgICAgIGNvZGU6IFwiU3BhY2VcIixcbiAgICAgICAga2V5Q29kZTogMzIsXG4gICAgICAgIHdoaWNoOiAzMixcbiAgICAgICAgYnViYmxlczogdHJ1ZVxuICAgIH0pO1xuXG4gICAgY29uc3QgdXAgPSBuZXcgS2V5Ym9hcmRFdmVudChcImtleXVwXCIsIHtcbiAgICAgICAga2V5OiBcIiBcIixcbiAgICAgICAgY29kZTogXCJTcGFjZVwiLFxuICAgICAgICBrZXlDb2RlOiAzMixcbiAgICAgICAgd2hpY2g6IDMyLFxuICAgICAgICBidWJibGVzOiB0cnVlXG4gICAgfSk7XG5cbiAgICBjYW52YXMuZGlzcGF0Y2hFdmVudChkb3duKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IGNhbnZhcy5kaXNwYXRjaEV2ZW50KHVwKSwgNTApO1xufVxuXG4vLyBAdHMtaWdub3JlXG5hc3luYyBmdW5jdGlvbiBmYXJtb25jZSgpIHtcbiAgICBsZXQgY29sbGVjdGVkY291bnQgPSAwXG4gICAgY29uc3QgbWF4X2NvbGxlY3QgPSAxMDBcbiAgICBwcmVzc3NwYWNlKClcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZ2V0R2FyZGVuKCkucGxhbnRzLml0ZW1zKSB7XG4gICAgICAgIGlmIChpdGVtLmlzRnJ1aXRUcmVlKSB7XG4gICAgICAgICAgICBjb25zdCBmcnVpdGlkID0gaXRlbS5wbGFudElkO1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgaXRlbS5mcnVpdHMuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgQ29sbGVjdFBsYW50KGZydWl0aWQsIHZhbHVlLnBsYW50SWQpO1xuICAgICAgICAgICAgICAgIGNvbGxlY3RlZGNvdW50KytcblxuICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0ZWRjb3VudCA+PSBtYXhfY29sbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxsSXRlbXMoKVxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWRjb3VudCA9IDBcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2xlZXAoMTAwMClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cdFx0XHRDb2xsZWN0UGxhbnQoaXRlbS5wbGFudElkKVxuICAgICAgICAgICAgY29sbGVjdGVkY291bnQrK1xuICAgICAgICAgICAgaWYgKGNvbGxlY3RlZGNvdW50ID49IG1heF9jb2xsZWN0KSB7XG4gICAgICAgICAgICAgICAgc2VsbEl0ZW1zKClcbiAgICAgICAgICAgICAgICBjb2xsZWN0ZWRjb3VudCA9IDBcbiAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcCgxMDAwKVxuICAgICAgICAgICAgfVxuXHRcdH1cbiAgICB9XG5cbiAgICBpZiAoY29sbGVjdGVkY291bnQgPiAwKSB7XG4gICAgICAgIHNlbGxJdGVtcygpXG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gZmluZENsb3Nlc3RTZWVkKGdldFBsYXllcigpLmNvaW5zKTtcblxuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubWF4QW1vdW50OyBpKyspIHtcbiAgICAgICAgICAgIGJ1eXNlZWQoTnVtYmVyKHJlc3VsdC5pZCkpO1xuICAgICAgICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IHBsYW50YWxsc2VlZHMoKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBzbGVlcChtczogbnVtYmVyKSB7XG5cdC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5cbmxldCBsYXN0eSA9IE51bWJlcih3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJSZWN0ZS1sYXN0eVwiKSB8fCBcIjBcIik7XG5cbi8vIEB0cy1pZ25vcmVcbmFzeW5jIGZ1bmN0aW9uIHBsYW50YWxsc2VlZHMoKSB7XG4gICAgbGV0IGhhc1NlZWRzID0gdHJ1ZTtcblxuICAgIHdoaWxlIChoYXNTZWVkcykge1xuICAgICAgICBoYXNTZWVkcyA9IGZhbHNlO1xuXG5cdFx0Ly9AdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IG15aW52ZW50b3J5ID0gQXJyYXkuZnJvbShnZXRQbGF5ZXIoKS5pbnZlbnRvcnkuZW50cmllcygpKTtcblxuICAgICAgICBmb3IgKGNvbnN0IFssIGRhdGFdIG9mIG15aW52ZW50b3J5KSB7XG4gICAgICAgICAgICBpZiAoZGF0YS50eXBlID09PSBcInNlZWRcIiAmJiBkYXRhLmFtb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBoYXNTZWVkcyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEuYW1vdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgUGxhbnRTZWVkKGRhdGEuaWQsIGxhc3R5LCBsYXN0eSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGFzdHkgKz0gMC4wMDAwMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3R5ID4gMykgbGFzdHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJSZWN0ZS1sYXN0eVwiLCBsYXN0eS50b1N0cmluZygpKTtcblxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcCgxMDAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDbG9zZXN0U2VlZChjb2luczogbnVtYmVyKTogeyBpZDogbnVtYmVyOyBtYXhBbW91bnQ6IG51bWJlciB9IHwgbnVsbCB7XG4gICAgbGV0IGNsb3Nlc3RJZDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IGNsb3Nlc3RQcmljZSA9IC1JbmZpbml0eTtcbiAgICBsZXQgYXZhaWxhYmxlUXVhbnRpdHkgPSAwO1xuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGN1cnJlbnRTdG9jayA9IEFycmF5LmZyb20oZ2V0UGxheWVyKCkuc3RvY2suZW50cmllcygpKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHF1YW50aXR5XSBvZiBjdXJyZW50U3RvY2spIHtcbiAgICAgICAgaWYgKHByaWNlbWFwLmhhc093blByb3BlcnR5KGtleSkgJiYgcXVhbnRpdHkgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBwcmljZSA9IHByaWNlbWFwW2tleV07XG4gICAgICAgICAgICBpZiAocHJpY2UgPD0gY29pbnMgJiYgcHJpY2UgPiBjbG9zZXN0UHJpY2UpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0UHJpY2UgPSBwcmljZTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0SWQgPSBrZXk7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlUXVhbnRpdHkgPSBxdWFudGl0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xvc2VzdElkID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICBsZXQgbWF4QW1vdW50ID0gTWF0aC5taW4oTWF0aC5mbG9vcihjb2lucyAvIGNsb3Nlc3RQcmljZSksIGF2YWlsYWJsZVF1YW50aXR5KTtcblx0aWYgKCFtYXhBbW91bnQpIG1heEFtb3VudCA9IDBcbiAgICByZXR1cm4geyBpZDogY2xvc2VzdElkLCBtYXhBbW91bnQgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UGxheWVyKCkge1xuICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgLy8gQHRzLWlnbm9yZVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdGF0ZS5wbGF5ZXJzLmVudHJpZXMgPyBzdGF0ZS5wbGF5ZXJzLmVudHJpZXMoKSA6IE9iamVjdC5lbnRyaWVzKHN0YXRlLnBsYXllcnMpKSB7XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLnBsYXllcklkID09PSBsb2NhbHBsYXllcmlkKSB7XG5cdFx0cmV0dXJuIHZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEdhcmRlbigpIHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gIC8vIEB0cy1pZ25vcmVcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3RhdGUuZ2FyZGVucy5lbnRyaWVzID8gc3RhdGUuZ2FyZGVucy5lbnRyaWVzKCkgOiBPYmplY3QuZW50cmllcyhzdGF0ZS5nYXJkZW5zKSkge1xuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5vd25lcklkID09PSBsb2NhbHBsYXllcmlkKSB7XG5cdFx0cmV0dXJuIHZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1eXNlZWQoc2VlZElkOiBudW1iZXIpIHtcblx0c2VuZEN1c3RvbSg4Nywge1xuICAgIFwic2VlZElkXCI6IHNlZWRJZCxcbiAgICBcInF1YW50aXR5XCI6IDEsXG4gICAgXCJwYXlXaXRoR2Vtc1wiOiBmYWxzZVxuXHR9KVxufVxuXG5mdW5jdGlvbiBDb2xsZWN0UGxhbnQocGxhbnRJZDpudW1iZXIsIGZydWl0SWQ6bnVtYmVyID0gMCkge1xuXHRpZiAoZnJ1aXRJZCkge1xuXHRcdHNlbmRDdXN0b20oNTYsIHtcblx0XHRcdFwicGxhbnRJZFwiOiBwbGFudElkLFxuXHRcdFx0XCJmcnVpdElkXCI6IGZydWl0SWQsXG5cdFx0XHRcImdhcmRlbklkXCI6IGxvY2FscGxheWVyaWRcblx0XHR9KVxuXHR9IGVsc2Uge1xuXHRcdHNlbmRDdXN0b20oNTYsIHtcblx0XHRcdFwicGxhbnRJZFwiOiBwbGFudElkLFxuXHRcdFx0XCJnYXJkZW5JZFwiOiBsb2NhbHBsYXllcmlkXG5cdFx0fSlcblx0fVxufVxuXG4vLyBAdHMtaWdub3JlXG5mdW5jdGlvbiBQbGFudFNlZWQgKHNlZWRJZDpudW1iZXIsIHBvc3g6bnVtYmVyLCBwb3h5Om51bWJlcikge1xuXHRzZW5kQ3VzdG9tKDU5LCB7XG4gICAgXHRcInNlZWRJZFwiOiBzZWVkSWQsXG4gICAgXHRcInhcIjogcG9zeCxcbiAgICBcdFwieVwiOiBwb3h5XG5cdH0pXG59XG5cbmZ1bmN0aW9uIHNlbGxJdGVtcygpIHtcblx0c2VuZEN1c3RvbSg0OCwge1wiaW52ZW50b3J5TG9va3VwSWRcIjogLTF9KVxufVxuIl0sIm5hbWVzIjpbIlByb3RvY29sIiwiQ3VzdG9tTWVzc2FnZVR5cGUiLCJTY2hlbWEiLCJ0eXBlIiwiQXJyYXlTY2hlbWEiLCJNYXBTY2hlbWEiLCJDb2x5VmVjdG9yMyIsIkNvbHlSaWdpZCIsIkludmVudG9yeUl0ZW0iLCJQdWJsaWNVc2VyRGF0YSIsIlBsYXllciIsIkVnZyIsIlBldCIsIlBsYW50IiwiU3ByaW5rbGVyIiwiR2FyZGVuIiwiTXlSb29tU3RhdGUiLCJQYWNrciIsInVucGFjayIsImRlY29kZSIsIkRlY29kZXIiLCJlbmNvZGUiLCJmaWx0ZXJlZE1lc3NhZ2VzIiwib3JpZ1dTIiwidW5zYWZlV2luZG93Iiwic3RhdGUiLCJkZWNvZGVyIiwibG9jYWxwbGF5ZXJpZCIsInByb2Nlc3NQYWNrZXQiLCJidWZmZXIiLCJzb3VyY2UiLCJpdCIsImNvZGUiLCJtZXNzYWdlIiwidW5kZWZpbmVkIiwiZSIsImVuY29kZVJvb21EYXRhIiwicGFja3IiLCJzZW5kQ3VzdG9tIiwiX3Vuc2FmZVdpbmRvd19jdXJyZW50U29ja2V0IiwiYnVmIiwiSG9va2VkV1MiLCJfa2V5IiwiYXJncyIsImNvbnNvbGUiLCJtYXRjaCIsInBhY2tldCIsIlVpbnQ4QXJyYXkiLCJyZXNwIiwiX3RoaXMiLCJldnQiLCJwcmljZW1hcCIsImZhcm1pbmciLCJmYXJtaW5nMiIsImRvY3VtZW50IiwiZXZlbnQiLCJrZXkiLCJhbGVydCIsInN0YXJ0RmFybWluZyIsInN0YXJ0RmFybWluZzIiLCJmYXJtb25jZSIsInNsZWVwIiwiZmFybW9uY2V3aXRob3V0YnV5aW5nIiwiX2l0ZXJhdG9yRXJyb3IiLCJpdGVtIiwiZnJ1aXRpZCIsIl9pdGVyYXRvckVycm9yMSIsInZhbHVlIiwiZ2V0R2FyZGVuIiwiQ29sbGVjdFBsYW50Iiwic2VsbEl0ZW1zIiwicHJlc3NzcGFjZSIsImNhbnZhcyIsImRvd24iLCJLZXlib2FyZEV2ZW50IiwidXAiLCJzZXRUaW1lb3V0IiwiY29sbGVjdGVkY291bnQiLCJtYXhfY29sbGVjdCIsInJlc3VsdCIsImkiLCJmaW5kQ2xvc2VzdFNlZWQiLCJnZXRQbGF5ZXIiLCJidXlzZWVkIiwiTnVtYmVyIiwicGxhbnRhbGxzZWVkcyIsIm1zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJsYXN0eSIsIndpbmRvdyIsImhhc1NlZWRzIiwibXlpbnZlbnRvcnkiLCJkYXRhIiwiQXJyYXkiLCJQbGFudFNlZWQiLCJjb2lucyIsImNsb3Nlc3RJZCIsImNsb3Nlc3RQcmljZSIsIkluZmluaXR5IiwiYXZhaWxhYmxlUXVhbnRpdHkiLCJjdXJyZW50U3RvY2siLCJxdWFudGl0eSIsInByaWNlIiwibWF4QW1vdW50IiwiTWF0aCIsInJlc3VsdHMiLCJPYmplY3QiLCJzZWVkSWQiLCJwbGFudElkIiwiZnJ1aXRJZCIsInBvc3giLCJwb3h5Il0sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0EsSUFBSSxLQUE0RCxXQUFXLE9BQU87QUFDbEYsSUFBSSxDQUN1RztBQUMzRyxDQUFDLEVBQUUsSUFBSSx3QkFBd0I7O0FBRS9CLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw4Q0FBOEM7O0FBRW5EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsTUFBTSxvQkFBb0IsTUFBTTtBQUN4RTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSxrRkFBa0Ysb0JBQW9CO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1DQUFtQztBQUM1RDtBQUNBLDJCQUEyQiwrQ0FBK0M7QUFDMUU7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3Q0FBd0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9CQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTyxrREFBa0QsNENBQTRDO0FBQ2pIO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU8sa0NBQWtDLHVCQUF1QixHQUFHLE1BQU07QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0JBQXNCLEdBQUcsb0NBQW9DLHVCQUF1QixVQUFVO0FBQy9ILDhDQUE4QyxhQUFhLHNCQUFzQixZQUFZLGtCQUFrQix1QkFBdUIsR0FBRyxNQUFNO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVUsdUJBQXVCLGdDQUFnQyxvQkFBb0IsMEJBQTBCLEdBQUcsTUFBTTtBQUN0SztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU8sd0RBQXdEO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlCQUF5QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3QkFBd0I7O0FBRWxEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQ0FBZ0M7O0FBRWpFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdCQUF3Qjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUIsb0NBQW9DLE1BQU07QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLE1BQU0sbUJBQW1CLGlCQUFpQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVyxFQUFFLGlCQUFpQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsTUFBTTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJCQUEyQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG1CQUFtQixPQUFPLG1CQUFtQjtBQUNwRiw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJIQUEySDtBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvR0FBb0c7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQSxtRUFBbUUsU0FBUztBQUM1RTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixlQUFlO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsZUFBZTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNkZBQTZGLGVBQWU7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixlQUFlO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixVQUFVLE9BQU8sV0FBVyxPQUFPO0FBQ25DO0FBQ0E7QUFDQSxZQUFZLE9BQU8sV0FBVyxPQUFPLHlCQUF5QixPQUFPO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsa0JBQWtCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNW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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QyxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EscUJBQXFCLFdBQVcsR0FBRyxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsZ0JBQWdCLFdBQVcsR0FBRyxJQUFJLEtBQUssYUFBYTtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixLQUFLLG1EQUFtRCxjQUFjO0FBQ3pGLEdBQUc7QUFDSDtBQUNBO0FBQ0EsK0JBQStCLElBQUk7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNLGFBQWEsU0FBUztBQUN0RDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdCQUFnQjtBQUN6QixjQUFjLG9CQUFvQixFQUFFLElBQUk7QUFDeEM7QUFDQSxZQUFZLGdCQUFnQixFQUFFLElBQUk7QUFDbEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEdBQUcsU0FBUyxHQUFHLEtBQUsscUJBQXFCLEVBQUUsRUFBRTtBQUNwRSxRQUFRO0FBQ1IseUJBQXlCLEdBQUcsS0FBSyx5QkFBeUIsRUFBRSxFQUFFO0FBQzlELG1CQUFtQix5QkFBeUIsRUFBRSxFQUFFO0FBQ2hEO0FBQ0EsTUFBTTtBQUNOLG9CQUFvQixJQUFJLEVBQUUsR0FBRyxTQUFTLElBQUksRUFBRSxFQUFFO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxjQUFjLFNBQVMsT0FBTztBQUN4RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDJFQUEwQzs7QUFF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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpQ0FBaUM7QUFDdkM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQ0FBTTtBQUNuQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsaUNBQWlDLDBCQUEwQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxtRkFBbUYsTUFBTTtBQUN6RixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFLE9BQU8sMEpBQTBKLEVBQUU7QUFDbks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRUE7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxPQUFPO0FBQ1Y7QUFD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