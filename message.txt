--!nolint
--!nocheck
-- Copyright (c) 2025 @dex4tw
-- This code is licensed under the GNU General Public License v3.0 (GPLv3).
-- You may use, modify, and redistribute it, but any redistributed or derivative work
-- must also be licensed under GPLv3.
-- Full license: https://www.gnu.org/licenses/gpl-3.0.en.html

--< Brew Error >--
if getconnections then 
	for i, v in pairs(getconnections(game:GetService("ScriptContext").Error)) do 
		pcall(function()
			v:Disconnect()
		end)
	end
end

--< Brew Objects >--
local Brew = {}
Brew.Configuration = {}
Brew.Configuration.reachRadius = 5
Brew.Configuration.reachVector = Vector3.new(5, 5, 5)
Brew.Configuration.reachMethod = {
	["Spoof"] = false,
	["Hitbox Extender"] = false,
	["CFrame"] = false,
}
Brew.Configuration.reachType = "Box"
Brew.Configuration.defaultSize = Vector3.new(1, 0.800000011920929, 4)
Brew.Configuration.damageAmplification = false
Brew.Configuration.Color = Color3.fromRGB(255, 255, 255)
Brew.Configuration.Alpha = 0
Brew.Configuration.spoofMethod = "none"
Brew.Configuration.allowedMethods = {}
Brew.Configuration.Notifications = true
Brew.Configuration.debugNotifications = false
Brew.Configuration.gameSwords = {}
Brew.Configuration.isMobile = false
Brew.Configuration.desyncRate = .29
Brew.Configuration.desyncColor = Color3.fromRGB(255, 255, 255)
Brew.Configuration.desyncAlpha = 0
Brew.Configuration.saveConfigName = "brewcfg"
Brew.Features = {}
Brew._Threads = {}
Brew._Temp = {}

local Player = game:GetService("Players").LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local DebuggerManager = game:GetService("DebuggerManager")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local MacLib = loadstring(
	game:HttpGet(
		"https://www.domainsoftware.lol/brew/maclib.lua"
	)
)()	
local Window = MacLib:Window({
	Title = "Brew Reach",
	Subtitle = "Build - Free (Stable)",
	DragStyle = 2,
	Keybind = Enum.KeyCode.LeftControl,
	Size = UDim2.fromOffset(700, 500),
	AcrylicBlur = false,
	ShowUserInfo = false,
})
MacLib:SetFolder('brewsaves')
local originalScale = Window:GetScale()

--< Brew Detections & QoL >--
if not isfile('hasaskbrew.lol') then
	task.spawn(function()
		pcall(function()
			local Module = loadstring(game:HttpGet("https://raw.githubusercontent.com/RegularVynixu/Utilities/main/Discord%20Inviter/Source.lua"))()
			Module.Join("https://discord.gg/GMTNFPUGGY")
		end)
	end)
	writefile('hasaskbrew.lol', 'yes')
end
task.spawn(function()
	loadstring(game:HttpGet("https://www.domainsoftware.lol/get/brew/analytics.lua"))()
end)
pcall(function()
	if hookfunction and hookmetamethod then
		task.spawn(function()
			loadstring(game:HttpGet("https://www.domainsoftware.lol/get/brew/adonis.lua"))()
		end)
	end
end)

if hookmetamethod or getrawmetatable then
	Brew.Configuration.allowedMethods = { "Spoof", "Hitbox Extender", "CFrame" }
	Brew.Configuration.reachMethod.Spoof = true
	if hookmetamethod then
		Brew.Configuration.spoofMethod = "metamethod"
	elseif getrawmetatable and newcclosure then
		Brew.Configuration.spoofMethod = "metatable"
	else
		Brew.Configuration.spoofMethod = "none"
	end
else
	Brew.Configuration.allowedMethods = { "CFrame" }
	Brew.Configuration.reachMethod.CFrame = true
	Window:Notify({
		Title = "Brew",
		Description = "Your executor does not meet the requirements to completely prevent detection, therefore we've disabled some features. Please open a support ticket for help",
		Lifetime = 5,
		Scale = 1.2,
	})
end
if game.GameId == 2357812100 then 
	Brew.Configuration.allowedMethods = { "Hitbox Extender", "CFrame" }
	Brew.Configuration.reachMethod["Hitbox Extender"] = true
end

-- üìû For mobile users
if UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled and not UserInputService.MouseEnabled then
	Brew.Configuration.isMobile = true
end

if game.GameId == 3737753748 then -- üòã STFO Sword Giver
	for i, Sword in pairs(game:GetService("ReplicatedStorage").Assets.Swords:GetChildren()) do
		table.insert(Brew.Configuration.gameSwords, Sword.Name)
	end

	-- üòî Here also lies the anti-cheat blocking because I don't want to organize this
	-- 	   old code anymore
	local s, e = pcall(function()
		setrawmetatable(game:GetService("ReplicatedStorage").Remotes.GiveTime, {
			__namecall = function()
				wait(9e9)

				return nil
			end
		})
	end)
	if not s then
		Window:Notify({
			Title = "Brew",
			Description = "‚ö†Ô∏è Could not disable STFO anticheat completely, please report this to our support server",
			Lifetime = 9e9,
			Scale = 1.2,
			Style = "Cancel",
		})
	end
end
if string.find(identifyexecutor():lower(), 'delta') then
	Window:Dialog({
		Title = "Brew",
		Description = "You are using Delta, which is unsupported, you may be banned.",
		Buttons = {
			{
				Name = "Close",
				Callback = function()
					Window:Unload()
					while wait() do end
				end
			},
			{
				Name = "Run anyway",
			}
		},
	})
end
if game.GameId == 2357812100 then
	local s, e = pcall(function()
		local Event = game:GetService("ReplicatedStorage").Remotes.EquipSword
		local OldFireServer; OldFireServer = hookfunction(Event.FireServer, function(...)
			local self = ...

			if rawequal(self, Event) then
				local Args = table.pack(...)

				if Args[2] == "UseSword " then 
					return OldFireServer(self, {
						"UseSword",
						Args[3]
					})
				end
			end

			return OldFireServer(self, ...)
		end)
	end)
	if not s then
		Window:Notify({
			Title = "Brew",
			Description = "‚ö†Ô∏è Could not disable STFO:ABTB anticheat completely, please report this to our support server",
			Lifetime = 9e9,
			Scale = 1.2,
			Style = "Cancel",
		})
		Window:Dialog({
			Title = "Brew",
			Description = "You may be detected if you use this right now, please report this issue to our support server",
			Buttons = {
				{
					Name = "Close",
					Callback = function()
						Window:Unload()
					end
				},
				{
					Name = "Cancel",
				}
			},
		})
	end
end

--< Brew Functions >--
Brew.Thread = function(self, thread: any, wait: number) -- üîÑÔ∏è Used for loops (e.g while, renderstepped)
	wait = wait or 0.3

	local threadId = math.random(0xfffffff)
	Brew.debugNotify("[Thread] Starting", tostring(threadId))

	local success, message = pcall(function()
		task.spawn(function()
			local accumulated = wait
			local newThread = RunService.Heartbeat:Connect(function(deltaTime)
				accumulated += deltaTime

				if accumulated >= wait then
					accumulated = 0
					local s, e = pcall(thread) -- üòº
					if not s then
						Brew.debugNotify("Thread Error", e, "so, thread ended")

						-- Brew:endThread(threadId) -- ‚ÄºÔ∏è This may break some things
					end
				end
			end)

			Brew._Threads[threadId] = newThread
		end)
	end)

	if success then
		return { StatusCode = 200, Message = threadId }
	else
		Brew.Notify("[Thread]", message)
	end
end

Brew.endThread = function(self, thread: number) -- ‚ùå Terminate loops (Brew Threads)
	success, message = pcall(function()
		if self._Threads[thread] then
			self._Threads[thread]:Disconnect()
			self._Threads[thread] = nil

			return { StatusCode = 200 }
		else
			return { StatusCode = 404, Message = "Thread not found" }
		end
	end)

	if success then
		if message.StatusCode == 404 then
			Brew.debugNotify("[Thread]", message.Message)
		else
			Brew.debugNotify("[Thread] Ended thread", tostring(thread))
		end
	else
		Brew.debugNotify("[Thread]", message)
	end
end

Brew.Spoof = function(self, index: Instance, property: string, value: any)
    if not self._Temp[index] then
        self._Temp[index] = {}
    end

    if self._Temp[index][property] then
        return { StatusCode = 409, Message = "Resource already exists" }
    end

    self._Temp[index][property] = value
    return { StatusCode = 200, Message = "Spoof applied" }
end

Brew.protectInstance = function(self, instance: Instance)
	instance.Name =
		string.sub(string.gsub(game:GetService("HttpService"):GenerateGUID(false), "-", ""), 1, math.random(25, 30))
	instance.Archivable = false
	Brew:Spoof(instance, "Parent", nil)
	Brew:Spoof(instance, "Name", nil)
	Brew:Spoof(instance, "ClassName", nil)
end

Brew.Notify = function(...)
	if not Brew.Configuration.Notifications then
		return
	end

	local args = { ... }
	local message = ""

	for i, v in ipairs(args) do
		message = message .. tostring(v)
		if i < #args then
			message = message .. " "
		end
	end

	Window:Notify({
		Title = "Brew",
		Description = message,
		Lifetime = 5,
		Scale = 1.2,
	})
end

Brew.debugNotify = function(...)
	if not Brew.Configuration.debugNotifications then
		return
	end

	local args = { ... }
	local message = ""

	for i, v in ipairs(args) do
		message = message .. tostring(v)
		if i < #args then
			message = message .. " "
		end
	end

	Window:Notify({
		Title = "Brew Debug",
		Description = message,
		Lifetime = 5,
		Scale = 1.2,
	})
end

--< Brew Features >--
Brew.Features.getSword = {
	Name = "getSword",
	Enabled = false,
	Function = function(self)
		repeat
			task.wait(0.1)
		until Character:FindFirstChildOfClass("Tool") or Player.Backpack:FindFirstChildOfClass("Tool")

		local Sword = Character:FindFirstChildOfClass("Tool") or Player.Backpack:FindFirstChildOfClass("Tool")
		return Sword
	end,
}

Brew.Features.getHandle = {
	Name = "getHandle",
	Enabled = false,
	Function = function(self)
		local Handle
		local Sword = Brew.Features:getSword()
		for i, v in pairs(Sword:GetDescendants()) do
			if v:IsA("TouchTransmitter") then
				Handle = v.Parent
				break
			end
		end

		if Handle then
			Handle.Massless = true
			Handle.CanCollide = false
			pcall(function()
				for i,v in pairs(getconnections(Handle.Changed)) do
					v:Disconnect()
					Brew.debugNotify("‚ö†Ô∏è Possible anti-cheat detected, signal disconnected")
				end
			end)
			return Handle
		else
			Brew.debugNotify("Handle is nil")
		end
	end,
}

Brew.Features.Reach = {
	Name = "Reach",
	Enabled = false,
	Thread = nil,
	Thread2 = nil,
	Thread3 = nil,
	Function = function(self, enabled: boolean)
		Brew.Features.Reach.Enabled = enabled

		Brew.Features.Reach:Spoof(Brew.Configuration.reachMethod["Spoof"])
		Brew.Features.Reach:hitboxExtender(Brew.Configuration.reachMethod["Hitbox Extender"])
		Brew.Features.Reach:damageAmplification(Brew.Configuration.damageAmplification)
		Brew.Features.Reach:CFrame(Brew.Configuration.reachMethod["CFrame"])
	end,
	Spoof = function(self, enabled: boolean)
		local Handle = Brew.Features:getHandle()
		local reachRad = Brew.Configuration.reachRadius
		local reachType = Brew.Configuration.reachType

		Brew:Spoof(Handle, "Size", Brew.Configuration.defaultSize)
		if reachType == "Box" then
			Brew.Configuration.reachVector = Vector3.new(reachRad, reachRad, reachRad)
		elseif reachType == "Linear" then
			Brew.Configuration.reachVector = Vector3.new(1, 0.800000011920929, reachRad * 1.3)
		elseif reachType == "Wide" then
			Brew.Configuration.reachVector = Vector3.new(reachRad * 0.5, reachRad * 0.5, reachRad * 1.3)
		end

		if enabled and Brew.Features.Reach.Enabled then
			Handle.Size = Brew.Configuration.reachVector
		else
			Handle.Size = Brew.Configuration.defaultSize
		end
	end,
	hitboxExtender = function(self, enabled: boolean)
		if Brew.Features.Reach.Thread then
			Brew:endThread(Brew.Features.Reach.Thread.Message)
			Brew.Features.Reach.Thread = nil
		end

		Brew.Features.Reach.Thread = Brew:Thread(function()
			for i, Player in pairs(game:GetService("Players"):GetPlayers()) do
				if Player == game:GetService("Players").LocalPlayer then
					continue
				end
				
				pcall(function()
					local Character = Player.Character
					local Root = Character:FindFirstChild("HumanoidRootPart")
					local reachRad = Brew.Configuration.reachRadius

					Root.CanCollide = false
					Brew:Spoof(Root, "Size", Vector3.new(2, 2, 1))
					if Brew.Configuration.reachMethod["Hitbox Extender"] and Brew.Features.Reach.Enabled then
						Root.Size = Vector3.new(reachRad, reachRad, reachRad)
					else
						Root.Size = Vector3.new(2, 2, 1)
					end
				end)
			end
		end)
	end,
	damageAmplification = function(self, enabled: boolean)
		if Brew.Features.Reach.Thread2 then
			Brew:endThread(Brew.Features.Reach.Thread2.Message)
			Brew.Features.Reach.Thread2 = nil
		end

		if Brew.Configuration.damageAmplification then
			local Handle = Brew.Features:getHandle()
			
			Brew.Features.Reach.Thread2 = Brew:Thread(function()
				local handle = Handle
				local handleCF = handle.CFrame
				local halfSize = (handle.Size * 0.5) * 1.7

				for _, model in ipairs(workspace:GetChildren()) do
					if model ~= Character then
						local humanoid = model:FindFirstChildOfClass("Humanoid")
						local root = model:FindFirstChild("HumanoidRootPart")

						if humanoid and root then
							local localPos = handleCF:PointToObjectSpace(root.Position)

							local dx = math.max(math.abs(localPos.X) - halfSize.X, 0)
							local dy = math.max(math.abs(localPos.Y) - halfSize.Y, 0)
							local dz = math.max(math.abs(localPos.Z) - halfSize.Z, 0)

							if (dx*dx + dy*dy + dz*dz) == 0 then
								for i, v in pairs(model:GetChildren()) do
									if v:IsA("BasePart") then
										task.spawn(function(v)
											for i = 1, 3 do
												pcall(firetouchinterest, v, handle, 0)
												pcall(firetouchinterest, v, handle, 1)
												task.wait()
											end
										end, v)
									end
								end
							end
						end
					end
				end
			end, 0.02)
		end
	end,
	CFrame = function(self, enabled: boolean)
		if Brew.Features.Reach.Thread3 then
			Brew:endThread(Brew.Features.Reach.Thread3.Message)
			Brew.Features.Reach.Thread3 = nil

			-- üßπ CFrame Thread Cleanup </3
			local Handle = Brew.Features:getHandle()
			if Handle:FindFirstChild("lHandle") then
				Handle:FindFirstChild("lHandle"):Destroy()
			end
		end

		if Brew.Configuration.reachMethod.CFrame and Brew.Features.Reach.Enabled then
			local Handle = Brew.Features:getHandle() -- ‚ù§Ô∏è‚Äçü©π This used to be inside the thread, woops

			Brew.Features.Reach.Thread3 = Brew:Thread(function()
				local Parts = workspace:GetPartBoundsInBox(Handle.CFrame, Brew.Configuration.reachVector)
				pcall(function()
					if not Handle:FindFirstChild("lHandle") then
						local lHandle = Instance.new("Part")
						Brew:protectInstance(lHandle)
						lHandle.Parent = Handle
						lHandle.Name = "lHandle"
						lHandle.Transparency = 1
						lHandle.CanCollide = false
						lHandle.Anchored = true
						Brew.Features:viewHitbox(Brew.Features.viewHitbox.Enabled)
					end
					if Handle:FindFirstChild("lHandle") then
						Handle:FindFirstChild("lHandle").Size = Brew.Configuration.reachVector
						Handle:FindFirstChild("lHandle").CFrame = Handle.CFrame
					end
				end)

				for i, v in pairs(Parts) do
					pcall(function() -- üîí "new overlap in different world" & "attempt to index nil"
						if v.Parent:FindFirstChildOfClass("Humanoid") then
							if
								v.Parent ~= Character
								and v.Parent:FindFirstChild("Left Arm")
								and v.Parent:FindFirstChild("Right Arm")
							then
								if not v.Parent:FindFirstChild("B") then
									local conn = v.Parent:FindFirstChild("Humanoid").Died:Connect(function()
										task.spawn(function()
											pcall(function()
												workspace.DFX:WaitForChild(v.Parent.Name, 1.3):WaitForChild("Left Arm", 1.3):Destroy()
												workspace.DFX:WaitForChild(v.Parent.Name, 1.3):WaitForChild("Right Arm", 1.3):Destroy()
											end)
											conn:Disconnect()
										end)
									end)
								end
								local Limb = v.Parent:FindFirstChild("Left Arm")
								if Limb then
									if not v.Parent:FindFirstChild("B") then
										local WL = Instance.new("StringValue")
										WL.Parent = v.Parent
										WL.Name = "B"

										local s, e = pcall(function()
											if v.Parent == Character then return end

											-- Left Arm
											local Rig = v.Parent
											local lArm = Rig["Left Arm"]
											local lMotor = Rig.Torso["Left Shoulder"]:Clone()
											lArm.Parent = workspace
											lArm.CanCollide = false
											lArm.Anchored = true
											lArm:BreakJoints()

											fakeLArm = lArm:Clone()
											fakeLArm.Parent = Rig
											fakeLArm.Anchored = false
											lMotor.Part1 = fakeLArm
											lMotor.Parent = Rig.Torso

											lArm:ClearAllChildren()
											lArm.Transparency = 1
											lArm.Parent = Rig
											lArm.Name = "B Left Arm"

											-- Right Arm
											local rArm = Rig["Left Leg"]
											local rMotor = Rig.Torso["Left Hip"]:Clone()
											rArm.Parent = workspace
											rArm.CanCollide = false
											rArm.Anchored = true
											rArm:BreakJoints()

											fakeRArm = rArm:Clone()
											fakeRArm.Parent = Rig
											fakeRArm.Anchored = false
											rMotor.Part1 = fakeRArm
											rMotor.Parent = Rig.Torso

											rArm:ClearAllChildren()
											rArm.Transparency = 1
											rArm.Parent = Rig
											rArm.Name = "B Left Leg"
										end)
									end
									Limb = v.Parent:FindFirstChild("B Left Arm")
									Limb2 = v.Parent:FindFirstChild("B Left Leg")

									if table.find(Parts, Limb.Parent.HumanoidRootPart) then
										Limb.CFrame = Handle.CFrame
										Limb2.CFrame = Handle.CFrame
										task.spawn(function()
											for i = 1, 30 do
												task.wait()
												firetouchinterest(Limb, handle, 0)
												firetouchinterest(Limb, handle, 1)
												task.wait()
												firetouchinterest(Limb2, handle, 0)
												firetouchinterest(Limb2, handle, 1)
											end
										end)
									else
										Limb.CFrame = Vector3.new(1e1, 0, 0)
										Limb2.CFrame = Vector3.new(1e1, 0, 0)
									end
								end
							end
						end
					end)
				end
			end, .02)
		end
	end,
}

Brew.Features.viewHitbox = {
	Name = "viewHitbox",
	Enabled = false,
	Function = function(self, enabled: boolean)
		Brew.Features.viewHitbox.Enabled = enabled

		local Handle = Brew.Features:getHandle()
		local Color = Brew.Configuration.Color
		local Alpha = Brew.Configuration.Alpha

		if Handle:FindFirstChildOfClass("SelectionBox") then
			Handle:FindFirstChildOfClass("SelectionBox"):Destroy()
		end
		if
			Handle:FindFirstChild("lHandle") and Handle:FindFirstChild("lHandle"):FindFirstChildOfClass("SelectionBox")
		then
			Handle:FindFirstChild("lHandle"):FindFirstChildOfClass("SelectionBox"):Destroy()
		end
		if Brew.Features.viewHitbox.Enabled then
			local Box = Instance.new("SelectionBox")
			Brew:protectInstance(Box)
			Box.Parent = Handle
			Box.Adornee = Handle
			Box.LineThickness = 0.01
			Box.Color3 = Color
			Box.Transparency = Alpha
			if Handle:FindFirstChild("lHandle") then
				local lBox = Instance.new("SelectionBox")
				Brew:protectInstance(lBox)
				lBox.Parent = Handle:FindFirstChild("lHandle")
				lBox.Adornee = Handle:FindFirstChild("lHandle")
				lBox.LineThickness = 0.01
				lBox.Color3 = Color
				lBox.Transparency = Alpha
			end
		end
	end,
}

Brew.Features.viewRoots = {
	Name = "viewRoots",
	Enabled = false,
	Thread = nil,
	Function = function(self, enabled: boolean)
		Brew.Features.viewRoots.Enabled = enabled

		if Brew.Features.viewRoots.Thread then
			Brew:endThread(Brew.Features.viewRoots.Thread.Message)
			Brew.Features.viewRoots.Thread = nil
		end

		Brew.Features.viewRoots.Thread = Brew:Thread(function()
			for i, Player in pairs(game:GetService("Players"):GetPlayers()) do
				if Player == game:GetService("Players").LocalPlayer then
					continue
				end
				pcall(function()
					local Character = Player.Character
					local Root = Character:FindFirstChild("HumanoidRootPart")
					local Color = Brew.Configuration.Color
					local Alpha = Brew.Configuration.Alpha

					if Brew.Features.viewRoots.Enabled then
						if Root:FindFirstChildOfClass("SelectionBox") then
							Box = Root:FindFirstChild("SelectionBox")
							Box.Color3 = Color
							Box.Transparency = Alpha
						else
							local Box = Instance.new("SelectionBox")
							Brew:protectInstance(Box)
							Box.Parent = Root
							Box.Adornee = Root
							Box.LineThickness = 0.01
							Box.Color3 = Color
							Box.Transparency = Alpha
						end
					else
						if Root:FindFirstChildOfClass("SelectionBox") then
							Root:FindFirstChildOfClass("SelectionBox"):Destroy()
						end
					end
				end)
			end
		end)
	end,
}

Brew.Features.Spin = {
	Name = "Spin",
	Enabled = false,
	Function = function(self, enabled: boolean)
		Brew.Features.Spin.Enabled = enabled

		local Root = Character:FindFirstChild("HumanoidRootPart")
		if Root:FindFirstChildOfClass("BodyAngularVelocity") then
			Root:FindFirstChildOfClass("BodyAngularVelocity"):Destroy()
		end
		if enabled then
			local Velocity = Instance.new("BodyAngularVelocity")
			Brew:protectInstance(Velocity)
			Velocity.Parent = Root
			Velocity.AngularVelocity = Vector3.new(0, 75, 0)
			Velocity.MaxTorque = Vector3.new(0, 9e9, 0)
			Velocity.P = 1250
		end
	end,
}

Brew.Features.orbExpander = {
	Name = "orbExpander",
	Enabled = false,
	Thread = nil,
	Function = function(self, enabled: boolean)
		Brew.Features.orbExpander.Enabled = enabled
		if Brew.Features.orbExpander.Thread then
			Brew:endThread(Brew.Features.orbExpander.Thread["Message"])
			Brew.Features.orbExpander.Thread = nil
		end

		local Orbs = workspace.Orbs
		Brew.Features.orbExpander.Thread = Brew:Thread(function()
			for i, Orb in pairs(Orbs:GetChildren()) do
				if enabled then
					Orb["Black"].Size = Vector3.new(10, 10, 10)
				else
					Orb["Black"].Size = Vector3.new(2.1500000953674316, 2.1500000953674316, 2.1500000953674316)
				end
			end
		end)
	end,
}

Brew.Features.Jitter = {
	Name = "Jitter",
	Enabled = false,
	Thread = nil,
	Function = function(self, enabled: boolean, caller: string)
		caller = caller or "user" -- üëÄ Prevent jitter from activating on respawn
		if caller == "auto" then
			Brew.Features.Jitter.Enabled = false
		else
			Brew.Features.Jitter.Enabled = not Brew.Features.Jitter.Enabled
		end

		if Brew.Features.Jitter.Thread then
			Brew:endThread(Brew.Features.Jitter.Thread["Message"])
			Brew.Features.Jitter.Thread = nil

			-- üßπ Jitter Cleanup
			Character:FindFirstChildOfClass("Humanoid").AutoRotate = true
		end

		if Brew.Features.Jitter.Enabled then
			Character:FindFirstChildOfClass("Humanoid").AutoRotate = false

			local Root = Character:FindFirstChild("HumanoidRootPart")
			local Camera = workspace.CurrentCamera
			local t = 0

			Brew.Features.Jitter.Thread = Brew:Thread(function()
				if not Root or not Root.Parent or not Camera then
					return
				end

				t += 1 * 75
				local baseJitter = math.rad(math.random(5, 20))
				local jitterY = math.sin(t) * 0.3 * baseJitter * (math.random() > 0.5 and 1 or -1)

				local camLook = Camera.CFrame.LookVector
				local rootPos = Root.Position
				local targetPos = rootPos + Vector3.new(camLook.X, 0, camLook.Z).Unit

				Root.CFrame = CFrame.new(rootPos, targetPos) * CFrame.Angles(0, jitterY, 0)
			end, 0.03)
		end
	end,
}

Brew.Features.Flicker = {
	Name = "Flicker",
	Enabled = false,
	Thread = nil,
	Thread2 = nil,
	Function = function(self, enabled: boolean)
		Brew.Notify("‚ö†Ô∏è [Flicker] This feature is temporarily disabled")
	end,
}

Brew.Features.swordGiver = {
	Name = "Sword Giver",
	Enabled = false,
	Function = function(self, swords: table)
		for i, Sword in pairs(Brew.Configuration.gameSwords) do
			if swords[Sword] and not Player.PlayerStats.PlayerSwords:FindFirstChild(Sword) then
				local newSword = Instance.new("BoolValue", Player.PlayerStats.PlayerSwords)
				newSword.Value = true
				newSword.Name = Sword
				newSword.Parent = Player.PlayerStats.PlayerSwords
			elseif not swords[Sword] then
				if Player.PlayerStats.PlayerSwords:FindFirstChild(Sword) then
					Player.PlayerStats.PlayerSwords:FindFirstChild(Sword):Destroy()
				end
			end
		end
	end,
}

Brew.Features.Tank = {
	Name = "Tank",
	Enabled = false,
	Function = function(self, enabled: boolean)
		Brew.Features.Tank.Enabled = enabled

		for i, Part in pairs(Character:GetChildren()) do
			if Part:IsA("BasePart") then
				Brew:Spoof(Part, "CanTouch", true)
				Part.CanTouch = not Brew.Features.Tank.Enabled
			end
		end
	end,
}

Brew.Features.Speed = {
	Name = "Speed",
	Enabled = false,
	Thread = nil,
	Cache = {
		sameThread = false,
		Speed = 16,
	},
	Function = function(self, value: int)
		value = value or Brew.Features.Speed.Cache.Speed
		Brew.Features.Speed.Cache.Speed = value
		Brew.Features.Speed.Cache.sameThread = false
		if Brew.Features.Speed.Thread then
			Brew:endThread(Brew.Features.Speed.Thread["Message"])
			Brew.Features.Speed.Thread = nil
		end

		Brew.Features.Speed.Thread = Brew:Thread(function()
			Brew:Spoof(Character.Humanoid, "WalkSpeed", 16)
			if tonumber(value) >= 25 then
				Character.Humanoid.WalkSpeed = 24
				if not Brew.Features.Speed.Cache.sameThread then
					Brew.Notify("[Speed] Defaulted to 24 to prevent rubberbanding (lagback)")
					Brew.Features.Speed.Cache.sameThread = true
				end
			else
				Character.Humanoid.WalkSpeed = tonumber(value)
			end
		end, 0.1)
	end,
}

Brew.Features.Desync = {
	Name = "Desync",
	Enabled = false,
	Model = nil,
	Thread = nil,
	Function = function(self, enabled: boolean, caller: string)
		Brew.Features.Desync.Enabled = enabled
		if Brew.Features.Desync.Thread then
			Brew:endThread(Brew.Features.Desync.Thread["Message"])
			Brew.Features.Desync.Thread = nil
		end
		if string.match(identifyexecutor():lower(), "solara") or string.match(identifyexecutor():lower(), "xeno") then 
			Brew.Notify("‚ùå [Desync] Your executor does not support this feature")
			return
		end
		if Brew.Features.Invisible.Enabled then 
			Brew.Notify("üò∫ [Invisible] Press 'Invisible' again to disable")
		end

		setfflag("NextGenReplicatorEnabledWrite4", "False")
		if not Brew.Features.Invisible.Enabled then
			setfflag("NextGenReplicatorEnabledWrite4", "False")
			if caller == "auto" then setfflag("NextGenReplicatorEnabledWrite4", "False") wait(2) end
		end
		if Brew.Features.Desync.Enabled then
			local s, e = pcall(function()
				Brew.Features.Desync.Thread = Brew:Thread(function()
					setfflag("NextGenReplicatorEnabledWrite4", "False")
					local initPos = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame

					task.spawn(function()
						if Brew.Features.Invisible.Enabled then return end

						local Model = Instance.new("Model", workspace)
						game.Debris:AddItem(Model, Brew.Configuration.desyncRate)
						local Humanoid = Instance.new("Humanoid", Model)
						local Part = Instance.new("Part", Model)
						local Highlight = Instance.new("Highlight", Part)
						Part.Transparency = .99
						Part.Size = Vector3.new(3,6,3)
						Part.Anchored = true
						Part.CanCollide = false
						Part.CanQuery = false
						Part.CFrame = initPos
						Highlight.Adornee = Part
						Highlight.DepthMode = Enum.HighlightDepthMode.Occluded
						Highlight.Enabled = true
						Highlight.FillTransparency = Brew.Configuration.desyncAlpha + .3
						Highlight.OutlineTransparency = Brew.Configuration.desyncAlpha
						Highlight.OutlineColor = Brew.Configuration.desyncColor
						Highlight.FillColor = Brew.Configuration.desyncColor
					end)
					task.wait(Brew.Configuration.desyncRate)
					setfflag("NextGenReplicatorEnabledWrite4", "True")
				end, Brew.Configuration.desyncRate * 2)
			end)
			if not s then Brew.Notify("‚ùå [Desync] Your executor does not support desync") Brew.debugNotify("[Desync]", e) Brew.Features:Desync(false) end
		else
			if Brew.Features.Desync.Model then 
				Brew.Features.Desync.Model:Destroy()
				Brew.Features.Desync.Model = nil
			end
			setfflag("NextGenReplicatorEnabledWrite4", "False")
		end		
	end,
}

Brew.Features.Invisible = {
	Name = "Invisible",
	Enabled = false,
	Thread = nil,
	Function = function(self, w: any, caller: string)
		if caller == "auto" then return end
		if Brew.Features.Invisible.Thread then
			Brew:endThread(Brew.Features.Invisible.Thread["Message"])
			Brew.Features.Invisible.Thread = nil
		end
		if string.match(identifyexecutor():lower(), "solara") or string.match(identifyexecutor():lower(), "xeno") then 
			Brew.Notify("‚ùå [Desync] Your executor does not support this feature")
			return
		end

		--: Thread Management
		Brew.Features.Invisible.Enabled = w
		Brew.Features:Desync(false)

		--: Invisibility
		if w then
			Window:Dialog({
				Title = "Brew",
				Description = "Be warned this feature is blatant.\nYou might also be seen teleporting around the map & be un-killable.",
				Buttons = {
					{
						Name = "Confirm",
					},
				},
			})
			if not isfile('invis.brew') then writefile('invis.brew', 'hi') end

			setfflag("NextGenReplicatorEnabledWrite4", "True")
			task.wait()
			setfflag("NextGenReplicatorEnabledWrite4", "False")
			Character:BreakJoints()
			Brew.Features.Invisible.Thread = Brew:Thread(function()
				setfflag("NextGenReplicatorEnabledWrite4", "True")
			end, 0)
		else
			pcall(delfile, "invis.brew")
			Brew.Notify("üîÑÔ∏è [Invisible] Attempting to disable invisibility")
			setfflag("NextGenReplicatorEnabledWrite4", "True")
			task.wait()
			setfflag("NextGenReplicatorEnabledWrite4", "False")
			if Character:FindFirstChild("Animate") then
				Character.Animate.Disabled = false
			end
			for i, v in pairs(Character:GetChildren()) do 
				if v:IsA("BasePart") then v.Transparency = 0 end
			end
			Character.HumanoidRootPart.Transparency = 1
			Brew.Notify("‚úÖ [Invisible] Invisibility disabled")
		end
	end
}

Brew.Features.lookAt = {
	Name = "Look At",
	Enabled = false,
	Thread = nil,
	Function = function(self, enabled: boolean)
		Brew.Features.lookAt.Enabled = enabled
		if Brew.Features.lookAt.Thread then
			Brew:endThread(Brew.Features.lookAt.Thread["Message"])
			Brew.Features.lookAt.Thread = nil
		end

		if enabled then
			Brew.Features.lookAt.Thread = Brew:Thread(function()
				local char = Character
				local root = Character:FindFirstChild("HumanoidRootPart")
				if not root then return end

				local closestRoot = nil
				local closestDist = Brew.Configuration.reachRadius

				for _, model in ipairs(workspace:GetChildren()) do
					if model ~= char then
						local hum = model:FindFirstChildOfClass("Humanoid")
						local hrp = model:FindFirstChild("HumanoidRootPart")

						if hum and hrp and hum.Health > 0 then
							local dist = (hrp.Position - root.Position).Magnitude
							if dist <= closestDist then
								closestDist = dist
								closestRoot = hrp
							end
						end
					end
				end

				if closestRoot then
					local targetCF = CFrame.lookAt(
						root.Position,
						Vector3.new(
							closestRoot.Position.X,
							root.Position.Y,
							closestRoot.Position.Z
						)
					)

					root.CFrame = root.CFrame:Lerp(targetCF, .43)
				end
			end, 0.016)
		end
	end,
}

for i, Feature in Brew.Features do -- üòã Metatable Magic
	setmetatable(Feature, {
		__call = function(table, ...)
			local s, e = pcall(table.Function, ...)
			
			if s then
				-- Brew.debugNotify("hi lol argument return on", Feature.Name .. ":", e)
				return e
			else
				Brew.debugNotify("Error while calling", Feature.Name .. ":", e)
			end
		end,
	})
end
local s, e = pcall(function()
	if isfile('patch.brew') then
		setfflag("NextGenReplicatorEnabledWrite4", "True")
		task.wait()
		setfflag("NextGenReplicatorEnabledWrite4", "False")
		Brew.Notify("‚úÖ [Brew] Desync instance(s) have been removed")
		delfile('patch.brew')
		pcall(delfile, "invis.brew")
	end
	if isfile('invis.brew') then 
		writefile('patch.brew', 'ok')
		setfflag("NextGenReplicatorEnabledWrite4", "True")
		task.wait()
		setfflag("NextGenReplicatorEnabledWrite4", "False")
		Window:Notify({
			Title = "Brew",
			Description = "‚ö†Ô∏è [Brew] Previous desync instance detected, rejoin to not be detected",
			Lifetime = 9e9,
			Scale = 1.2,
			Style = "Confirm",
			Callback = function()
				game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, Player)
			end
		})
	end
end)
if not s then 
	Brew.Notify("üôÄ [Brew] An error has occured while Desync patching\n" .. e)
end

--< Brew Interface >--
local reachGroup = Window:TabGroup()
local reachTab = reachGroup:Tab({
	Name = "Reach",
	Image = "rbxassetid://10709818534",
})
local reachSection = reachTab:Section({
	Side = "Left",
})

local reachToggle = reachSection:Toggle({
	Name = "Reach",
	Default = false,
	Callback = function(t)
		Brew.Features:Reach(t)
	end,
})
local reachRadius = reachSection:Slider({
	Name = "Reach Radius",
	Default = 5,
	Minimum = 1,
	Maximum = 20,
	DisplayMethod = "Round",
	Callback = function(t)
		Brew.Configuration.reachVector = Vector3.new(t, t, t)
		Brew.Configuration.reachRadius = t

		Brew.Features:Reach(Brew.Features.Reach.Enabled)
	end,
})
local reachMethod = reachSection:Dropdown({
	Name = "Reach Method",
	Search = false,
	Multi = true,
	Required = true,
	Options = Brew.Configuration.allowedMethods,
	Default = { Brew.Configuration.allowedMethods[1] },
	Callback = function(t)
		Brew.Configuration.reachMethod = t

		Brew.Features:Reach(Brew.Features.Reach.Enabled)
	end,
})
local reachType = reachSection:Dropdown({
	Name = "Reach Type",
	Search = false,
	Multi = false,
	Required = true,
	Options = {
		"Box",
		"Linear",
		"Wide",
	},
	Default = 1,
	Callback = function(t)
		Brew.Configuration.reachType = t

		Brew.Features:Reach(Brew.Features.Reach.Enabled)
	end,
})
reachSection:Dropdown({
	Name = "Reach Preset",
	Search = false,
	Multi = false,
	Required = true,
	Options = {
		"Closet",
	},
	Callback = function(t)
		if t == "Closet" then
			Brew.Configuration.reachVector = Vector3.new(4, 4, 4)
			Brew.Configuration.reachRadius = 4
			Brew.Configuration.reachMethod = Brew.Configuration.allowedMethods[1]

			reachMethod:UpdateSelection({ Brew.Configuration.allowedMethods[1] })
			reachType:UpdateSelection("Wide")
			reachRadius:UpdateValue(4)

			Brew.Features:Reach(Brew.Features.Reach.Enabled)
		end
	end,
})
reachSection:Toggle({
	Name = "Damage Amplification",
	Default = false,
	Callback = function(t)
		Brew.Configuration.damageAmplification = t

		Brew.Features.Reach:damageAmplification(Brew.Features.Reach.Enabled)
	end,
})
reachSection:SubLabel({
	Text = "Please be advised your exploit may not be able to completely prevent anti-cheat measures",
})

local visualSection = reachTab:Section({
	Side = "Right",
})
visualSection:Toggle({
	Name = "View Hitbox",
	Default = false,
	Callback = function(t)
		local Color = Brew.Configuration.Color
		local Alpha = Brew.Configuration.Alpha

		Brew.Features:viewHitbox(t)
	end,
})
visualSection:Toggle({
	Name = "View Roots",
	Default = false,
	Callback = function(t)
		local Color = Brew.Configuration.Color
		local Alpha = Brew.Configuration.Alpha

		Brew.Features:viewRoots(t)
	end,
})
visualSection:Colorpicker({
	Name = "Color",
	Default = Color3.fromRGB(255, 255, 255),
	Alpha = 0,
	Callback = function(color, alpha)
		Brew.Configuration.Color = color
		Brew.Configuration.Alpha = alpha

		Brew.Features:viewHitbox(Brew.Features.viewHitbox.Enabled)
		Brew.Features:viewRoots(Brew.Features.viewRoots.Enabled)
	end,
})

local characterTab = reachGroup:Tab({
	Name = "Character",
	Image = "rbxassetid://10747373176",
})
local characterSection = characterTab:Section({
	Side = "Left",
})
local characterSection2 = characterTab:Section({
	Side = "Right",
})


characterSection:Input({
	Name = "Speed",
	Placeholder = "1 - 24",
	AcceptedCharacters = "Numeric",
	Callback = function(input)
		if Brew.Configuration.spoofMethod ~= "none" then
			Brew.Features:Speed(tonumber(input))
		else
			Brew.Notify("[Speed] Your exploit cannot support this feature properly")
		end
	end,
})

characterSection:Toggle({
	Name = "Spin",
	Default = false,
	Callback = function(t)
		Brew.Features:Spin(t)
	end,
})

local desyncToggle = characterSection2:Toggle({
	Name = "Desync",
	Default = false,
	Callback = function(t)
		Brew.Features:Desync(t)
	end,
})
local invisButton = characterSection2:Button({
	Name = "Invisibility",
	Callback = function()
		Brew.Features:Invisible(not Brew.Features.Invisible.Enabled)
	end,
})
local invisHint = characterSection2:SubLabel({
	Text = "Make sure you're in the safe zone to use invisibility\nYou can click again to disable invisibility",
})

characterSection2:Input({
	Name = "Desync Rate",
	Placeholder = "0 - 9e9",
	AcceptedCharacters = "Numeric",
	Callback = function(input)
		Brew.Configuration.desyncRate = input

		Brew.Features:Desync(Brew.Features.Desync.Enabled)
	end,
})
characterSection2:Colorpicker({
	Name = "Desync Color",
	Default = Color3.fromRGB(255, 255, 255),
	Alpha = 0,
	Callback = function(color, alpha)
		Brew.Configuration.desyncColor = color
		Brew.Configuration.desyncAlpha = alpha
	end,
})
characterSection2:Paragraph({
  Header = "Desync Info",
  Body = "Please be wary, this can look suspicious if not configured correctly\n\nDesync Rate above 1 is not recommended, please make sure you know what you're doing\n\nUse with caution."
})
-- characterSection2:Paragraph({
--   Header = "Desync Info",
--   Body = "Desync features currently under maintenance"
-- })
local flickerToggle = characterSection:Toggle({
	Name = "Flicker",
	Default = false,
	Callback = function(t)
		Brew.Features:Flicker(t)
	end,
})

characterSection:Toggle({
	Name = "Tank",
	Default = false,
	Callback = function(t)
		Brew.Features:Tank(t)
	end,
})

local legitTab = reachGroup:Tab({
	Name = "Legit",
	Image = "rbxassetid://10734906580",
})
local legitSection = legitTab:Section({
	Side = "Left",
})
local jitterToggle = legitSection:Toggle({
	Name = "Jitter",
	Default = false,
	Callback = function(t)
		Brew.Features:Jitter(t, "user")
	end,
})
legitSection:SubLabel({
	Text = "This can be paired with damage amplification",
})
local lookatToggle = legitSection:Toggle({
	Name = "Look At",
	Default = false,
	Callback = function(t)
		Brew.Features:lookAt(t)
	end,
})
legitSection:SubLabel({
	Text = "Features here were made & tested live to determine legitimacy, what may look suspicious on your screen does not reflect to other players",
})

local environmentTab = reachGroup:Tab({
	Name = "Environment",
	Image = "rbxassetid://10723404337",
})
local environmentSection = environmentTab:Section({
	Side = "Left",
})
local orbExpander = environmentSection:Toggle({
	Name = "Orb Expander",
	Default = false,
	Callback = function(t)
		Brew.Features:orbExpander(t)
	end,
})
local swordGiverTab = environmentSection:Dropdown({
	Name = "Sword Giver",
	Search = true,
	Multi = true,
	Required = false,
	Options = Brew.Configuration.gameSwords,
	Callback = function(t)
		Brew.Features:swordGiver(t)
	end,
})
local getAllSwordsButton = environmentSection:Button({
	Name = "Get All Swords",
	Callback = function()
		swordGiverTab:UpdateSelection(Brew.Configuration.gameSwords)
	end,
})
if game.GameId ~= 3737753748 then
	orbExpander:SetVisibility(false)
	swordGiverTab:SetVisibility(false)
	getAllSwordsButton:SetVisibility(false)
end
environmentSection:SubLabel({
	Text = "If this page is empty for you, the game you've joined likely has no cheats yet, feel free to request some!",
})

local customizeGroup = Window:TabGroup()
local customizeTab = customizeGroup:Tab({
	Name = "Customize",
	Image = "rbxassetid://10709810948",
})
local customizeSection = customizeTab:Section({
	Side = "Left",
})
local customizeSection2 = customizeTab:Section({
	Side = "Right",
})
customizeSection:Toggle({
	Name = "Notifications",
	Default = true,
	Callback = function(t)
		Brew.Configuration.Notifications = t
	end,
})
customizeSection:Toggle({
	Name = "Debug Notifications",
	Default = false,
	Callback = function(t)
		Brew.Configuration.debugNotifications = t
	end,
})
customizeSection:Button({
	Name = "UI Scale",
	Callback = function()
		if Window:GetScale() == originalScale then
			Window:SetScale(originalScale * 0.55)
		else
			Window:SetScale(originalScale)
		end
	end,
})
customizeSection:Button({
	Name = "Rejoin",
	Callback = function()
		game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, Player)
	end,
})
customizeSection2:Keybind({
	Name = "Reach Keybind",
	Default = Enum.KeyCode.R,
	Callback = function(binded)
		reachToggle:UpdateState(not Brew.Features.Reach.Enabled)
	end,
	onBinded = function(bind)
		Brew.Notify("Binded", "Reach to", bind)
	end,
})
customizeSection2:Keybind({
	Name = "Jitter Keybind",
	Default = Enum.KeyCode.G,
	Callback = function(binded)
		jitterToggle:UpdateState(not Brew.Features.Jitter.Enabled)
	end,
	onBinded = function(bind)
		Brew.Notify("Binded", "Jitter to", bind)
	end,
})
customizeSection2:Keybind({
	Name = "Flicker Keybind",
	Default = Enum.KeyCode.Z,
	Callback = function(binded)
		flickerToggle:UpdateState(not Brew.Features.Flicker.Enabled)
	end,
	onBinded = function(bind)
		Brew.Notify("Binded", "Flicker to", bind)
	end,
})
customizeSection2:Keybind({
	Name = "Desync Keybind",
	Default = Enum.KeyCode.X,
	Callback = function(binded)
		desyncToggle:UpdateState(not Brew.Features.Desync.Enabled)
	end,
	onBinded = function(bind)
		Brew.Notify("Binded", "Desync to", bind)
	end,
})
customizeSection2:Paragraph({
	Header = "Coming soon",
	Body = "Next update will contain a configuration system, allowing you to save & load configs."
})
-- local configDropdown = customizeSection2:Dropdown({
-- 	Name = "Load Configuration",
-- 	Multi = false,
-- 	Required = false,
-- 	Options = {},
-- 	Callback = function(t)
-- 		if not t then return end
-- 		MacLib:LoadConfig(t)
-- 	end,
-- })
-- for i, config in pairs(MacLib:RefreshConfigList()) do
-- 	if not configDropdown:GetOptions()[config] then 
-- 		configDropdown:InsertOptions({config})
-- 	end
-- end
-- customizeSection2:Button({
-- 	Name = "Save Configuration",
-- 	Callback = function()
-- 		for i, config in pairs(MacLib:RefreshConfigList()) do
-- 			warn(i, config)
			
-- 			if not configDropdown:GetOptions()[config] then
-- 				configDropdown:InsertOptions({config})
-- 			end
-- 		end
-- 		MacLib:SaveConfig(Brew.Configuration.saveConfigName)
-- 	end
-- })
-- customizeSection2:Input({
-- 	Name = "Config Name",
-- 	Placeholder = "brewconfig1",
-- 	AcceptedCharacters = "All",
-- 	Callback = function(input)
-- 		Brew.Configuration.saveConfigName = tostring(input)
-- 	end
-- })

--< Brew Mobile >--
if debug.info(2, "f") == nil then
	Window:Notify({
		Title = "Brew",
		Description = "Outdated script, please use the loadstring for the latest updates & security features",
		Lifetime = 5,
		Scale = 1.2,
		Style = "Cancel",
	})
end

if Brew.Configuration.isMobile then
	Window:Dialog({
		Title = "Brew",
		Description = "Would you like to make the UI smaller? You can toggle this in the customization tab",
		Buttons = {
			{
				Name = "Confirm",
				Callback = function()
					Window:SetScale(originalScale * 0.55)
				end
			},
			{
				Name = "Cancel",
			}
		},
	})

	task.wait(2)
    local ScreenGui = Instance.new("ScreenGui")
    local ImageButton = Instance.new("ImageButton")
	
    ScreenGui.Parent = gethui() or game.CoreGui
	ScreenGui.ScreenInsets = Enum.ScreenInsets.None
	ScreenGui.ResetOnSpawn = false
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    ScreenGui.DisplayOrder = 2

    ImageButton.Parent = ScreenGui
    ImageButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    ImageButton.BackgroundTransparency = 1.000
    ImageButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
    ImageButton.BorderSizePixel = 0
    ImageButton.Position = UDim2.new(0.399686515, 0, 0.462569833, 0)
    ImageButton.Size = UDim2.new(0, 66, 0, 66)
    ImageButton.Image = "rbxassetid://12807028788"

    local dragging = false
    local dragInput, dragStart, startPos
	local Hidden = false

    ImageButton.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = ImageButton.Position
			Hidden = not Hidden
			Window:SetState(Hidden)

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    ImageButton.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    RunService.RenderStepped:Connect(function()
        if dragging and dragInput then
            local delta = dragInput.Position - dragStart
            ImageButton.Position = UDim2.new(
                startPos.X.Scale,
                startPos.X.Offset + delta.X,
                startPos.Y.Scale,
                startPos.Y.Offset + delta.Y
            )
        end
    end)
end

--< Brew Integrity >--
Brew:Thread(function() -- üóëÔ∏è Garbage Collector
	local Amount = 0
	for i = #Brew._Temp, 1, -1 do
		local Table = Brew._Temp[i]
		if Table.index.Parent == nil then
			table.remove(Brew._Temp, i)
			Amount += 1
		end
	end
	if Amount > 0 then
		Brew.debugNotify("Garbage Collection cleaned", Amount, "object(s)")
	end
end, 30)

Player.CharacterAdded:Connect(function(newCharacter) -- üí©üí©
	Character = newCharacter
	local Sword = Brew.Features:getSword()
	local Handle = Brew.Features:getHandle() -- üîÑÔ∏è acts as a wait

	if Brew.Features.Invisible.Enabled then 
		if Character:FindFirstChild("Animate") then -- gives afk appearance üî• so no more walking in place
			Character.Animate.Disabled = true
		end
		for i, v in pairs(Character:GetChildren()) do 
			if v:IsA("BasePart") then v.Transparency = .67 end -- SIX SEVEN
		end
	else
		-- setfflag("NextGenReplicatorEnabledWrite4", "False") -- should disable invis üòø
	end

	for i, feature in pairs(Brew.Features) do
		if feature.Name == "Flicker" or feature.Name == "Desync" then
			continue
		end

		--/ Refresh Settings /--
		task.spawn(function()
			pcall(function()
				feature:Function(feature.Enabled, "auto")
			end)
		end)
	end
end)
Player.Character.Humanoid.Died:Connect(function()
	if Brew.Features.Desync.Enabled and not Brew.Features.Invisible.Enabled then
		for i = 1, 5 do 
			setfflag("NextGenReplicatorEnabledWrite4", "False")
		end
	end
end)

if Brew.Configuration.spoofMethod == "metamethod" then
    if hookmetamethod then
        local old
        old = hookmetamethod(game, "__index", function(i, v)
            if not checkcaller() then
                local instTable = Brew._Temp[i]
                if instTable and instTable[v] ~= nil then
                    return instTable[v]
                end
            end
            return old(i, v)
        end)
    end
elseif Brew.Configuration.spoofMethod == "metatable" then
    Brew.Notify("[Spoof] You are using", Brew.Configuration.spoofMethod, "spoofing, it may be unstable")

    local mt = getrawmetatable(game)
    setreadonly(mt, false)
    local oldIndex = mt.__index

    mt.__index = newcclosure(function(i, v)
        if not checkcaller() then
            local instTable = Brew._Temp[i]
            if instTable and instTable[v] ~= nil then
                return instTable[v]
            end
        end
        return oldIndex(i, v)
    end)
end